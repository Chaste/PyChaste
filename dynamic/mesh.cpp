// This file has been generated by Py++.

#include "boost/python.hpp"

#include "indexing_suite/value_traits.hpp"

#include "indexing_suite/container_suite.hpp"

#include "indexing_suite/vector.hpp"

#include "indexing_suite/set.hpp"

#include "mesh_headers.hpp"

namespace bp = boost::python;

struct AbstractMesh_less__2_comma__2__greater__wrapper : AbstractMesh< 2, 2 >, bp::wrapper< AbstractMesh< 2, 2 > > {

    AbstractMesh_less__2_comma__2__greater__wrapper( )
    : AbstractMesh<2, 2>( )
      , bp::wrapper< AbstractMesh< 2, 2 > >(){
        // null constructor
    
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumNodes( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 2, 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 2, 2 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 2, 2 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 2, 2 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" );
        return func_SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct AbstractMesh_less__3_comma__3__greater__wrapper : AbstractMesh< 3, 3 >, bp::wrapper< AbstractMesh< 3, 3 > > {

    AbstractMesh_less__3_comma__3__greater__wrapper( )
    : AbstractMesh<3, 3>( )
      , bp::wrapper< AbstractMesh< 3, 3 > >(){
        // null constructor
    
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumNodes( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 3, 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 3, 3 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 3, 3 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 3, 3 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" );
        return func_SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper : AbstractTetrahedralMesh< 2, 2 >, bp::wrapper< AbstractTetrahedralMesh< 2, 2 > > {

    AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper( )
    : AbstractTetrahedralMesh<2, 2>( )
      , bp::wrapper< AbstractTetrahedralMesh< 2, 2 > >(){
        // null constructor
    
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 2, 2 > & rMeshReader ){
        bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" );
        func_ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        AbstractTetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumVertices( );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        AbstractTetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" );
        return func_SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" );
        return func_SolveElementMapping( index );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumNodes( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 2, 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 2, 2 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 2, 2 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" );
        return func_SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper : AbstractTetrahedralMesh< 3, 3 >, bp::wrapper< AbstractTetrahedralMesh< 3, 3 > > {

    AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper( )
    : AbstractTetrahedralMesh<3, 3>( )
      , bp::wrapper< AbstractTetrahedralMesh< 3, 3 > >(){
        // null constructor
    
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 3, 3 > & rMeshReader ){
        bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" );
        func_ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        AbstractTetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumVertices( );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        AbstractTetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" );
        return func_SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" );
        return func_SolveElementMapping( index );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumNodes( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 3, 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 3, 3 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 3, 3 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" );
        return func_SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct TetrahedralMesh_less__2_comma__2__greater__wrapper : TetrahedralMesh< 2, 2 >, bp::wrapper< TetrahedralMesh< 2, 2 > > {

    TetrahedralMesh_less__2_comma__2__greater__wrapper( )
    : TetrahedralMesh<2, 2>( )
      , bp::wrapper< TetrahedralMesh< 2, 2 > >(){
        // null constructor
    
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->TetrahedralMesh< 2, 2 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        TetrahedralMesh< 2, 2 >::Clear( );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 2, 2 > & rMeshReader ) {
        if( bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" ) )
            func_ConstructFromMeshReader( boost::ref(rMeshReader) );
        else{
            this->TetrahedralMesh< 2, 2 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
        }
    }
    
    void default_ConstructFromMeshReader( ::AbstractMeshReader< 2, 2 > & rMeshReader ) {
        TetrahedralMesh< 2, 2 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual void GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetJacobianForElement = this->get_override( "GetJacobianForElement" ) )
            func_GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        }
    }
    
    void default_GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForElement = this->get_override( "GetWeightedDirectionForElement" ) )
            func_GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->TetrahedralMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        TetrahedralMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshJacobianCachedData(  ) {
        if( bp::override func_RefreshJacobianCachedData = this->get_override( "RefreshJacobianCachedData" ) )
            func_RefreshJacobianCachedData(  );
        else{
            this->TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData(  );
        }
    }
    
    void default_RefreshJacobianCachedData(  ) {
        TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData( );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->TetrahedralMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        TetrahedralMesh< 2, 2 >::RefreshMesh( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        if( bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" ) )
            return func_SolveBoundaryElementMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveBoundaryElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveBoundaryElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        if( bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" ) )
            return func_SolveElementMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumNodes( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumVertices( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 2, 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 2, 2 >::GetWidth( rDimension );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships( );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct MutableMesh_less__2_comma__2__greater__wrapper : MutableMesh< 2, 2 >, bp::wrapper< MutableMesh< 2, 2 > > {

    MutableMesh_less__2_comma__2__greater__wrapper( )
    : MutableMesh<2, 2>( )
      , bp::wrapper< MutableMesh< 2, 2 > >(){
        // null constructor
    
    }

    MutableMesh_less__2_comma__2__greater__wrapper(::std::vector< Node<2> * > nodes )
    : MutableMesh<2, 2>( nodes )
      , bp::wrapper< MutableMesh< 2, 2 > >(){
        // constructor
    
    }

    virtual unsigned int AddNode( ::Node< 2 > * pNewNode ) {
        if( bp::override func_AddNode = this->get_override( "AddNode" ) )
            return func_AddNode( boost::python::ptr(pNewNode) );
        else{
            return this->MutableMesh< 2, 2 >::AddNode( boost::python::ptr(pNewNode) );
        }
    }
    
    unsigned int default_AddNode( ::Node< 2 > * pNewNode ) {
        return MutableMesh< 2, 2 >::AddNode( boost::python::ptr(pNewNode) );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->MutableMesh< 2, 2 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        MutableMesh< 2, 2 >::Clear( );
    }

    virtual void DeleteElement( unsigned int index ) {
        if( bp::override func_DeleteElement = this->get_override( "DeleteElement" ) )
            func_DeleteElement( index );
        else{
            this->MutableMesh< 2, 2 >::DeleteElement( index );
        }
    }
    
    void default_DeleteElement( unsigned int index ) {
        MutableMesh< 2, 2 >::DeleteElement( index );
    }

    virtual void DeleteNode( unsigned int index ) {
        if( bp::override func_DeleteNode = this->get_override( "DeleteNode" ) )
            func_DeleteNode( index );
        else{
            this->MutableMesh< 2, 2 >::DeleteNode( index );
        }
    }
    
    void default_DeleteNode( unsigned int index ) {
        MutableMesh< 2, 2 >::DeleteNode( index );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->MutableMesh< 2, 2 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return MutableMesh< 2, 2 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->MutableMesh< 2, 2 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return MutableMesh< 2, 2 >::GetNumElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->MutableMesh< 2, 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return MutableMesh< 2, 2 >::GetNumNodes( );
    }

    virtual void ReMesh( ::NodeMap & map ) {
        if( bp::override func_ReMesh = this->get_override( "ReMesh" ) )
            func_ReMesh( boost::ref(map) );
        else{
            this->MutableMesh< 2, 2 >::ReMesh( boost::ref(map) );
        }
    }
    
    void default_ReMesh( ::NodeMap & map ) {
        MutableMesh< 2, 2 >::ReMesh( boost::ref(map) );
    }

    virtual void SetNode( unsigned int index, ::ChastePoint< 2 > point, bool concreteMove=true ) {
        if( bp::override func_SetNode = this->get_override( "SetNode" ) )
            func_SetNode( index, point, concreteMove );
        else{
            this->MutableMesh< 2, 2 >::SetNode( index, point, concreteMove );
        }
    }
    
    void default_SetNode( unsigned int index, ::ChastePoint< 2 > point, bool concreteMove=true ) {
        MutableMesh< 2, 2 >::SetNode( index, point, concreteMove );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 2, 2 > & rMeshReader ) {
        if( bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" ) )
            func_ConstructFromMeshReader( boost::ref(rMeshReader) );
        else{
            this->TetrahedralMesh< 2, 2 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
        }
    }
    
    void default_ConstructFromMeshReader( ::AbstractMeshReader< 2, 2 > & rMeshReader ) {
        TetrahedralMesh< 2, 2 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual void GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetJacobianForElement = this->get_override( "GetJacobianForElement" ) )
            func_GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        }
    }
    
    void default_GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumVertices( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForElement = this->get_override( "GetWeightedDirectionForElement" ) )
            func_GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 2, 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 2, 2 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->TetrahedralMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        TetrahedralMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshJacobianCachedData(  ) {
        if( bp::override func_RefreshJacobianCachedData = this->get_override( "RefreshJacobianCachedData" ) )
            func_RefreshJacobianCachedData(  );
        else{
            this->TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData(  );
        }
    }
    
    void default_RefreshJacobianCachedData(  ) {
        TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData( );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->TetrahedralMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        TetrahedralMesh< 2, 2 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        if( bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" ) )
            return func_SolveBoundaryElementMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveBoundaryElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveBoundaryElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        if( bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" ) )
            return func_SolveElementMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct TetrahedralMesh_less__3_comma__3__greater__wrapper : TetrahedralMesh< 3, 3 >, bp::wrapper< TetrahedralMesh< 3, 3 > > {

    TetrahedralMesh_less__3_comma__3__greater__wrapper( )
    : TetrahedralMesh<3, 3>( )
      , bp::wrapper< TetrahedralMesh< 3, 3 > >(){
        // null constructor
    
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->TetrahedralMesh< 3, 3 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        TetrahedralMesh< 3, 3 >::Clear( );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 3, 3 > & rMeshReader ) {
        if( bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" ) )
            func_ConstructFromMeshReader( boost::ref(rMeshReader) );
        else{
            this->TetrahedralMesh< 3, 3 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
        }
    }
    
    void default_ConstructFromMeshReader( ::AbstractMeshReader< 3, 3 > & rMeshReader ) {
        TetrahedralMesh< 3, 3 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual void GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetJacobianForElement = this->get_override( "GetJacobianForElement" ) )
            func_GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        }
    }
    
    void default_GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForElement = this->get_override( "GetWeightedDirectionForElement" ) )
            func_GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->TetrahedralMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        TetrahedralMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshJacobianCachedData(  ) {
        if( bp::override func_RefreshJacobianCachedData = this->get_override( "RefreshJacobianCachedData" ) )
            func_RefreshJacobianCachedData(  );
        else{
            this->TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData(  );
        }
    }
    
    void default_RefreshJacobianCachedData(  ) {
        TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData( );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->TetrahedralMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        TetrahedralMesh< 3, 3 >::RefreshMesh( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        if( bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" ) )
            return func_SolveBoundaryElementMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveBoundaryElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveBoundaryElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        if( bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" ) )
            return func_SolveElementMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumNodes( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumVertices( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 3, 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 3, 3 >::GetWidth( rDimension );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships( );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct MutableMesh_less__3_comma__3__greater__wrapper : MutableMesh< 3, 3 >, bp::wrapper< MutableMesh< 3, 3 > > {

    MutableMesh_less__3_comma__3__greater__wrapper( )
    : MutableMesh<3, 3>( )
      , bp::wrapper< MutableMesh< 3, 3 > >(){
        // null constructor
    
    }

    MutableMesh_less__3_comma__3__greater__wrapper(::std::vector< Node<3> * > nodes )
    : MutableMesh<3, 3>( nodes )
      , bp::wrapper< MutableMesh< 3, 3 > >(){
        // constructor
    
    }

    virtual unsigned int AddNode( ::Node< 3 > * pNewNode ) {
        if( bp::override func_AddNode = this->get_override( "AddNode" ) )
            return func_AddNode( boost::python::ptr(pNewNode) );
        else{
            return this->MutableMesh< 3, 3 >::AddNode( boost::python::ptr(pNewNode) );
        }
    }
    
    unsigned int default_AddNode( ::Node< 3 > * pNewNode ) {
        return MutableMesh< 3, 3 >::AddNode( boost::python::ptr(pNewNode) );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->MutableMesh< 3, 3 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        MutableMesh< 3, 3 >::Clear( );
    }

    virtual void DeleteElement( unsigned int index ) {
        if( bp::override func_DeleteElement = this->get_override( "DeleteElement" ) )
            func_DeleteElement( index );
        else{
            this->MutableMesh< 3, 3 >::DeleteElement( index );
        }
    }
    
    void default_DeleteElement( unsigned int index ) {
        MutableMesh< 3, 3 >::DeleteElement( index );
    }

    virtual void DeleteNode( unsigned int index ) {
        if( bp::override func_DeleteNode = this->get_override( "DeleteNode" ) )
            func_DeleteNode( index );
        else{
            this->MutableMesh< 3, 3 >::DeleteNode( index );
        }
    }
    
    void default_DeleteNode( unsigned int index ) {
        MutableMesh< 3, 3 >::DeleteNode( index );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->MutableMesh< 3, 3 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return MutableMesh< 3, 3 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->MutableMesh< 3, 3 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return MutableMesh< 3, 3 >::GetNumElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->MutableMesh< 3, 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return MutableMesh< 3, 3 >::GetNumNodes( );
    }

    virtual void ReMesh( ::NodeMap & map ) {
        if( bp::override func_ReMesh = this->get_override( "ReMesh" ) )
            func_ReMesh( boost::ref(map) );
        else{
            this->MutableMesh< 3, 3 >::ReMesh( boost::ref(map) );
        }
    }
    
    void default_ReMesh( ::NodeMap & map ) {
        MutableMesh< 3, 3 >::ReMesh( boost::ref(map) );
    }

    virtual void SetNode( unsigned int index, ::ChastePoint< 3 > point, bool concreteMove=true ) {
        if( bp::override func_SetNode = this->get_override( "SetNode" ) )
            func_SetNode( index, point, concreteMove );
        else{
            this->MutableMesh< 3, 3 >::SetNode( index, point, concreteMove );
        }
    }
    
    void default_SetNode( unsigned int index, ::ChastePoint< 3 > point, bool concreteMove=true ) {
        MutableMesh< 3, 3 >::SetNode( index, point, concreteMove );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 3, 3 > & rMeshReader ) {
        if( bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" ) )
            func_ConstructFromMeshReader( boost::ref(rMeshReader) );
        else{
            this->TetrahedralMesh< 3, 3 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
        }
    }
    
    void default_ConstructFromMeshReader( ::AbstractMeshReader< 3, 3 > & rMeshReader ) {
        TetrahedralMesh< 3, 3 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual void GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetJacobianForElement = this->get_override( "GetJacobianForElement" ) )
            func_GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        }
    }
    
    void default_GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumVertices( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForElement = this->get_override( "GetWeightedDirectionForElement" ) )
            func_GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 3, 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 3, 3 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->TetrahedralMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        TetrahedralMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshJacobianCachedData(  ) {
        if( bp::override func_RefreshJacobianCachedData = this->get_override( "RefreshJacobianCachedData" ) )
            func_RefreshJacobianCachedData(  );
        else{
            this->TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData(  );
        }
    }
    
    void default_RefreshJacobianCachedData(  ) {
        TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData( );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->TetrahedralMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        TetrahedralMesh< 3, 3 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        if( bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" ) )
            return func_SolveBoundaryElementMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveBoundaryElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveBoundaryElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        if( bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" ) )
            return func_SolveElementMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct VertexMesh_less__2_comma__2__greater__wrapper : VertexMesh< 2, 2 >, bp::wrapper< VertexMesh< 2, 2 > > {

    VertexMesh_less__2_comma__2__greater__wrapper(::std::vector< Node<2> * > nodes, ::std::vector< VertexElement<2, 2> * > vertexElements )
    : VertexMesh<2, 2>( nodes, vertexElements )
      , bp::wrapper< VertexMesh< 2, 2 > >(){
        // constructor
    
    }

    VertexMesh_less__2_comma__2__greater__wrapper(::std::vector< Node<2> * > nodes, ::std::vector< VertexElement<1, 2> * > faces, ::std::vector< VertexElement<2, 2> * > vertexElements )
    : VertexMesh<2, 2>( nodes, faces, vertexElements )
      , bp::wrapper< VertexMesh< 2, 2 > >(){
        // constructor
    
    }

    VertexMesh_less__2_comma__2__greater__wrapper(::TetrahedralMesh< 2, 2 > & rMesh, bool isPeriodic=false )
    : VertexMesh<2, 2>( boost::ref(rMesh), isPeriodic )
      , bp::wrapper< VertexMesh< 2, 2 > >(){
        // constructor
    
    }

    VertexMesh_less__2_comma__2__greater__wrapper( )
    : VertexMesh<2, 2>( )
      , bp::wrapper< VertexMesh< 2, 2 > >(){
        // null constructor
    
    }

    virtual double CalculateAreaOfFace( ::VertexElement< 1, 2 > * pFace ) {
        if( bp::override func_CalculateAreaOfFace = this->get_override( "CalculateAreaOfFace" ) )
            return func_CalculateAreaOfFace( boost::python::ptr(pFace) );
        else{
            return this->VertexMesh< 2, 2 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
        }
    }
    
    double default_CalculateAreaOfFace( ::VertexElement< 1, 2 > * pFace ) {
        return VertexMesh< 2, 2 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > CalculateMomentsOfElement( unsigned int index ) {
        if( bp::override func_CalculateMomentsOfElement = this->get_override( "CalculateMomentsOfElement" ) )
            return func_CalculateMomentsOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::CalculateMomentsOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_CalculateMomentsOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::CalculateMomentsOfElement( index );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->VertexMesh< 2, 2 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        VertexMesh< 2, 2 >::Clear( );
    }

    bool ElementIncludesPoint( ::boost::numeric::ublas::c_vector< double, 2 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 2, 2 >::ElementIncludesPoint( boost::ref(rTestPoint), elementIndex );
    }

    void GenerateVerticesFromElementCircumcentres( ::TetrahedralMesh< 2, 2 > & rMesh ){
        VertexMesh< 2, 2 >::GenerateVerticesFromElementCircumcentres( boost::ref(rMesh) );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetCentroidOfElement( unsigned int index ) {
        if( bp::override func_GetCentroidOfElement = this->get_override( "GetCentroidOfElement" ) )
            return func_GetCentroidOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::GetCentroidOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetCentroidOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::GetCentroidOfElement( index );
    }

    unsigned int GetLocalIndexForElementEdgeClosestToPoint( ::boost::numeric::ublas::c_vector< double, 2 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 2, 2 >::GetLocalIndexForElementEdgeClosestToPoint( boost::ref(rTestPoint), elementIndex );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->VertexMesh< 2, 2 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return VertexMesh< 2, 2 >::GetNumElements( );
    }

    virtual unsigned int GetNumFaces(  ) const  {
        if( bp::override func_GetNumFaces = this->get_override( "GetNumFaces" ) )
            return func_GetNumFaces(  );
        else{
            return this->VertexMesh< 2, 2 >::GetNumFaces(  );
        }
    }
    
    unsigned int default_GetNumFaces(  ) const  {
        return VertexMesh< 2, 2 >::GetNumFaces( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->VertexMesh< 2, 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return VertexMesh< 2, 2 >::GetNumNodes( );
    }

    virtual double GetSurfaceAreaOfElement( unsigned int index ) {
        if( bp::override func_GetSurfaceAreaOfElement = this->get_override( "GetSurfaceAreaOfElement" ) )
            return func_GetSurfaceAreaOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::GetSurfaceAreaOfElement( index );
        }
    }
    
    double default_GetSurfaceAreaOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::GetSurfaceAreaOfElement( index );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->VertexMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return VertexMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetVolumeOfElement( unsigned int index ) {
        if( bp::override func_GetVolumeOfElement = this->get_override( "GetVolumeOfElement" ) )
            return func_GetVolumeOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::GetVolumeOfElement( index );
        }
    }
    
    double default_GetVolumeOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::GetVolumeOfElement( index );
    }

    unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        return VertexMesh< 2, 2 >::SolveBoundaryElementMapping( index );
    }

    unsigned int SolveElementMapping( unsigned int index ) const {
        return VertexMesh< 2, 2 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->VertexMesh< 2, 2 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return VertexMesh< 2, 2 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 2, 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 2, 2 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 2, 2 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 2, 2 >::SetElementOwnerships( );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct MutableVertexMesh_less__2_comma__2__greater__wrapper : MutableVertexMesh< 2, 2 >, bp::wrapper< MutableVertexMesh< 2, 2 > > {

    MutableVertexMesh_less__2_comma__2__greater__wrapper(::std::vector< Node<2> * > nodes, ::std::vector< VertexElement<2, 2> * > vertexElements, double cellRearrangementThreshold=0.01, double t2Threshold=0.001, double cellRearrangementRatio=1.5, double protorosetteFormationProbability=0., double protorosetteResolutionProbabilityPerTimestep=0., double rosetteResolutionProbabilityPerTimestep=0. )
    : MutableVertexMesh<2, 2>( nodes, vertexElements, cellRearrangementThreshold, t2Threshold, cellRearrangementRatio, protorosetteFormationProbability, protorosetteResolutionProbabilityPerTimestep, rosetteResolutionProbabilityPerTimestep )
      , bp::wrapper< MutableVertexMesh< 2, 2 > >(){
        // constructor
    
    }

    MutableVertexMesh_less__2_comma__2__greater__wrapper( )
    : MutableVertexMesh<2, 2>( )
      , bp::wrapper< MutableVertexMesh< 2, 2 > >(){
        // null constructor
    
    }

    bool CheckForIntersections(  ){
        return MutableVertexMesh< 2, 2 >::CheckForIntersections(  );
    }

    void CheckForRosettes(  ){
        MutableVertexMesh< 2, 2 >::CheckForRosettes(  );
    }

    bool CheckForSwapsFromShortEdges(  ){
        return MutableVertexMesh< 2, 2 >::CheckForSwapsFromShortEdges(  );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->MutableVertexMesh< 2, 2 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        MutableVertexMesh< 2, 2 >::Clear( );
    }

    unsigned int DivideElement( ::VertexElement< 2, 2 > * pElement, unsigned int nodeAIndex, unsigned int nodeBIndex, bool placeOriginalElementBelow=false ){
        return MutableVertexMesh< 2, 2 >::DivideElement( boost::python::ptr(pElement), nodeAIndex, nodeBIndex, placeOriginalElementBelow );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->MutableVertexMesh< 2, 2 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return MutableVertexMesh< 2, 2 >::GetNumElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->MutableVertexMesh< 2, 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return MutableVertexMesh< 2, 2 >::GetNumNodes( );
    }

    virtual void HandleHighOrderJunctions( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB ){
        if( bp::override func_HandleHighOrderJunctions = this->get_override( "HandleHighOrderJunctions" ) )
            func_HandleHighOrderJunctions( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        else{
            this->MutableVertexMesh< 2, 2 >::HandleHighOrderJunctions( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        }
    }
    
    virtual void default_HandleHighOrderJunctions( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB ){
        MutableVertexMesh< 2, 2 >::HandleHighOrderJunctions( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    virtual void IdentifySwapType( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB ){
        if( bp::override func_IdentifySwapType = this->get_override( "IdentifySwapType" ) )
            func_IdentifySwapType( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        else{
            this->MutableVertexMesh< 2, 2 >::IdentifySwapType( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        }
    }
    
    virtual void default_IdentifySwapType( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB ){
        MutableVertexMesh< 2, 2 >::IdentifySwapType( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    void PerformIntersectionSwap( ::Node< 2 > * pNode, unsigned int elementIndex ){
        MutableVertexMesh< 2, 2 >::PerformIntersectionSwap( boost::python::ptr(pNode), elementIndex );
    }

    void PerformNodeMerge( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB ){
        MutableVertexMesh< 2, 2 >::PerformNodeMerge( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    void PerformProtorosetteResolution( ::Node< 2 > * pProtorosetteNode ){
        MutableVertexMesh< 2, 2 >::PerformProtorosetteResolution( boost::python::ptr(pProtorosetteNode) );
    }

    void PerformRosetteRankDecrease( ::Node< 2 > * pRosetteNode ){
        MutableVertexMesh< 2, 2 >::PerformRosetteRankDecrease( boost::python::ptr(pRosetteNode) );
    }

    void PerformRosetteRankIncrease( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB ){
        MutableVertexMesh< 2, 2 >::PerformRosetteRankIncrease( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    void PerformT1Swap( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB, ::std::set< unsigned int > & rElementsContainingNodes ){
        MutableVertexMesh< 2, 2 >::PerformT1Swap( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB), boost::ref(rElementsContainingNodes) );
    }

    void PerformT2Swap( ::VertexElement< 2, 2 > & rElement ){
        MutableVertexMesh< 2, 2 >::PerformT2Swap( boost::ref(rElement) );
    }

    void PerformT3Swap( ::Node< 2 > * pNode, unsigned int elementIndex ){
        MutableVertexMesh< 2, 2 >::PerformT3Swap( boost::python::ptr(pNode), elementIndex );
    }

    void PerformVoidRemoval( ::Node< 2 > * pNodeA, ::Node< 2 > * pNodeB, ::Node< 2 > * pNodeC ){
        MutableVertexMesh< 2, 2 >::PerformVoidRemoval( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB), boost::python::ptr(pNodeC) );
    }

    virtual void ReMesh( ::VertexElementMap & rElementMap ) {
        if( bp::override func_ReMesh = this->get_override( "ReMesh" ) )
            func_ReMesh( boost::ref(rElementMap) );
        else{
            this->MutableVertexMesh< 2, 2 >::ReMesh( boost::ref(rElementMap) );
        }
    }
    
    void default_ReMesh( ::VertexElementMap & rElementMap ) {
        MutableVertexMesh< 2, 2 >::ReMesh( boost::ref(rElementMap) );
    }

    virtual void SetNode( unsigned int nodeIndex, ::ChastePoint< 2 > point ) {
        if( bp::override func_SetNode = this->get_override( "SetNode" ) )
            func_SetNode( nodeIndex, point );
        else{
            this->MutableVertexMesh< 2, 2 >::SetNode( nodeIndex, point );
        }
    }
    
    void default_SetNode( unsigned int nodeIndex, ::ChastePoint< 2 > point ) {
        MutableVertexMesh< 2, 2 >::SetNode( nodeIndex, point );
    }

    ::boost::numeric::ublas::c_vector< double, 2 > WidenEdgeOrCorrectIntersectionLocationIfNecessary( unsigned int indexA, unsigned int indexB, ::boost::numeric::ublas::c_vector< double, 2 > intersection ){
        return MutableVertexMesh< 2, 2 >::WidenEdgeOrCorrectIntersectionLocationIfNecessary( indexA, indexB, intersection );
    }

    virtual double CalculateAreaOfFace( ::VertexElement< 1, 2 > * pFace ) {
        if( bp::override func_CalculateAreaOfFace = this->get_override( "CalculateAreaOfFace" ) )
            return func_CalculateAreaOfFace( boost::python::ptr(pFace) );
        else{
            return this->VertexMesh< 2, 2 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
        }
    }
    
    double default_CalculateAreaOfFace( ::VertexElement< 1, 2 > * pFace ) {
        return VertexMesh< 2, 2 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > CalculateMomentsOfElement( unsigned int index ) {
        if( bp::override func_CalculateMomentsOfElement = this->get_override( "CalculateMomentsOfElement" ) )
            return func_CalculateMomentsOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::CalculateMomentsOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_CalculateMomentsOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::CalculateMomentsOfElement( index );
    }

    bool ElementIncludesPoint( ::boost::numeric::ublas::c_vector< double, 2 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 2, 2 >::ElementIncludesPoint( boost::ref(rTestPoint), elementIndex );
    }

    void GenerateVerticesFromElementCircumcentres( ::TetrahedralMesh< 2, 2 > & rMesh ){
        VertexMesh< 2, 2 >::GenerateVerticesFromElementCircumcentres( boost::ref(rMesh) );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetCentroidOfElement( unsigned int index ) {
        if( bp::override func_GetCentroidOfElement = this->get_override( "GetCentroidOfElement" ) )
            return func_GetCentroidOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::GetCentroidOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetCentroidOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::GetCentroidOfElement( index );
    }

    unsigned int GetLocalIndexForElementEdgeClosestToPoint( ::boost::numeric::ublas::c_vector< double, 2 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 2, 2 >::GetLocalIndexForElementEdgeClosestToPoint( boost::ref(rTestPoint), elementIndex );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumFaces(  ) const  {
        if( bp::override func_GetNumFaces = this->get_override( "GetNumFaces" ) )
            return func_GetNumFaces(  );
        else{
            return this->VertexMesh< 2, 2 >::GetNumFaces(  );
        }
    }
    
    unsigned int default_GetNumFaces(  ) const  {
        return VertexMesh< 2, 2 >::GetNumFaces( );
    }

    virtual double GetSurfaceAreaOfElement( unsigned int index ) {
        if( bp::override func_GetSurfaceAreaOfElement = this->get_override( "GetSurfaceAreaOfElement" ) )
            return func_GetSurfaceAreaOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::GetSurfaceAreaOfElement( index );
        }
    }
    
    double default_GetSurfaceAreaOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::GetSurfaceAreaOfElement( index );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->VertexMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return VertexMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetVolumeOfElement( unsigned int index ) {
        if( bp::override func_GetVolumeOfElement = this->get_override( "GetVolumeOfElement" ) )
            return func_GetVolumeOfElement( index );
        else{
            return this->VertexMesh< 2, 2 >::GetVolumeOfElement( index );
        }
    }
    
    double default_GetVolumeOfElement( unsigned int index ) {
        return VertexMesh< 2, 2 >::GetVolumeOfElement( index );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 2, 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 2, 2 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 2, 2 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 2, 2 >::SetElementOwnerships( );
    }

    unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        return VertexMesh< 2, 2 >::SolveBoundaryElementMapping( index );
    }

    unsigned int SolveElementMapping( unsigned int index ) const {
        return VertexMesh< 2, 2 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->VertexMesh< 2, 2 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return VertexMesh< 2, 2 >::SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct VertexMesh_less__3_comma__3__greater__wrapper : VertexMesh< 3, 3 >, bp::wrapper< VertexMesh< 3, 3 > > {

    VertexMesh_less__3_comma__3__greater__wrapper(::std::vector< Node<3> * > nodes, ::std::vector< VertexElement<3, 3> * > vertexElements )
    : VertexMesh<3, 3>( nodes, vertexElements )
      , bp::wrapper< VertexMesh< 3, 3 > >(){
        // constructor
    
    }

    VertexMesh_less__3_comma__3__greater__wrapper(::TetrahedralMesh< 3, 3 > & rMesh )
    : VertexMesh<3, 3>( boost::ref(rMesh) )
      , bp::wrapper< VertexMesh< 3, 3 > >(){
        // constructor
    
    }

    VertexMesh_less__3_comma__3__greater__wrapper( )
    : VertexMesh<3, 3>( )
      , bp::wrapper< VertexMesh< 3, 3 > >(){
        // null constructor
    
    }

    virtual double CalculateAreaOfFace( ::VertexElement< 2, 3 > * pFace ) {
        if( bp::override func_CalculateAreaOfFace = this->get_override( "CalculateAreaOfFace" ) )
            return func_CalculateAreaOfFace( boost::python::ptr(pFace) );
        else{
            return this->VertexMesh< 3, 3 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
        }
    }
    
    double default_CalculateAreaOfFace( ::VertexElement< 2, 3 > * pFace ) {
        return VertexMesh< 3, 3 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > CalculateMomentsOfElement( unsigned int index ) {
        if( bp::override func_CalculateMomentsOfElement = this->get_override( "CalculateMomentsOfElement" ) )
            return func_CalculateMomentsOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::CalculateMomentsOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_CalculateMomentsOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::CalculateMomentsOfElement( index );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->VertexMesh< 3, 3 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        VertexMesh< 3, 3 >::Clear( );
    }

    bool ElementIncludesPoint( ::boost::numeric::ublas::c_vector< double, 3 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 3, 3 >::ElementIncludesPoint( boost::ref(rTestPoint), elementIndex );
    }

    void GenerateVerticesFromElementCircumcentres( ::TetrahedralMesh< 3, 3 > & rMesh ){
        VertexMesh< 3, 3 >::GenerateVerticesFromElementCircumcentres( boost::ref(rMesh) );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetCentroidOfElement( unsigned int index ) {
        if( bp::override func_GetCentroidOfElement = this->get_override( "GetCentroidOfElement" ) )
            return func_GetCentroidOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::GetCentroidOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetCentroidOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::GetCentroidOfElement( index );
    }

    unsigned int GetLocalIndexForElementEdgeClosestToPoint( ::boost::numeric::ublas::c_vector< double, 3 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 3, 3 >::GetLocalIndexForElementEdgeClosestToPoint( boost::ref(rTestPoint), elementIndex );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->VertexMesh< 3, 3 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return VertexMesh< 3, 3 >::GetNumElements( );
    }

    virtual unsigned int GetNumFaces(  ) const  {
        if( bp::override func_GetNumFaces = this->get_override( "GetNumFaces" ) )
            return func_GetNumFaces(  );
        else{
            return this->VertexMesh< 3, 3 >::GetNumFaces(  );
        }
    }
    
    unsigned int default_GetNumFaces(  ) const  {
        return VertexMesh< 3, 3 >::GetNumFaces( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->VertexMesh< 3, 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return VertexMesh< 3, 3 >::GetNumNodes( );
    }

    virtual double GetSurfaceAreaOfElement( unsigned int index ) {
        if( bp::override func_GetSurfaceAreaOfElement = this->get_override( "GetSurfaceAreaOfElement" ) )
            return func_GetSurfaceAreaOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::GetSurfaceAreaOfElement( index );
        }
    }
    
    double default_GetSurfaceAreaOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::GetSurfaceAreaOfElement( index );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->VertexMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return VertexMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetVolumeOfElement( unsigned int index ) {
        if( bp::override func_GetVolumeOfElement = this->get_override( "GetVolumeOfElement" ) )
            return func_GetVolumeOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::GetVolumeOfElement( index );
        }
    }
    
    double default_GetVolumeOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::GetVolumeOfElement( index );
    }

    unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        return VertexMesh< 3, 3 >::SolveBoundaryElementMapping( index );
    }

    unsigned int SolveElementMapping( unsigned int index ) const {
        return VertexMesh< 3, 3 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->VertexMesh< 3, 3 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return VertexMesh< 3, 3 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 3, 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 3, 3 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 3, 3 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 3, 3 >::SetElementOwnerships( );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct MutableVertexMesh_less__3_comma__3__greater__wrapper : MutableVertexMesh< 3, 3 >, bp::wrapper< MutableVertexMesh< 3, 3 > > {

    MutableVertexMesh_less__3_comma__3__greater__wrapper(::std::vector< Node<3> * > nodes, ::std::vector< VertexElement<3, 3> * > vertexElements, double cellRearrangementThreshold=0.01, double t2Threshold=0.001, double cellRearrangementRatio=1.5, double protorosetteFormationProbability=0., double protorosetteResolutionProbabilityPerTimestep=0., double rosetteResolutionProbabilityPerTimestep=0. )
    : MutableVertexMesh<3, 3>( nodes, vertexElements, cellRearrangementThreshold, t2Threshold, cellRearrangementRatio, protorosetteFormationProbability, protorosetteResolutionProbabilityPerTimestep, rosetteResolutionProbabilityPerTimestep )
      , bp::wrapper< MutableVertexMesh< 3, 3 > >(){
        // constructor
    
    }

    MutableVertexMesh_less__3_comma__3__greater__wrapper( )
    : MutableVertexMesh<3, 3>( )
      , bp::wrapper< MutableVertexMesh< 3, 3 > >(){
        // null constructor
    
    }

    bool CheckForIntersections(  ){
        return MutableVertexMesh< 3, 3 >::CheckForIntersections(  );
    }

    void CheckForRosettes(  ){
        MutableVertexMesh< 3, 3 >::CheckForRosettes(  );
    }

    bool CheckForSwapsFromShortEdges(  ){
        return MutableVertexMesh< 3, 3 >::CheckForSwapsFromShortEdges(  );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->MutableVertexMesh< 3, 3 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        MutableVertexMesh< 3, 3 >::Clear( );
    }

    unsigned int DivideElement( ::VertexElement< 3, 3 > * pElement, unsigned int nodeAIndex, unsigned int nodeBIndex, bool placeOriginalElementBelow=false ){
        return MutableVertexMesh< 3, 3 >::DivideElement( boost::python::ptr(pElement), nodeAIndex, nodeBIndex, placeOriginalElementBelow );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->MutableVertexMesh< 3, 3 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return MutableVertexMesh< 3, 3 >::GetNumElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->MutableVertexMesh< 3, 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return MutableVertexMesh< 3, 3 >::GetNumNodes( );
    }

    virtual void HandleHighOrderJunctions( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB ){
        if( bp::override func_HandleHighOrderJunctions = this->get_override( "HandleHighOrderJunctions" ) )
            func_HandleHighOrderJunctions( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        else{
            this->MutableVertexMesh< 3, 3 >::HandleHighOrderJunctions( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        }
    }
    
    virtual void default_HandleHighOrderJunctions( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB ){
        MutableVertexMesh< 3, 3 >::HandleHighOrderJunctions( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    virtual void IdentifySwapType( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB ){
        if( bp::override func_IdentifySwapType = this->get_override( "IdentifySwapType" ) )
            func_IdentifySwapType( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        else{
            this->MutableVertexMesh< 3, 3 >::IdentifySwapType( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
        }
    }
    
    virtual void default_IdentifySwapType( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB ){
        MutableVertexMesh< 3, 3 >::IdentifySwapType( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    void PerformIntersectionSwap( ::Node< 3 > * pNode, unsigned int elementIndex ){
        MutableVertexMesh< 3, 3 >::PerformIntersectionSwap( boost::python::ptr(pNode), elementIndex );
    }

    void PerformNodeMerge( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB ){
        MutableVertexMesh< 3, 3 >::PerformNodeMerge( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    void PerformProtorosetteResolution( ::Node< 3 > * pProtorosetteNode ){
        MutableVertexMesh< 3, 3 >::PerformProtorosetteResolution( boost::python::ptr(pProtorosetteNode) );
    }

    void PerformRosetteRankDecrease( ::Node< 3 > * pRosetteNode ){
        MutableVertexMesh< 3, 3 >::PerformRosetteRankDecrease( boost::python::ptr(pRosetteNode) );
    }

    void PerformRosetteRankIncrease( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB ){
        MutableVertexMesh< 3, 3 >::PerformRosetteRankIncrease( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB) );
    }

    void PerformT1Swap( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB, ::std::set< unsigned int > & rElementsContainingNodes ){
        MutableVertexMesh< 3, 3 >::PerformT1Swap( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB), boost::ref(rElementsContainingNodes) );
    }

    void PerformT2Swap( ::VertexElement< 3, 3 > & rElement ){
        MutableVertexMesh< 3, 3 >::PerformT2Swap( boost::ref(rElement) );
    }

    void PerformT3Swap( ::Node< 3 > * pNode, unsigned int elementIndex ){
        MutableVertexMesh< 3, 3 >::PerformT3Swap( boost::python::ptr(pNode), elementIndex );
    }

    void PerformVoidRemoval( ::Node< 3 > * pNodeA, ::Node< 3 > * pNodeB, ::Node< 3 > * pNodeC ){
        MutableVertexMesh< 3, 3 >::PerformVoidRemoval( boost::python::ptr(pNodeA), boost::python::ptr(pNodeB), boost::python::ptr(pNodeC) );
    }

    virtual void ReMesh( ::VertexElementMap & rElementMap ) {
        if( bp::override func_ReMesh = this->get_override( "ReMesh" ) )
            func_ReMesh( boost::ref(rElementMap) );
        else{
            this->MutableVertexMesh< 3, 3 >::ReMesh( boost::ref(rElementMap) );
        }
    }
    
    void default_ReMesh( ::VertexElementMap & rElementMap ) {
        MutableVertexMesh< 3, 3 >::ReMesh( boost::ref(rElementMap) );
    }

    virtual void SetNode( unsigned int nodeIndex, ::ChastePoint< 3 > point ) {
        if( bp::override func_SetNode = this->get_override( "SetNode" ) )
            func_SetNode( nodeIndex, point );
        else{
            this->MutableVertexMesh< 3, 3 >::SetNode( nodeIndex, point );
        }
    }
    
    void default_SetNode( unsigned int nodeIndex, ::ChastePoint< 3 > point ) {
        MutableVertexMesh< 3, 3 >::SetNode( nodeIndex, point );
    }

    ::boost::numeric::ublas::c_vector< double, 2 > WidenEdgeOrCorrectIntersectionLocationIfNecessary( unsigned int indexA, unsigned int indexB, ::boost::numeric::ublas::c_vector< double, 2 > intersection ){
        return MutableVertexMesh< 3, 3 >::WidenEdgeOrCorrectIntersectionLocationIfNecessary( indexA, indexB, intersection );
    }

    virtual double CalculateAreaOfFace( ::VertexElement< 2, 3 > * pFace ) {
        if( bp::override func_CalculateAreaOfFace = this->get_override( "CalculateAreaOfFace" ) )
            return func_CalculateAreaOfFace( boost::python::ptr(pFace) );
        else{
            return this->VertexMesh< 3, 3 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
        }
    }
    
    double default_CalculateAreaOfFace( ::VertexElement< 2, 3 > * pFace ) {
        return VertexMesh< 3, 3 >::CalculateAreaOfFace( boost::python::ptr(pFace) );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > CalculateMomentsOfElement( unsigned int index ) {
        if( bp::override func_CalculateMomentsOfElement = this->get_override( "CalculateMomentsOfElement" ) )
            return func_CalculateMomentsOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::CalculateMomentsOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_CalculateMomentsOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::CalculateMomentsOfElement( index );
    }

    bool ElementIncludesPoint( ::boost::numeric::ublas::c_vector< double, 3 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 3, 3 >::ElementIncludesPoint( boost::ref(rTestPoint), elementIndex );
    }

    void GenerateVerticesFromElementCircumcentres( ::TetrahedralMesh< 3, 3 > & rMesh ){
        VertexMesh< 3, 3 >::GenerateVerticesFromElementCircumcentres( boost::ref(rMesh) );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetCentroidOfElement( unsigned int index ) {
        if( bp::override func_GetCentroidOfElement = this->get_override( "GetCentroidOfElement" ) )
            return func_GetCentroidOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::GetCentroidOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetCentroidOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::GetCentroidOfElement( index );
    }

    unsigned int GetLocalIndexForElementEdgeClosestToPoint( ::boost::numeric::ublas::c_vector< double, 3 > const & rTestPoint, unsigned int elementIndex ){
        return VertexMesh< 3, 3 >::GetLocalIndexForElementEdgeClosestToPoint( boost::ref(rTestPoint), elementIndex );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumFaces(  ) const  {
        if( bp::override func_GetNumFaces = this->get_override( "GetNumFaces" ) )
            return func_GetNumFaces(  );
        else{
            return this->VertexMesh< 3, 3 >::GetNumFaces(  );
        }
    }
    
    unsigned int default_GetNumFaces(  ) const  {
        return VertexMesh< 3, 3 >::GetNumFaces( );
    }

    virtual double GetSurfaceAreaOfElement( unsigned int index ) {
        if( bp::override func_GetSurfaceAreaOfElement = this->get_override( "GetSurfaceAreaOfElement" ) )
            return func_GetSurfaceAreaOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::GetSurfaceAreaOfElement( index );
        }
    }
    
    double default_GetSurfaceAreaOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::GetSurfaceAreaOfElement( index );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->VertexMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return VertexMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetVolumeOfElement( unsigned int index ) {
        if( bp::override func_GetVolumeOfElement = this->get_override( "GetVolumeOfElement" ) )
            return func_GetVolumeOfElement( index );
        else{
            return this->VertexMesh< 3, 3 >::GetVolumeOfElement( index );
        }
    }
    
    double default_GetVolumeOfElement( unsigned int index ) {
        return VertexMesh< 3, 3 >::GetVolumeOfElement( index );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 3, 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 3, 3 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 3, 3 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 3, 3 >::SetElementOwnerships( );
    }

    unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        return VertexMesh< 3, 3 >::SolveBoundaryElementMapping( index );
    }

    unsigned int SolveElementMapping( unsigned int index ) const {
        return VertexMesh< 3, 3 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->VertexMesh< 3, 3 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return VertexMesh< 3, 3 >::SolveNodeMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct NodesOnlyMesh_less__2__greater__wrapper : NodesOnlyMesh< 2 >, bp::wrapper< NodesOnlyMesh< 2 > > {

    NodesOnlyMesh_less__2__greater__wrapper( )
    : NodesOnlyMesh<2>( )
      , bp::wrapper< NodesOnlyMesh< 2 > >(){
        // null constructor
    
    }

    virtual unsigned int AddNode( ::Node< 2 > * pNewNode ) {
        if( bp::override func_AddNode = this->get_override( "AddNode" ) )
            return func_AddNode( boost::python::ptr(pNewNode) );
        else{
            return this->NodesOnlyMesh< 2 >::AddNode( boost::python::ptr(pNewNode) );
        }
    }
    
    unsigned int default_AddNode( ::Node< 2 > * pNewNode ) {
        return NodesOnlyMesh< 2 >::AddNode( boost::python::ptr(pNewNode) );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->NodesOnlyMesh< 2 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        NodesOnlyMesh< 2 >::Clear( );
    }

    void ClearBoxCollection(  ){
        NodesOnlyMesh< 2 >::ClearBoxCollection(  );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 2, 2 > & rMeshReader ) {
        if( bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" ) )
            func_ConstructFromMeshReader( boost::ref(rMeshReader) );
        else{
            this->NodesOnlyMesh< 2 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
        }
    }
    
    void default_ConstructFromMeshReader( ::AbstractMeshReader< 2, 2 > & rMeshReader ) {
        NodesOnlyMesh< 2 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void DeleteNode( unsigned int index ) {
        if( bp::override func_DeleteNode = this->get_override( "DeleteNode" ) )
            func_DeleteNode( index );
        else{
            this->NodesOnlyMesh< 2 >::DeleteNode( index );
        }
    }
    
    void default_DeleteNode( unsigned int index ) {
        NodesOnlyMesh< 2 >::DeleteNode( index );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->NodesOnlyMesh< 2 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return NodesOnlyMesh< 2 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->NodesOnlyMesh< 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return NodesOnlyMesh< 2 >::GetNumNodes( );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->NodesOnlyMesh< 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return NodesOnlyMesh< 2 >::GetWidth( rDimension );
    }

    virtual void ReMesh( ::NodeMap & rMap ) {
        if( bp::override func_ReMesh = this->get_override( "ReMesh" ) )
            func_ReMesh( boost::ref(rMap) );
        else{
            this->NodesOnlyMesh< 2 >::ReMesh( boost::ref(rMap) );
        }
    }
    
    void default_ReMesh( ::NodeMap & rMap ) {
        NodesOnlyMesh< 2 >::ReMesh( boost::ref(rMap) );
    }

    virtual void SetNode( unsigned int nodeIndex, ::ChastePoint< 2 > point, bool concreteMove=false ) {
        if( bp::override func_SetNode = this->get_override( "SetNode" ) )
            func_SetNode( nodeIndex, point, concreteMove );
        else{
            this->NodesOnlyMesh< 2 >::SetNode( nodeIndex, point, concreteMove );
        }
    }
    
    void default_SetNode( unsigned int nodeIndex, ::ChastePoint< 2 > point, bool concreteMove=false ) {
        NodesOnlyMesh< 2 >::SetNode( nodeIndex, point, concreteMove );
    }

    virtual void SetUpBoxCollection( double cutOffLength, ::boost::numeric::ublas::c_vector< double, 4 > domainSize, int numLocalRows=-1, bool isPeriodic=false ){
        if( bp::override func_SetUpBoxCollection = this->get_override( "SetUpBoxCollection" ) )
            func_SetUpBoxCollection( cutOffLength, domainSize, numLocalRows, isPeriodic );
        else{
            this->NodesOnlyMesh< 2 >::SetUpBoxCollection( cutOffLength, domainSize, numLocalRows, isPeriodic );
        }
    }
    
    virtual void default_SetUpBoxCollection( double cutOffLength, ::boost::numeric::ublas::c_vector< double, 4 > domainSize, int numLocalRows=-1, bool isPeriodic=false ){
        NodesOnlyMesh< 2 >::SetUpBoxCollection( cutOffLength, domainSize, numLocalRows, isPeriodic );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const  {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->NodesOnlyMesh< 2 >::SolveNodeMapping( index );
        }
    }
    
    unsigned int default_SolveNodeMapping( unsigned int index ) const  {
        return NodesOnlyMesh< 2 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void DeleteElement( unsigned int index ) {
        if( bp::override func_DeleteElement = this->get_override( "DeleteElement" ) )
            func_DeleteElement( index );
        else{
            this->MutableMesh< 2, 2 >::DeleteElement( index );
        }
    }
    
    void default_DeleteElement( unsigned int index ) {
        MutableMesh< 2, 2 >::DeleteElement( index );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rInverseJacobian ) const  {
        TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual void GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetJacobianForElement = this->get_override( "GetJacobianForElement" ) )
            func_GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        }
    }
    
    void default_GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 2, 2 > & rJacobian, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->MutableMesh< 2, 2 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return MutableMesh< 2, 2 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->MutableMesh< 2, 2 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return MutableMesh< 2, 2 >::GetNumElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 2, 2 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 2, 2 >::GetNumVertices( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForElement = this->get_override( "GetWeightedDirectionForElement" ) )
            func_GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 2 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->TetrahedralMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        TetrahedralMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshJacobianCachedData(  ) {
        if( bp::override func_RefreshJacobianCachedData = this->get_override( "RefreshJacobianCachedData" ) )
            func_RefreshJacobianCachedData(  );
        else{
            this->TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData(  );
        }
    }
    
    void default_RefreshJacobianCachedData(  ) {
        TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData( );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->TetrahedralMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        TetrahedralMesh< 2, 2 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        if( bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" ) )
            return func_SolveBoundaryElementMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveBoundaryElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveBoundaryElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        if( bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" ) )
            return func_SolveElementMapping( index );
        else{
            return this->TetrahedralMesh< 2, 2 >::SolveElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 2, 2 >::SolveElementMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct NodesOnlyMesh_less__3__greater__wrapper : NodesOnlyMesh< 3 >, bp::wrapper< NodesOnlyMesh< 3 > > {

    NodesOnlyMesh_less__3__greater__wrapper( )
    : NodesOnlyMesh<3>( )
      , bp::wrapper< NodesOnlyMesh< 3 > >(){
        // null constructor
    
    }

    virtual unsigned int AddNode( ::Node< 3 > * pNewNode ) {
        if( bp::override func_AddNode = this->get_override( "AddNode" ) )
            return func_AddNode( boost::python::ptr(pNewNode) );
        else{
            return this->NodesOnlyMesh< 3 >::AddNode( boost::python::ptr(pNewNode) );
        }
    }
    
    unsigned int default_AddNode( ::Node< 3 > * pNewNode ) {
        return NodesOnlyMesh< 3 >::AddNode( boost::python::ptr(pNewNode) );
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->NodesOnlyMesh< 3 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        NodesOnlyMesh< 3 >::Clear( );
    }

    void ClearBoxCollection(  ){
        NodesOnlyMesh< 3 >::ClearBoxCollection(  );
    }

    virtual void ConstructFromMeshReader( ::AbstractMeshReader< 3, 3 > & rMeshReader ) {
        if( bp::override func_ConstructFromMeshReader = this->get_override( "ConstructFromMeshReader" ) )
            func_ConstructFromMeshReader( boost::ref(rMeshReader) );
        else{
            this->NodesOnlyMesh< 3 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
        }
    }
    
    void default_ConstructFromMeshReader( ::AbstractMeshReader< 3, 3 > & rMeshReader ) {
        NodesOnlyMesh< 3 >::ConstructFromMeshReader( boost::ref(rMeshReader) );
    }

    virtual void DeleteNode( unsigned int index ) {
        if( bp::override func_DeleteNode = this->get_override( "DeleteNode" ) )
            func_DeleteNode( index );
        else{
            this->NodesOnlyMesh< 3 >::DeleteNode( index );
        }
    }
    
    void default_DeleteNode( unsigned int index ) {
        NodesOnlyMesh< 3 >::DeleteNode( index );
    }

    virtual unsigned int GetMaximumNodeIndex(  ) {
        if( bp::override func_GetMaximumNodeIndex = this->get_override( "GetMaximumNodeIndex" ) )
            return func_GetMaximumNodeIndex(  );
        else{
            return this->NodesOnlyMesh< 3 >::GetMaximumNodeIndex(  );
        }
    }
    
    unsigned int default_GetMaximumNodeIndex(  ) {
        return NodesOnlyMesh< 3 >::GetMaximumNodeIndex( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->NodesOnlyMesh< 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return NodesOnlyMesh< 3 >::GetNumNodes( );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->NodesOnlyMesh< 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return NodesOnlyMesh< 3 >::GetWidth( rDimension );
    }

    virtual void ReMesh( ::NodeMap & rMap ) {
        if( bp::override func_ReMesh = this->get_override( "ReMesh" ) )
            func_ReMesh( boost::ref(rMap) );
        else{
            this->NodesOnlyMesh< 3 >::ReMesh( boost::ref(rMap) );
        }
    }
    
    void default_ReMesh( ::NodeMap & rMap ) {
        NodesOnlyMesh< 3 >::ReMesh( boost::ref(rMap) );
    }

    virtual void SetNode( unsigned int nodeIndex, ::ChastePoint< 3 > point, bool concreteMove=false ) {
        if( bp::override func_SetNode = this->get_override( "SetNode" ) )
            func_SetNode( nodeIndex, point, concreteMove );
        else{
            this->NodesOnlyMesh< 3 >::SetNode( nodeIndex, point, concreteMove );
        }
    }
    
    void default_SetNode( unsigned int nodeIndex, ::ChastePoint< 3 > point, bool concreteMove=false ) {
        NodesOnlyMesh< 3 >::SetNode( nodeIndex, point, concreteMove );
    }

    virtual void SetUpBoxCollection( double cutOffLength, ::boost::numeric::ublas::c_vector< double, 6 > domainSize, int numLocalRows=-1, bool isPeriodic=false ){
        if( bp::override func_SetUpBoxCollection = this->get_override( "SetUpBoxCollection" ) )
            func_SetUpBoxCollection( cutOffLength, domainSize, numLocalRows, isPeriodic );
        else{
            this->NodesOnlyMesh< 3 >::SetUpBoxCollection( cutOffLength, domainSize, numLocalRows, isPeriodic );
        }
    }
    
    virtual void default_SetUpBoxCollection( double cutOffLength, ::boost::numeric::ublas::c_vector< double, 6 > domainSize, int numLocalRows=-1, bool isPeriodic=false ){
        NodesOnlyMesh< 3 >::SetUpBoxCollection( cutOffLength, domainSize, numLocalRows, isPeriodic );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const  {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->NodesOnlyMesh< 3 >::SolveNodeMapping( index );
        }
    }
    
    unsigned int default_SolveNodeMapping( unsigned int index ) const  {
        return NodesOnlyMesh< 3 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    virtual bool CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfBoundaryElement = this->get_override( "CalculateDesignatedOwnershipOfBoundaryElement" ) )
            return func_CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfBoundaryElement( unsigned int faceIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement( faceIndex );
    }

    virtual bool CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        if( bp::override func_CalculateDesignatedOwnershipOfElement = this->get_override( "CalculateDesignatedOwnershipOfElement" ) )
            return func_CalculateDesignatedOwnershipOfElement( elementIndex );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
        }
    }
    
    bool default_CalculateDesignatedOwnershipOfElement( unsigned int elementIndex ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement( elementIndex );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > CalculateMinMaxEdgeLengths(  ) {
        if( bp::override func_CalculateMinMaxEdgeLengths = this->get_override( "CalculateMinMaxEdgeLengths" ) )
            return func_CalculateMinMaxEdgeLengths(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths(  );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_CalculateMinMaxEdgeLengths(  ) {
        return AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths( );
    }

    virtual void ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        if( bp::override func_ConstructCuboid = this->get_override( "ConstructCuboid" ) )
            func_ConstructCuboid( width, height, depth );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
        }
    }
    
    void default_ConstructCuboid( unsigned int width, unsigned int height, unsigned int depth ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid( width, height, depth );
    }

    virtual void ConstructLinearMesh( unsigned int width ) {
        if( bp::override func_ConstructLinearMesh = this->get_override( "ConstructLinearMesh" ) )
            func_ConstructLinearMesh( width );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
        }
    }
    
    void default_ConstructLinearMesh( unsigned int width ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh( width );
    }

    virtual void ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        if( bp::override func_ConstructRectangularMesh = this->get_override( "ConstructRectangularMesh" ) )
            func_ConstructRectangularMesh( width, height, stagger );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
        }
    }
    
    void default_ConstructRectangularMesh( unsigned int width, unsigned int height, bool stagger=true ) {
        AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh( width, height, stagger );
    }

    virtual void DeleteElement( unsigned int index ) {
        if( bp::override func_DeleteElement = this->get_override( "DeleteElement" ) )
            func_DeleteElement( index );
        else{
            this->MutableMesh< 3, 3 >::DeleteElement( index );
        }
    }
    
    void default_DeleteElement( unsigned int index ) {
        MutableMesh< 3, 3 >::DeleteElement( index );
    }

    virtual void GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        if( bp::override func_GetHaloNodeIndices = this->get_override( "GetHaloNodeIndices" ) )
            func_GetHaloNodeIndices( boost::ref(rHaloIndices) );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
        }
    }
    
    void default_GetHaloNodeIndices( ::std::vector< unsigned int > & rHaloIndices ) const  {
        AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices( boost::ref(rHaloIndices) );
    }

    virtual void GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        if( bp::override func_GetInverseJacobianForElement = this->get_override( "GetInverseJacobianForElement" ) )
            func_GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        else{
            this->TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
        }
    }
    
    void default_GetInverseJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rInverseJacobian ) const  {
        TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant, boost::ref(rInverseJacobian) );
    }

    virtual void GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetJacobianForElement = this->get_override( "GetJacobianForElement" ) )
            func_GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
        }
    }
    
    void default_GetJacobianForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_matrix< double, 3, 3 > & rJacobian, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetJacobianForElement( elementIndex, boost::ref(rJacobian), rJacobianDeterminant );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual unsigned int GetNumBoundaryElements(  ) const  {
        if( bp::override func_GetNumBoundaryElements = this->get_override( "GetNumBoundaryElements" ) )
            return func_GetNumBoundaryElements(  );
        else{
            return this->MutableMesh< 3, 3 >::GetNumBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumBoundaryElements(  ) const  {
        return MutableMesh< 3, 3 >::GetNumBoundaryElements( );
    }

    virtual unsigned int GetNumCableElements(  ) const  {
        if( bp::override func_GetNumCableElements = this->get_override( "GetNumCableElements" ) )
            return func_GetNumCableElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements(  );
        }
    }
    
    unsigned int default_GetNumCableElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements( );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->MutableMesh< 3, 3 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return MutableMesh< 3, 3 >::GetNumElements( );
    }

    virtual unsigned int GetNumLocalBoundaryElements(  ) const  {
        if( bp::override func_GetNumLocalBoundaryElements = this->get_override( "GetNumLocalBoundaryElements" ) )
            return func_GetNumLocalBoundaryElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements(  );
        }
    }
    
    unsigned int default_GetNumLocalBoundaryElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements( );
    }

    virtual unsigned int GetNumLocalElements(  ) const  {
        if( bp::override func_GetNumLocalElements = this->get_override( "GetNumLocalElements" ) )
            return func_GetNumLocalElements(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements(  );
        }
    }
    
    unsigned int default_GetNumLocalElements(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements( );
    }

    virtual unsigned int GetNumVertices(  ) const  {
        if( bp::override func_GetNumVertices = this->get_override( "GetNumVertices" ) )
            return func_GetNumVertices(  );
        else{
            return this->AbstractTetrahedralMesh< 3, 3 >::GetNumVertices(  );
        }
    }
    
    unsigned int default_GetNumVertices(  ) const  {
        return AbstractTetrahedralMesh< 3, 3 >::GetNumVertices( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual void GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForBoundaryElement = this->get_override( "GetWeightedDirectionForBoundaryElement" ) )
            func_GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForBoundaryElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        if( bp::override func_GetWeightedDirectionForElement = this->get_override( "GetWeightedDirectionForElement" ) )
            func_GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        else{
            this->TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
        }
    }
    
    void default_GetWeightedDirectionForElement( unsigned int elementIndex, ::boost::numeric::ublas::c_vector< double, 3 > & rWeightedDirection, double & rJacobianDeterminant ) const  {
        TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement( elementIndex, boost::ref(rWeightedDirection), rJacobianDeterminant );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->TetrahedralMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        TetrahedralMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshJacobianCachedData(  ) {
        if( bp::override func_RefreshJacobianCachedData = this->get_override( "RefreshJacobianCachedData" ) )
            func_RefreshJacobianCachedData(  );
        else{
            this->TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData(  );
        }
    }
    
    void default_RefreshJacobianCachedData(  ) {
        TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData( );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->TetrahedralMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        TetrahedralMesh< 3, 3 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships( );
    }

    virtual unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        if( bp::override func_SolveBoundaryElementMapping = this->get_override( "SolveBoundaryElementMapping" ) )
            return func_SolveBoundaryElementMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveBoundaryElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveBoundaryElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveBoundaryElementMapping( index );
    }

    virtual unsigned int SolveElementMapping( unsigned int index ) const {
        if( bp::override func_SolveElementMapping = this->get_override( "SolveElementMapping" ) )
            return func_SolveElementMapping( index );
        else{
            return this->TetrahedralMesh< 3, 3 >::SolveElementMapping( index );
        }
    }
    
    virtual unsigned int default_SolveElementMapping( unsigned int index ) const {
        return TetrahedralMesh< 3, 3 >::SolveElementMapping( index );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct PottsMesh_less__2__greater__wrapper : PottsMesh< 2 >, bp::wrapper< PottsMesh< 2 > > {

    PottsMesh_less__2__greater__wrapper(::std::vector< Node<2> * > nodes, ::std::vector< PottsElement<2> * > pottsElements, ::std::vector< std::set< unsigned int > > vonNeumannNeighbouringNodeIndices, ::std::vector< std::set< unsigned int > > mooreNeighbouringNodeIndices )
    : PottsMesh<2>( nodes, pottsElements, vonNeumannNeighbouringNodeIndices, mooreNeighbouringNodeIndices )
      , bp::wrapper< PottsMesh< 2 > >(){
        // constructor
    
    }

    PottsMesh_less__2__greater__wrapper( )
    : PottsMesh<2>( )
      , bp::wrapper< PottsMesh< 2 > >(){
        // null constructor
    
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->PottsMesh< 2 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        PottsMesh< 2 >::Clear( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetCentroidOfElement( unsigned int index ) {
        if( bp::override func_GetCentroidOfElement = this->get_override( "GetCentroidOfElement" ) )
            return func_GetCentroidOfElement( index );
        else{
            return this->PottsMesh< 2 >::GetCentroidOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetCentroidOfElement( unsigned int index ) {
        return PottsMesh< 2 >::GetCentroidOfElement( index );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->PottsMesh< 2 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return PottsMesh< 2 >::GetNumElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->PottsMesh< 2 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return PottsMesh< 2 >::GetNumNodes( );
    }

    virtual double GetSurfaceAreaOfElement( unsigned int index ) {
        if( bp::override func_GetSurfaceAreaOfElement = this->get_override( "GetSurfaceAreaOfElement" ) )
            return func_GetSurfaceAreaOfElement( index );
        else{
            return this->PottsMesh< 2 >::GetSurfaceAreaOfElement( index );
        }
    }
    
    double default_GetSurfaceAreaOfElement( unsigned int index ) {
        return PottsMesh< 2 >::GetSurfaceAreaOfElement( index );
    }

    virtual double GetVolumeOfElement( unsigned int index ) {
        if( bp::override func_GetVolumeOfElement = this->get_override( "GetVolumeOfElement" ) )
            return func_GetVolumeOfElement( index );
        else{
            return this->PottsMesh< 2 >::GetVolumeOfElement( index );
        }
    }
    
    double default_GetVolumeOfElement( unsigned int index ) {
        return PottsMesh< 2 >::GetVolumeOfElement( index );
    }

    unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        return PottsMesh< 2 >::SolveBoundaryElementMapping( index );
    }

    unsigned int SolveElementMapping( unsigned int index ) const {
        return PottsMesh< 2 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->PottsMesh< 2 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return PottsMesh< 2 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 2 > CalculateBoundingBox( ::std::vector< Node<2> * > const & rNodes ) const {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 2 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 2, 2 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 2 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 2, 2 >::CalculateBoundingBox( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 2 > const & rTestPoint ) {
        return AbstractMesh< 2, 2 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 2, 2 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 2, 2 >::GetNumAllNodes( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 2 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 2 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 2 > const & rLocationB ) {
        return AbstractMesh< 2, 2 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 2, 2 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 2, 2 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 2, 2 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 2, 2 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 2, 2 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 2, 2 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 2, 2 > rotationMatrix ) {
        AbstractMesh< 2, 2 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 2, 2 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 2, 2 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 2, 2 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 2, 2 >::SetElementOwnerships( );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 2 > const & rDisplacement ) {
        AbstractMesh< 2, 2 >::Translate( boost::ref(rDisplacement) );
    }

};

struct PottsMesh_less__3__greater__wrapper : PottsMesh< 3 >, bp::wrapper< PottsMesh< 3 > > {

    PottsMesh_less__3__greater__wrapper(::std::vector< Node<3> * > nodes, ::std::vector< PottsElement<3> * > pottsElements, ::std::vector< std::set< unsigned int > > vonNeumannNeighbouringNodeIndices, ::std::vector< std::set< unsigned int > > mooreNeighbouringNodeIndices )
    : PottsMesh<3>( nodes, pottsElements, vonNeumannNeighbouringNodeIndices, mooreNeighbouringNodeIndices )
      , bp::wrapper< PottsMesh< 3 > >(){
        // constructor
    
    }

    PottsMesh_less__3__greater__wrapper( )
    : PottsMesh<3>( )
      , bp::wrapper< PottsMesh< 3 > >(){
        // null constructor
    
    }

    virtual void Clear(  ) {
        if( bp::override func_Clear = this->get_override( "Clear" ) )
            func_Clear(  );
        else{
            this->PottsMesh< 3 >::Clear(  );
        }
    }
    
    void default_Clear(  ) {
        PottsMesh< 3 >::Clear( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetCentroidOfElement( unsigned int index ) {
        if( bp::override func_GetCentroidOfElement = this->get_override( "GetCentroidOfElement" ) )
            return func_GetCentroidOfElement( index );
        else{
            return this->PottsMesh< 3 >::GetCentroidOfElement( index );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetCentroidOfElement( unsigned int index ) {
        return PottsMesh< 3 >::GetCentroidOfElement( index );
    }

    virtual unsigned int GetNumElements(  ) const  {
        if( bp::override func_GetNumElements = this->get_override( "GetNumElements" ) )
            return func_GetNumElements(  );
        else{
            return this->PottsMesh< 3 >::GetNumElements(  );
        }
    }
    
    unsigned int default_GetNumElements(  ) const  {
        return PottsMesh< 3 >::GetNumElements( );
    }

    virtual unsigned int GetNumNodes(  ) const  {
        if( bp::override func_GetNumNodes = this->get_override( "GetNumNodes" ) )
            return func_GetNumNodes(  );
        else{
            return this->PottsMesh< 3 >::GetNumNodes(  );
        }
    }
    
    unsigned int default_GetNumNodes(  ) const  {
        return PottsMesh< 3 >::GetNumNodes( );
    }

    virtual double GetSurfaceAreaOfElement( unsigned int index ) {
        if( bp::override func_GetSurfaceAreaOfElement = this->get_override( "GetSurfaceAreaOfElement" ) )
            return func_GetSurfaceAreaOfElement( index );
        else{
            return this->PottsMesh< 3 >::GetSurfaceAreaOfElement( index );
        }
    }
    
    double default_GetSurfaceAreaOfElement( unsigned int index ) {
        return PottsMesh< 3 >::GetSurfaceAreaOfElement( index );
    }

    virtual double GetVolumeOfElement( unsigned int index ) {
        if( bp::override func_GetVolumeOfElement = this->get_override( "GetVolumeOfElement" ) )
            return func_GetVolumeOfElement( index );
        else{
            return this->PottsMesh< 3 >::GetVolumeOfElement( index );
        }
    }
    
    double default_GetVolumeOfElement( unsigned int index ) {
        return PottsMesh< 3 >::GetVolumeOfElement( index );
    }

    unsigned int SolveBoundaryElementMapping( unsigned int index ) const {
        return PottsMesh< 3 >::SolveBoundaryElementMapping( index );
    }

    unsigned int SolveElementMapping( unsigned int index ) const {
        return PottsMesh< 3 >::SolveElementMapping( index );
    }

    virtual unsigned int SolveNodeMapping( unsigned int index ) const {
        if( bp::override func_SolveNodeMapping = this->get_override( "SolveNodeMapping" ) )
            return func_SolveNodeMapping( index );
        else{
            return this->PottsMesh< 3 >::SolveNodeMapping( index );
        }
    }
    
    virtual unsigned int default_SolveNodeMapping( unsigned int index ) const {
        return PottsMesh< 3 >::SolveNodeMapping( index );
    }

    ::ChasteCuboid< 3 > CalculateBoundingBox( ::std::vector< Node<3> * > const & rNodes ) const {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( boost::ref(rNodes) );
    }

    virtual ::ChasteCuboid< 3 > CalculateBoundingBox(  ) const  {
        if( bp::override func_CalculateBoundingBox = this->get_override( "CalculateBoundingBox" ) )
            return func_CalculateBoundingBox(  );
        else{
            return this->AbstractMesh< 3, 3 >::CalculateBoundingBox(  );
        }
    }
    
    ::ChasteCuboid< 3 > default_CalculateBoundingBox(  ) const  {
        return AbstractMesh< 3, 3 >::CalculateBoundingBox( );
    }

    virtual unsigned int GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        if( bp::override func_GetNearestNodeIndex = this->get_override( "GetNearestNodeIndex" ) )
            return func_GetNearestNodeIndex( boost::ref(rTestPoint) );
        else{
            return this->AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
        }
    }
    
    unsigned int default_GetNearestNodeIndex( ::ChastePoint< 3 > const & rTestPoint ) {
        return AbstractMesh< 3, 3 >::GetNearestNodeIndex( boost::ref(rTestPoint) );
    }

    virtual unsigned int GetNumAllNodes(  ) const  {
        if( bp::override func_GetNumAllNodes = this->get_override( "GetNumAllNodes" ) )
            return func_GetNumAllNodes(  );
        else{
            return this->AbstractMesh< 3, 3 >::GetNumAllNodes(  );
        }
    }
    
    unsigned int default_GetNumAllNodes(  ) const  {
        return AbstractMesh< 3, 3 >::GetNumAllNodes( );
    }

    virtual ::boost::numeric::ublas::c_vector< double, 3 > GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        if( bp::override func_GetVectorFromAtoB = this->get_override( "GetVectorFromAtoB" ) )
            return func_GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        else{
            return this->AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
        }
    }
    
    ::boost::numeric::ublas::c_vector< double, 3 > default_GetVectorFromAtoB( ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationA, ::boost::numeric::ublas::c_vector< double, 3 > const & rLocationB ) {
        return AbstractMesh< 3, 3 >::GetVectorFromAtoB( boost::ref(rLocationA), boost::ref(rLocationB) );
    }

    virtual double GetWidth( unsigned int const & rDimension ) const  {
        if( bp::override func_GetWidth = this->get_override( "GetWidth" ) )
            return func_GetWidth( rDimension );
        else{
            return this->AbstractMesh< 3, 3 >::GetWidth( rDimension );
        }
    }
    
    double default_GetWidth( unsigned int const & rDimension ) const  {
        return AbstractMesh< 3, 3 >::GetWidth( rDimension );
    }

    virtual void PermuteNodes(  ) {
        if( bp::override func_PermuteNodes = this->get_override( "PermuteNodes" ) )
            func_PermuteNodes(  );
        else{
            this->AbstractMesh< 3, 3 >::PermuteNodes(  );
        }
    }
    
    void default_PermuteNodes(  ) {
        AbstractMesh< 3, 3 >::PermuteNodes( );
    }

    virtual void ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        if( bp::override func_ReadNodesPerProcessorFile = this->get_override( "ReadNodesPerProcessorFile" ) )
            func_ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        else{
            this->AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
        }
    }
    
    void default_ReadNodesPerProcessorFile( ::std::string const & rNodesPerProcessorFile ) {
        AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile( rNodesPerProcessorFile );
    }

    virtual void RefreshMesh(  ) {
        if( bp::override func_RefreshMesh = this->get_override( "RefreshMesh" ) )
            func_RefreshMesh(  );
        else{
            this->AbstractMesh< 3, 3 >::RefreshMesh(  );
        }
    }
    
    void default_RefreshMesh(  ) {
        AbstractMesh< 3, 3 >::RefreshMesh( );
    }

    virtual void Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        if( bp::override func_Rotate = this->get_override( "Rotate" ) )
            func_Rotate( rotationMatrix );
        else{
            this->AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
        }
    }
    
    void default_Rotate( ::boost::numeric::ublas::c_matrix< double, 3, 3 > rotationMatrix ) {
        AbstractMesh< 3, 3 >::Rotate( rotationMatrix );
    }

    virtual void Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        if( bp::override func_Scale = this->get_override( "Scale" ) )
            func_Scale( xFactor, yFactor, zFactor );
        else{
            this->AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
        }
    }
    
    void default_Scale( double const xFactor=1., double const yFactor=1., double const zFactor=1. ) {
        AbstractMesh< 3, 3 >::Scale( xFactor, yFactor, zFactor );
    }

    virtual void SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        if( bp::override func_SetDistributedVectorFactory = this->get_override( "SetDistributedVectorFactory" ) )
            func_SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        else{
            this->AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
        }
    }
    
    void default_SetDistributedVectorFactory( ::DistributedVectorFactory * pFactory ) {
        AbstractMesh< 3, 3 >::SetDistributedVectorFactory( boost::python::ptr(pFactory) );
    }

    virtual void SetElementOwnerships(  ){
        if( bp::override func_SetElementOwnerships = this->get_override( "SetElementOwnerships" ) )
            func_SetElementOwnerships(  );
        else{
            this->AbstractMesh< 3, 3 >::SetElementOwnerships(  );
        }
    }
    
    virtual void default_SetElementOwnerships(  ){
        AbstractMesh< 3, 3 >::SetElementOwnerships( );
    }

    virtual void Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        if( bp::override func_Translate = this->get_override( "Translate" ) )
            func_Translate( boost::ref(rDisplacement) );
        else{
            this->AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
        }
    }
    
    void default_Translate( ::boost::numeric::ublas::c_vector< double, 3 > const & rDisplacement ) {
        AbstractMesh< 3, 3 >::Translate( boost::ref(rDisplacement) );
    }

};

struct SharedHoneycombMeshGenerator_wrapper : SharedHoneycombMeshGenerator, bp::wrapper< SharedHoneycombMeshGenerator > {

    SharedHoneycombMeshGenerator_wrapper(SharedHoneycombMeshGenerator const & arg )
    : SharedHoneycombMeshGenerator( arg )
      , bp::wrapper< SharedHoneycombMeshGenerator >(){
        // copy constructor
        
    }

    SharedHoneycombMeshGenerator_wrapper(unsigned int numNodesAlongWidth, unsigned int numNodesAlongLength, unsigned int ghosts=0, double scaleFactor=1. )
    : SharedHoneycombMeshGenerator( numNodesAlongWidth, numNodesAlongLength, ghosts, scaleFactor )
      , bp::wrapper< SharedHoneycombMeshGenerator >(){
        // constructor
    
    }

    SharedHoneycombMeshGenerator_wrapper( )
    : SharedHoneycombMeshGenerator( )
      , bp::wrapper< SharedHoneycombMeshGenerator >(){
        // null constructor
    
    }

    virtual ::boost::shared_ptr< MutableMesh< 2, 2 > > GetMesh(  ) {
        if( bp::override func_GetMesh = this->get_override( "GetMesh" ) )
            return func_GetMesh(  );
        else{
            return this->SharedHoneycombMeshGenerator::GetMesh(  );
        }
    }
    
    ::boost::shared_ptr< MutableMesh< 2, 2 > > default_GetMesh(  ) {
        return SharedHoneycombMeshGenerator::GetMesh( );
    }

};

struct SharedHoneycombVertexMeshGenerator_wrapper : SharedHoneycombVertexMeshGenerator, bp::wrapper< SharedHoneycombVertexMeshGenerator > {

    SharedHoneycombVertexMeshGenerator_wrapper(SharedHoneycombVertexMeshGenerator const & arg )
    : SharedHoneycombVertexMeshGenerator( arg )
      , bp::wrapper< SharedHoneycombVertexMeshGenerator >(){
        // copy constructor
        
    }

    SharedHoneycombVertexMeshGenerator_wrapper(unsigned int numElementsAcross, unsigned int numElementsUp, bool isFlatBottom=false, double cellRearrangementThreshold=0.01, double t2Threshold=0.001, double elementArea=0.5 * sqrt(3.) )
    : SharedHoneycombVertexMeshGenerator( numElementsAcross, numElementsUp, isFlatBottom, cellRearrangementThreshold, t2Threshold, elementArea )
      , bp::wrapper< SharedHoneycombVertexMeshGenerator >(){
        // constructor
    
    }

    SharedHoneycombVertexMeshGenerator_wrapper( )
    : SharedHoneycombVertexMeshGenerator( )
      , bp::wrapper< SharedHoneycombVertexMeshGenerator >(){
        // null constructor
    
    }

    virtual ::boost::shared_ptr< MutableVertexMesh< 2, 2 > > GetMesh(  ) {
        if( bp::override func_GetMesh = this->get_override( "GetMesh" ) )
            return func_GetMesh(  );
        else{
            return this->SharedHoneycombVertexMeshGenerator::GetMesh(  );
        }
    }
    
    ::boost::shared_ptr< MutableVertexMesh< 2, 2 > > default_GetMesh(  ) {
        return SharedHoneycombVertexMeshGenerator::GetMesh( );
    }

};

struct SharedPottsMeshGenerator_less__2__greater__wrapper : SharedPottsMeshGenerator< 2 >, bp::wrapper< SharedPottsMeshGenerator< 2 > > {

    SharedPottsMeshGenerator_less__2__greater__wrapper(SharedPottsMeshGenerator<2> const & arg )
    : SharedPottsMeshGenerator<2>( arg )
      , bp::wrapper< SharedPottsMeshGenerator< 2 > >(){
        // copy constructor
        
    }

    SharedPottsMeshGenerator_less__2__greater__wrapper(unsigned int numNodesAcross, unsigned int numElementsAcross, unsigned int elementWidth, unsigned int numNodesUp=1U, unsigned int numElementsUp=1U, unsigned int elementHeight=1U, unsigned int numNodesDeep=1U, unsigned int numElementsDeep=1U, unsigned int elementDepth=1U, bool startAtBottomLeft=false, bool isPeriodicInX=false, bool isPeriodicInY=false, bool isPeriodicInZ=false )
    : SharedPottsMeshGenerator<2>( numNodesAcross, numElementsAcross, elementWidth, numNodesUp, numElementsUp, elementHeight, numNodesDeep, numElementsDeep, elementDepth, startAtBottomLeft, isPeriodicInX, isPeriodicInY, isPeriodicInZ )
      , bp::wrapper< SharedPottsMeshGenerator< 2 > >(){
        // constructor
    
    }

    SharedPottsMeshGenerator_less__2__greater__wrapper( )
    : SharedPottsMeshGenerator<2>( )
      , bp::wrapper< SharedPottsMeshGenerator< 2 > >(){
        // null constructor
    
    }

    virtual ::boost::shared_ptr< PottsMesh< 2 > > GetMesh(  ) {
        if( bp::override func_GetMesh = this->get_override( "GetMesh" ) )
            return func_GetMesh(  );
        else{
            return this->SharedPottsMeshGenerator< 2 >::GetMesh(  );
        }
    }
    
    ::boost::shared_ptr< PottsMesh< 2 > > default_GetMesh(  ) {
        return SharedPottsMeshGenerator< 2 >::GetMesh( );
    }

};

struct SharedPottsMeshGenerator_less__3__greater__wrapper : SharedPottsMeshGenerator< 3 >, bp::wrapper< SharedPottsMeshGenerator< 3 > > {

    SharedPottsMeshGenerator_less__3__greater__wrapper(SharedPottsMeshGenerator<3> const & arg )
    : SharedPottsMeshGenerator<3>( arg )
      , bp::wrapper< SharedPottsMeshGenerator< 3 > >(){
        // copy constructor
        
    }

    SharedPottsMeshGenerator_less__3__greater__wrapper(unsigned int numNodesAcross, unsigned int numElementsAcross, unsigned int elementWidth, unsigned int numNodesUp=1U, unsigned int numElementsUp=1U, unsigned int elementHeight=1U, unsigned int numNodesDeep=1U, unsigned int numElementsDeep=1U, unsigned int elementDepth=1U, bool startAtBottomLeft=false, bool isPeriodicInX=false, bool isPeriodicInY=false, bool isPeriodicInZ=false )
    : SharedPottsMeshGenerator<3>( numNodesAcross, numElementsAcross, elementWidth, numNodesUp, numElementsUp, elementHeight, numNodesDeep, numElementsDeep, elementDepth, startAtBottomLeft, isPeriodicInX, isPeriodicInY, isPeriodicInZ )
      , bp::wrapper< SharedPottsMeshGenerator< 3 > >(){
        // constructor
    
    }

    SharedPottsMeshGenerator_less__3__greater__wrapper( )
    : SharedPottsMeshGenerator<3>( )
      , bp::wrapper< SharedPottsMeshGenerator< 3 > >(){
        // null constructor
    
    }

    virtual ::boost::shared_ptr< PottsMesh< 3 > > GetMesh(  ) {
        if( bp::override func_GetMesh = this->get_override( "GetMesh" ) )
            return func_GetMesh(  );
        else{
            return this->SharedPottsMeshGenerator< 3 >::GetMesh(  );
        }
    }
    
    ::boost::shared_ptr< PottsMesh< 3 > > default_GetMesh(  ) {
        return SharedPottsMeshGenerator< 3 >::GetMesh( );
    }

};

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::numeric::ublas::c_vector< double, 2 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::numeric::ublas::c_vector< double, 3 > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< Node< 2 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< boost::shared_ptr< Node< 3 > > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< std::set< unsigned int > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

namespace boost { namespace python { namespace indexing {

template<>
struct value_traits< std::vector< unsigned int > >{

    static bool const equality_comparable = false;
    

    static bool const less_than_comparable = false;
    

    template<typename PythonClass, typename Policy>
    static void visit_container_class(PythonClass &, Policy const &){
        
    }

};

}/*indexing*/ } /*python*/ } /*boost*/

BOOST_PYTHON_MODULE(_chaste_project_PyChaste_mesh){
    { //::std::vector< unsigned int >
        typedef bp::class_< std::vector< unsigned int > > vector_less__unsigned_int__greater__exposer_t;
        vector_less__unsigned_int__greater__exposer_t vector_less__unsigned_int__greater__exposer = vector_less__unsigned_int__greater__exposer_t( "vector_less__unsigned_int__greater_" );
        bp::scope vector_less__unsigned_int__greater__scope( vector_less__unsigned_int__greater__exposer );
        vector_less__unsigned_int__greater__exposer.def( bp::indexing::vector_suite< std::vector< unsigned int > >() );
    }

    { //::std::vector< std::vector< unsigned int > >
        typedef bp::class_< std::vector< std::vector< unsigned int > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< std::vector< unsigned int > > >() );
    }

    { //::std::vector< std::set< unsigned int > >
        typedef bp::class_< std::vector< std::set< unsigned int > > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< std::set< unsigned int > > >() );
    }

    bp::class_< std::vector< std::pair<Node<3> *, Node<3> *> > >("vector_less__std_scope_pair_less_Node_less_3_greater___ptr__comma__Node_less_3_greater___ptr__greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< std::pair<Node<3> *, Node<3> *> > >() );

    bp::class_< std::vector< std::pair<Node<2> *, Node<2> *> > >("vector_less__std_scope_pair_less_Node_less_2_greater___ptr__comma__Node_less_2_greater___ptr__greater___greater_")    
        .def( bp::indexing::vector_suite< std::vector< std::pair<Node<2> *, Node<2> *> > >() );

    { //::std::vector< double >
        typedef bp::class_< std::vector< double > > vector_less__double__greater__exposer_t;
        vector_less__double__greater__exposer_t vector_less__double__greater__exposer = vector_less__double__greater__exposer_t( "vector_less__double__greater_" );
        bp::scope vector_less__double__greater__scope( vector_less__double__greater__exposer );
        vector_less__double__greater__exposer.def( bp::indexing::vector_suite< std::vector< double > >() );
    }

    { //::std::vector< boost::shared_ptr<Node<3> > >
        typedef bp::class_< std::vector< boost::shared_ptr<Node<3> > > > vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater__exposer_t;
        vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater__exposer_t vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater__exposer = vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater__exposer_t( "vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater_" );
        bp::scope vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater__scope( vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater__exposer );
        vector_less__boost_scope_shared_ptr_less_Node_less_3_greater___greater___greater__exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<Node<3> > > >() );
    }

    { //::std::vector< boost::shared_ptr<Node<2> > >
        typedef bp::class_< std::vector< boost::shared_ptr<Node<2> > > > vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater__exposer_t;
        vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater__exposer_t vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater__exposer = vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater__exposer_t( "vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater_" );
        bp::scope vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater__scope( vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater__exposer );
        vector_less__boost_scope_shared_ptr_less_Node_less_2_greater___greater___greater__exposer.def( bp::indexing::vector_suite< std::vector< boost::shared_ptr<Node<2> > > >() );
    }

    { //::std::vector< boost::numeric::ublas::c_vector<double, 3> >
        typedef bp::class_< std::vector< boost::numeric::ublas::c_vector<double, 3> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::numeric::ublas::c_vector<double, 3> > >() );
    }

    { //::std::vector< boost::numeric::ublas::c_vector<double, 2> >
        typedef bp::class_< std::vector< boost::numeric::ublas::c_vector<double, 2> > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< boost::numeric::ublas::c_vector<double, 2> > >() );
    }

    { //::std::vector< VertexElement<3, 3> * >
        typedef bp::class_< std::vector< VertexElement<3, 3> * > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< VertexElement<3, 3> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< VertexElement<2, 3> * >
        typedef bp::class_< std::vector< VertexElement<2, 3> * > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< VertexElement<2, 3> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< VertexElement<2, 2> * >
        typedef bp::class_< std::vector< VertexElement<2, 2> * > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< VertexElement<2, 2> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< VertexElement<1, 2> * >
        typedef bp::class_< std::vector< VertexElement<1, 2> * > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< VertexElement<1, 2> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< PottsElement<3> * >
        typedef bp::class_< std::vector< PottsElement<3> * > > vector_less__PottsElement_less_3_greater___ptr___greater__exposer_t;
        vector_less__PottsElement_less_3_greater___ptr___greater__exposer_t vector_less__PottsElement_less_3_greater___ptr___greater__exposer = vector_less__PottsElement_less_3_greater___ptr___greater__exposer_t( "vector_less__PottsElement_less_3_greater___ptr___greater_" );
        bp::scope vector_less__PottsElement_less_3_greater___ptr___greater__scope( vector_less__PottsElement_less_3_greater___ptr___greater__exposer );
        vector_less__PottsElement_less_3_greater___ptr___greater__exposer.def( bp::indexing::vector_suite< std::vector< PottsElement<3> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< PottsElement<2> * >
        typedef bp::class_< std::vector< PottsElement<2> * > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< PottsElement<2> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< Node<3> * >
        typedef bp::class_< std::vector< Node<3> * > > vector_less__Node_less_3_greater___ptr___greater__exposer_t;
        vector_less__Node_less_3_greater___ptr___greater__exposer_t vector_less__Node_less_3_greater___ptr___greater__exposer = vector_less__Node_less_3_greater___ptr___greater__exposer_t( "vector_less__Node_less_3_greater___ptr___greater_" );
        bp::scope vector_less__Node_less_3_greater___ptr___greater__scope( vector_less__Node_less_3_greater___ptr___greater__exposer );
        vector_less__Node_less_3_greater___ptr___greater__exposer.def( bp::indexing::vector_suite< std::vector< Node<3> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::vector< Node<2> * >
        typedef bp::class_< std::vector< Node<2> * > > __type_exposer_t;
        __type_exposer_t __type_exposer = __type_exposer_t( "__type" );
        bp::scope __type_scope( __type_exposer );
        __type_exposer.def( bp::indexing::vector_suite< std::vector< Node<2> * > >::with_policies(bp::return_internal_reference< >()) );
    }

    { //::std::set< unsigned int >
        typedef bp::class_< std::set< unsigned int > > set_less__unsigned_int__greater__exposer_t;
        set_less__unsigned_int__greater__exposer_t set_less__unsigned_int__greater__exposer = set_less__unsigned_int__greater__exposer_t( "set_less__unsigned_int__greater_" );
        bp::scope set_less__unsigned_int__greater__scope( set_less__unsigned_int__greater__exposer );
        set_less__unsigned_int__greater__exposer.def( bp::indexing::set_suite< std::set< unsigned int > >() );
    }

    bp::class_< AbstractMesh_less__2_comma__2__greater__wrapper, boost::noncopyable >( "AbstractMesh2_2", bp::init< >() )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 2 > ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
            , (::ChasteCuboid< 2 > ( AbstractMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractMesh_less__2_comma__2__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<2> ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( ::std::vector<Node<2> *, std::allocator<Node<2> *> > const & )const)(&AbstractMesh_less__2_comma__2__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateMaximumContainingElementsPerProcess"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::CalculateMaximumContainingElementsPerProcess ) )    
        .def( 
            "GetBoundaryNodeIteratorBegin"
            , (::AbstractMesh< 2, 2 >::BoundaryNodeIterator ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::GetBoundaryNodeIteratorBegin ) )    
        .def( 
            "GetBoundaryNodeIteratorEnd"
            , (::AbstractMesh< 2, 2 >::BoundaryNodeIterator ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::GetBoundaryNodeIteratorEnd ) )    
        .def( 
            "GetDistanceBetweenNodes"
            , (double ( ::AbstractMesh<2, 2>::* )( unsigned int,unsigned int ))( &::AbstractMesh< 2, 2 >::GetDistanceBetweenNodes )
            , ( bp::arg("indexA"), bp::arg("indexB") ) )    
        .def( 
            "GetMeshFileBaseName"
            , (::std::string ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::GetMeshFileBaseName ) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )( ::ChastePoint< 2 > const & ))(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
            , (unsigned int ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( ::ChastePoint< 2 > const & ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNodeIteratorBegin"
            , (::AbstractMesh< 2, 2 >::NodeIterator ( ::AbstractMesh<2, 2>::* )( bool ))( &::AbstractMesh< 2, 2 >::GetNodeIteratorBegin )
            , ( bp::arg("skipDeletedNodes")=(bool)(true) ) )    
        .def( 
            "GetNodeIteratorEnd"
            , (::AbstractMesh< 2, 2 >::NodeIterator ( ::AbstractMesh<2, 2>::* )(  ))( &::AbstractMesh< 2, 2 >::GetNodeIteratorEnd ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
            , (unsigned int ( AbstractMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractMesh_less__2_comma__2__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumBoundaryNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::GetNumBoundaryNodes ) )    
        .def( 
            "GetNumNodeAttributes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::GetNumNodeAttributes ) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::GetNumNodes)
            , (unsigned int ( AbstractMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractMesh_less__2_comma__2__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWidth"
            , (double ( ::AbstractMesh<2, 2>::* )( unsigned int const & )const)(&::AbstractMesh< 2, 2 >::GetWidth)
            , (double ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( unsigned int const & )const)(&AbstractMesh_less__2_comma__2__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "IsMeshChanging"
            , (bool ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::IsMeshChanging ) )    
        .def( 
            "IsMeshOnDisk"
            , (bool ( ::AbstractMesh<2, 2>::* )(  )const)( &::AbstractMesh< 2, 2 >::IsMeshOnDisk ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::AbstractMesh<2, 2>::* )(  ))(&::AbstractMesh< 2, 2 >::PermuteNodes)
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::AbstractMesh<2, 2>::* )( ::std::string const & ))(&::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile)
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( ::std::string const & ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshMesh"
            , (void ( ::AbstractMesh<2, 2>::* )(  ))(&::AbstractMesh< 2, 2 >::RefreshMesh)
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&::AbstractMesh< 2, 2 >::Rotate)
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "RotateX"
            , (void ( ::AbstractMesh<2, 2>::* )( double const ))( &::AbstractMesh< 2, 2 >::RotateX )
            , ( bp::arg("theta") ) )    
        .def( 
            "RotateY"
            , (void ( ::AbstractMesh<2, 2>::* )( double const ))( &::AbstractMesh< 2, 2 >::RotateY )
            , ( bp::arg("theta") ) )    
        .def( 
            "RotateZ"
            , (void ( ::AbstractMesh<2, 2>::* )( double const ))( &::AbstractMesh< 2, 2 >::RotateZ )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))(&::AbstractMesh< 2, 2 >::Scale)
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( double const,double const,double const ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<2, 2>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( ::DistributedVectorFactory * ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "SetMeshHasChangedSinceLoading"
            , (void ( ::AbstractMesh<2, 2>::* )(  ))( &::AbstractMesh< 2, 2 >::SetMeshHasChangedSinceLoading ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::Translate)
            , (void ( AbstractMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&AbstractMesh_less__2_comma__2__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))( &::AbstractMesh< 2, 2 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    bp::class_< AbstractMesh_less__3_comma__3__greater__wrapper, boost::noncopyable >( "AbstractMesh3_3", bp::init< >() )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 3 > ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
            , (::ChasteCuboid< 3 > ( AbstractMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractMesh_less__3_comma__3__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<3> ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( ::std::vector<Node<3> *, std::allocator<Node<3> *> > const & )const)(&AbstractMesh_less__3_comma__3__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateMaximumContainingElementsPerProcess"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::CalculateMaximumContainingElementsPerProcess ) )    
        .def( 
            "GetBoundaryNodeIteratorBegin"
            , (::AbstractMesh< 3, 3 >::BoundaryNodeIterator ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::GetBoundaryNodeIteratorBegin ) )    
        .def( 
            "GetBoundaryNodeIteratorEnd"
            , (::AbstractMesh< 3, 3 >::BoundaryNodeIterator ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::GetBoundaryNodeIteratorEnd ) )    
        .def( 
            "GetDistanceBetweenNodes"
            , (double ( ::AbstractMesh<3, 3>::* )( unsigned int,unsigned int ))( &::AbstractMesh< 3, 3 >::GetDistanceBetweenNodes )
            , ( bp::arg("indexA"), bp::arg("indexB") ) )    
        .def( 
            "GetMeshFileBaseName"
            , (::std::string ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::GetMeshFileBaseName ) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )( ::ChastePoint< 3 > const & ))(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
            , (unsigned int ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( ::ChastePoint< 3 > const & ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNodeIteratorBegin"
            , (::AbstractMesh< 3, 3 >::NodeIterator ( ::AbstractMesh<3, 3>::* )( bool ))( &::AbstractMesh< 3, 3 >::GetNodeIteratorBegin )
            , ( bp::arg("skipDeletedNodes")=(bool)(true) ) )    
        .def( 
            "GetNodeIteratorEnd"
            , (::AbstractMesh< 3, 3 >::NodeIterator ( ::AbstractMesh<3, 3>::* )(  ))( &::AbstractMesh< 3, 3 >::GetNodeIteratorEnd ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
            , (unsigned int ( AbstractMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractMesh_less__3_comma__3__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumBoundaryNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::GetNumBoundaryNodes ) )    
        .def( 
            "GetNumNodeAttributes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::GetNumNodeAttributes ) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumNodes)
            , (unsigned int ( AbstractMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractMesh_less__3_comma__3__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 3 > ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWidth"
            , (double ( ::AbstractMesh<3, 3>::* )( unsigned int const & )const)(&::AbstractMesh< 3, 3 >::GetWidth)
            , (double ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( unsigned int const & )const)(&AbstractMesh_less__3_comma__3__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "IsMeshChanging"
            , (bool ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::IsMeshChanging ) )    
        .def( 
            "IsMeshOnDisk"
            , (bool ( ::AbstractMesh<3, 3>::* )(  )const)( &::AbstractMesh< 3, 3 >::IsMeshOnDisk ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::AbstractMesh<3, 3>::* )(  ))(&::AbstractMesh< 3, 3 >::PermuteNodes)
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::AbstractMesh<3, 3>::* )( ::std::string const & ))(&::AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile)
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( ::std::string const & ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshMesh"
            , (void ( ::AbstractMesh<3, 3>::* )(  ))(&::AbstractMesh< 3, 3 >::RefreshMesh)
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&::AbstractMesh< 3, 3 >::Rotate)
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "RotateX"
            , (void ( ::AbstractMesh<3, 3>::* )( double const ))( &::AbstractMesh< 3, 3 >::RotateX )
            , ( bp::arg("theta") ) )    
        .def( 
            "RotateY"
            , (void ( ::AbstractMesh<3, 3>::* )( double const ))( &::AbstractMesh< 3, 3 >::RotateY )
            , ( bp::arg("theta") ) )    
        .def( 
            "RotateZ"
            , (void ( ::AbstractMesh<3, 3>::* )( double const ))( &::AbstractMesh< 3, 3 >::RotateZ )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))(&::AbstractMesh< 3, 3 >::Scale)
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( double const,double const,double const ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<3, 3>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( ::DistributedVectorFactory * ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "SetMeshHasChangedSinceLoading"
            , (void ( ::AbstractMesh<3, 3>::* )(  ))( &::AbstractMesh< 3, 3 >::SetMeshHasChangedSinceLoading ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::Translate)
            , (void ( AbstractMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&AbstractMesh_less__3_comma__3__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))( &::AbstractMesh< 3, 3 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    bp::class_< AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper, bp::bases< AbstractMesh< 2, 2 > >, boost::noncopyable >( "AbstractTetrahedralMesh2_2", bp::init< >() )    
        .def( 
            "CalculateDesignatedOwnershipOfBoundaryElement"
            , (bool ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement)
            , (bool ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
            , ( bp::arg("faceIndex") ) )    
        .def( 
            "CalculateDesignatedOwnershipOfElement"
            , (bool ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement)
            , (bool ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
            , ( bp::arg("elementIndex") ) )    
        .def( 
            "CalculateMaximumNodeConnectivityPerProcess"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)( &::AbstractTetrahedralMesh< 2, 2 >::CalculateMaximumNodeConnectivityPerProcess ) )    
        .def( 
            "CalculateMinMaxEdgeLengths"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractTetrahedralMesh<2, 2>::* )(  ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateMinMaxEdgeLengths) )    
        .def( 
            "CalculateNodeExchange"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( ::std::vector< std::vector< unsigned int > > &,::std::vector< std::vector< unsigned int > > & ))( &::AbstractTetrahedralMesh< 2, 2 >::CalculateNodeExchange )
            , ( bp::arg("rNodesToSendPerProcess"), bp::arg("rNodesToReceivePerProcess") ) )    
        .def( 
            "CheckOutwardNormals"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )(  ))( &::AbstractTetrahedralMesh< 2, 2 >::CheckOutwardNormals ) )    
        .def( 
            "ConstructCuboid"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,unsigned int,unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,unsigned int,unsigned int ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_ConstructCuboid)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) )    
        .def( 
            "ConstructFromMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( ::AbstractTetrahedralMesh< 2, 2 > & ))( &::AbstractTetrahedralMesh< 2, 2 >::ConstructFromMesh )
            , ( bp::arg("rOtherMesh") ) )    
        .def( 
            "ConstructFromMeshReader"
            , bp::pure_virtual( (void ( ::AbstractTetrahedralMesh<2, 2>::* )( ::AbstractMeshReader< 2, 2 > & ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructFromMeshReader) )
            , ( bp::arg("rMeshReader") ) )    
        .def( 
            "ConstructLinearMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_ConstructLinearMesh)
            , ( bp::arg("width") ) )    
        .def( 
            "ConstructRectangularMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,unsigned int,bool ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,unsigned int,bool ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_ConstructRectangularMesh)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) )    
        .def( 
            "ConstructRegularSlabMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( double,double,double,double ))( &::AbstractTetrahedralMesh< 2, 2 >::ConstructRegularSlabMesh )
            , ( bp::arg("spaceStep"), bp::arg("width"), bp::arg("height")=0, bp::arg("depth")=0 ) )    
        .def( 
            "ConstructRegularSlabMeshWithDimensionSplit"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,double,double,double,double ))( &::AbstractTetrahedralMesh< 2, 2 >::ConstructRegularSlabMeshWithDimensionSplit )
            , ( bp::arg("dimension"), bp::arg("spaceStep"), bp::arg("width"), bp::arg("height")=0, bp::arg("depth")=0 ) )    
        .def( 
            "GetBoundaryElementIteratorBegin"
            , (::AbstractTetrahedralMesh< 2, 2 >::BoundaryElementIterator ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)( &::AbstractTetrahedralMesh< 2, 2 >::GetBoundaryElementIteratorBegin ) )    
        .def( 
            "GetBoundaryElementIteratorEnd"
            , (::AbstractTetrahedralMesh< 2, 2 >::BoundaryElementIterator ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)( &::AbstractTetrahedralMesh< 2, 2 >::GetBoundaryElementIteratorEnd ) )    
        .def( 
            "GetContainingElementIndex"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )( ::ChastePoint< 2 > const &,bool,::std::set< unsigned int >,bool ))( &::AbstractTetrahedralMesh< 2, 2 >::GetContainingElementIndex )
            , ( bp::arg("rTestPoint"), bp::arg("strict")=(bool)(false), bp::arg("testElements")=std::set<unsigned int>(), bp::arg("onlyTryWithTestElements")=(bool)(false) ) )    
        .def( 
            "GetElementIteratorBegin"
            , (::AbstractTetrahedralMesh< 2, 2 >::ElementIterator ( ::AbstractTetrahedralMesh<2, 2>::* )( bool ))( &::AbstractTetrahedralMesh< 2, 2 >::GetElementIteratorBegin )
            , ( bp::arg("skipDeletedElements")=(bool)(true) ) )    
        .def( 
            "GetElementIteratorEnd"
            , (::AbstractTetrahedralMesh< 2, 2 >::ElementIterator ( ::AbstractTetrahedralMesh<2, 2>::* )(  ))( &::AbstractTetrahedralMesh< 2, 2 >::GetElementIteratorEnd ) )    
        .def( 
            "GetHaloNodeIndices"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( ::std::vector< unsigned int > & )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::std::vector< unsigned int > & )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetHaloNodeIndices)
            , ( bp::arg("rHaloIndices") ) )    
        .def( 
            "GetInverseJacobianForElement"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetInverseJacobianForElement)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetInverseJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) )    
        .def( 
            "GetMaximumNodeIndex"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  ))(&::AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetMaximumNodeIndex) )    
        .def( 
            "GetNearestElementIndexFromTestElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )( ::ChastePoint< 2 > const &,::std::set< unsigned int > ))( &::AbstractTetrahedralMesh< 2, 2 >::GetNearestElementIndexFromTestElements )
            , ( bp::arg("rTestPoint"), bp::arg("testElements") ) )    
        .def( 
            "GetNumAllBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)( &::AbstractTetrahedralMesh< 2, 2 >::GetNumAllBoundaryElements ) )    
        .def( 
            "GetNumAllElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)( &::AbstractTetrahedralMesh< 2, 2 >::GetNumAllElements ) )    
        .def( 
            "GetNumBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumBoundaryElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumBoundaryElements) )    
        .def( 
            "GetNumCableElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumCableElements) )    
        .def( 
            "GetNumElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumElements) )    
        .def( 
            "GetNumLocalBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumLocalBoundaryElements) )    
        .def( 
            "GetNumLocalElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumLocalElements) )    
        .def( 
            "GetNumVertices"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumVertices)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumVertices) )    
        .def( 
            "GetWeightedDirectionForBoundaryElement"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<2> ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::std::vector<Node<2> *, std::allocator<Node<2> *> > const & )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 2 > ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
            , (::ChasteCuboid< 2 > ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )( ::ChastePoint< 2 > const & ))(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::ChastePoint< 2 > const & ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::GetNumNodes)
            , (unsigned int ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWidth"
            , (double ( ::AbstractMesh<2, 2>::* )( unsigned int const & )const)(&::AbstractMesh< 2, 2 >::GetWidth)
            , (double ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int const & )const)(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::AbstractMesh<2, 2>::* )(  ))(&::AbstractMesh< 2, 2 >::PermuteNodes)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::AbstractMesh<2, 2>::* )( ::std::string const & ))(&::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::std::string const & ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshMesh"
            , (void ( ::AbstractMesh<2, 2>::* )(  ))(&::AbstractMesh< 2, 2 >::RefreshMesh)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&::AbstractMesh< 2, 2 >::Rotate)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))(&::AbstractMesh< 2, 2 >::Scale)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( double const,double const,double const ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<2, 2>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::DistributedVectorFactory * ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::Translate)
            , (void ( AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&AbstractTetrahedralMesh_less__2_comma__2__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))( &::AbstractMesh< 2, 2 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    bp::class_< AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper, bp::bases< AbstractMesh< 3, 3 > >, boost::noncopyable >( "AbstractTetrahedralMesh3_3", bp::init< >() )    
        .def( 
            "CalculateDesignatedOwnershipOfBoundaryElement"
            , (bool ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement)
            , (bool ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
            , ( bp::arg("faceIndex") ) )    
        .def( 
            "CalculateDesignatedOwnershipOfElement"
            , (bool ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement)
            , (bool ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
            , ( bp::arg("elementIndex") ) )    
        .def( 
            "CalculateMaximumNodeConnectivityPerProcess"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)( &::AbstractTetrahedralMesh< 3, 3 >::CalculateMaximumNodeConnectivityPerProcess ) )    
        .def( 
            "CalculateMinMaxEdgeLengths"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractTetrahedralMesh<3, 3>::* )(  ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateMinMaxEdgeLengths) )    
        .def( 
            "CalculateNodeExchange"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( ::std::vector< std::vector< unsigned int > > &,::std::vector< std::vector< unsigned int > > & ))( &::AbstractTetrahedralMesh< 3, 3 >::CalculateNodeExchange )
            , ( bp::arg("rNodesToSendPerProcess"), bp::arg("rNodesToReceivePerProcess") ) )    
        .def( 
            "CheckOutwardNormals"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )(  ))( &::AbstractTetrahedralMesh< 3, 3 >::CheckOutwardNormals ) )    
        .def( 
            "ConstructCuboid"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,unsigned int,unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,unsigned int,unsigned int ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_ConstructCuboid)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) )    
        .def( 
            "ConstructFromMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( ::AbstractTetrahedralMesh< 3, 3 > & ))( &::AbstractTetrahedralMesh< 3, 3 >::ConstructFromMesh )
            , ( bp::arg("rOtherMesh") ) )    
        .def( 
            "ConstructFromMeshReader"
            , bp::pure_virtual( (void ( ::AbstractTetrahedralMesh<3, 3>::* )( ::AbstractMeshReader< 3, 3 > & ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructFromMeshReader) )
            , ( bp::arg("rMeshReader") ) )    
        .def( 
            "ConstructLinearMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_ConstructLinearMesh)
            , ( bp::arg("width") ) )    
        .def( 
            "ConstructRectangularMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,unsigned int,bool ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,unsigned int,bool ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_ConstructRectangularMesh)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) )    
        .def( 
            "ConstructRegularSlabMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( double,double,double,double ))( &::AbstractTetrahedralMesh< 3, 3 >::ConstructRegularSlabMesh )
            , ( bp::arg("spaceStep"), bp::arg("width"), bp::arg("height")=0, bp::arg("depth")=0 ) )    
        .def( 
            "ConstructRegularSlabMeshWithDimensionSplit"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,double,double,double,double ))( &::AbstractTetrahedralMesh< 3, 3 >::ConstructRegularSlabMeshWithDimensionSplit )
            , ( bp::arg("dimension"), bp::arg("spaceStep"), bp::arg("width"), bp::arg("height")=0, bp::arg("depth")=0 ) )    
        .def( 
            "GetBoundaryElementIteratorBegin"
            , (::AbstractTetrahedralMesh< 3, 3 >::BoundaryElementIterator ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)( &::AbstractTetrahedralMesh< 3, 3 >::GetBoundaryElementIteratorBegin ) )    
        .def( 
            "GetBoundaryElementIteratorEnd"
            , (::AbstractTetrahedralMesh< 3, 3 >::BoundaryElementIterator ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)( &::AbstractTetrahedralMesh< 3, 3 >::GetBoundaryElementIteratorEnd ) )    
        .def( 
            "GetContainingElementIndex"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )( ::ChastePoint< 3 > const &,bool,::std::set< unsigned int >,bool ))( &::AbstractTetrahedralMesh< 3, 3 >::GetContainingElementIndex )
            , ( bp::arg("rTestPoint"), bp::arg("strict")=(bool)(false), bp::arg("testElements")=std::set<unsigned int>(), bp::arg("onlyTryWithTestElements")=(bool)(false) ) )    
        .def( 
            "GetElementIteratorBegin"
            , (::AbstractTetrahedralMesh< 3, 3 >::ElementIterator ( ::AbstractTetrahedralMesh<3, 3>::* )( bool ))( &::AbstractTetrahedralMesh< 3, 3 >::GetElementIteratorBegin )
            , ( bp::arg("skipDeletedElements")=(bool)(true) ) )    
        .def( 
            "GetElementIteratorEnd"
            , (::AbstractTetrahedralMesh< 3, 3 >::ElementIterator ( ::AbstractTetrahedralMesh<3, 3>::* )(  ))( &::AbstractTetrahedralMesh< 3, 3 >::GetElementIteratorEnd ) )    
        .def( 
            "GetHaloNodeIndices"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( ::std::vector< unsigned int > & )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::std::vector< unsigned int > & )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetHaloNodeIndices)
            , ( bp::arg("rHaloIndices") ) )    
        .def( 
            "GetInverseJacobianForElement"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetInverseJacobianForElement)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetInverseJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) )    
        .def( 
            "GetMaximumNodeIndex"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  ))(&::AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetMaximumNodeIndex) )    
        .def( 
            "GetNearestElementIndexFromTestElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )( ::ChastePoint< 3 > const &,::std::set< unsigned int > ))( &::AbstractTetrahedralMesh< 3, 3 >::GetNearestElementIndexFromTestElements )
            , ( bp::arg("rTestPoint"), bp::arg("testElements") ) )    
        .def( 
            "GetNumAllBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)( &::AbstractTetrahedralMesh< 3, 3 >::GetNumAllBoundaryElements ) )    
        .def( 
            "GetNumAllElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)( &::AbstractTetrahedralMesh< 3, 3 >::GetNumAllElements ) )    
        .def( 
            "GetNumBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumBoundaryElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumBoundaryElements) )    
        .def( 
            "GetNumCableElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumCableElements) )    
        .def( 
            "GetNumElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumElements) )    
        .def( 
            "GetNumLocalBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumLocalBoundaryElements) )    
        .def( 
            "GetNumLocalElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumLocalElements) )    
        .def( 
            "GetNumVertices"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumVertices)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumVertices) )    
        .def( 
            "GetWeightedDirectionForBoundaryElement"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<3> ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::std::vector<Node<3> *, std::allocator<Node<3> *> > const & )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 3 > ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
            , (::ChasteCuboid< 3 > ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )( ::ChastePoint< 3 > const & ))(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::ChastePoint< 3 > const & ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumNodes)
            , (unsigned int ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 3 > ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWidth"
            , (double ( ::AbstractMesh<3, 3>::* )( unsigned int const & )const)(&::AbstractMesh< 3, 3 >::GetWidth)
            , (double ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int const & )const)(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::AbstractMesh<3, 3>::* )(  ))(&::AbstractMesh< 3, 3 >::PermuteNodes)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::AbstractMesh<3, 3>::* )( ::std::string const & ))(&::AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::std::string const & ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshMesh"
            , (void ( ::AbstractMesh<3, 3>::* )(  ))(&::AbstractMesh< 3, 3 >::RefreshMesh)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&::AbstractMesh< 3, 3 >::Rotate)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))(&::AbstractMesh< 3, 3 >::Scale)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( double const,double const,double const ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<3, 3>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::DistributedVectorFactory * ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::Translate)
            , (void ( AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&AbstractTetrahedralMesh_less__3_comma__3__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))( &::AbstractMesh< 3, 3 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    { //::ChastePoint< 2 >
        typedef bp::class_< ChastePoint< 2 > > ChastePoint2_exposer_t;
        ChastePoint2_exposer_t ChastePoint2_exposer = ChastePoint2_exposer_t( "ChastePoint2", bp::init< bp::optional< double, double, double > >(( bp::arg("v1")=0, bp::arg("v2")=0, bp::arg("v3")=0 )) );
        bp::scope ChastePoint2_scope( ChastePoint2_exposer );
        bp::implicitly_convertible< double, ChastePoint< 2 > >();
        ChastePoint2_exposer.def( bp::init< std::vector< double > >(( bp::arg("coords") )) );
        bp::implicitly_convertible< std::vector< double >, ChastePoint< 2 > >();
        ChastePoint2_exposer.def( bp::init< boost::numeric::ublas::c_vector< double, 2 > >(( bp::arg("location") )) );
        bp::implicitly_convertible< boost::numeric::ublas::c_vector< double, 2 >, ChastePoint< 2 > >();
        { //::ChastePoint< 2 >::GetWithDefault
        
            typedef ChastePoint< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetWithDefault_function_type)( unsigned int,double ) const;
            
            ChastePoint2_exposer.def( 
                "GetWithDefault"
                , GetWithDefault_function_type( &::ChastePoint< 2 >::GetWithDefault )
                , ( bp::arg("i"), bp::arg("def")=0. ) );
        
        }
        { //::ChastePoint< 2 >::IsSamePoint
        
            typedef ChastePoint< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsSamePoint_function_type)( ::ChastePoint< 2 > const & ) const;
            
            ChastePoint2_exposer.def( 
                "IsSamePoint"
                , IsSamePoint_function_type( &::ChastePoint< 2 >::IsSamePoint )
                , ( bp::arg("rPoint") ) );
        
        }
        { //::ChastePoint< 2 >::SetCoordinate
        
            typedef ChastePoint< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCoordinate_function_type)( unsigned int,double ) ;
            
            ChastePoint2_exposer.def( 
                "SetCoordinate"
                , SetCoordinate_function_type( &::ChastePoint< 2 >::SetCoordinate )
                , ( bp::arg("i"), bp::arg("value") ) );
        
        }
        { //::ChastePoint< 2 >::operator[]
        
            typedef ChastePoint< 2 > exported_class_t;
            typedef double ( exported_class_t::*__getitem___function_type)( unsigned int ) const;
            
            ChastePoint2_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::ChastePoint< 2 >::operator[] )
                , ( bp::arg("i") ) );
        
        }
        { //::ChastePoint< 2 >::rGetLocation
        
            typedef ChastePoint< 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > const & ( exported_class_t::*rGetLocation_function_type)(  ) const;
            
            ChastePoint2_exposer.def( 
                "rGetLocation"
                , rGetLocation_function_type( &::ChastePoint< 2 >::rGetLocation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
    }

    { //::ChastePoint< 3 >
        typedef bp::class_< ChastePoint< 3 > > ChastePoint3_exposer_t;
        ChastePoint3_exposer_t ChastePoint3_exposer = ChastePoint3_exposer_t( "ChastePoint3", bp::init< bp::optional< double, double, double > >(( bp::arg("v1")=0, bp::arg("v2")=0, bp::arg("v3")=0 )) );
        bp::scope ChastePoint3_scope( ChastePoint3_exposer );
        bp::implicitly_convertible< double, ChastePoint< 3 > >();
        ChastePoint3_exposer.def( bp::init< std::vector< double > >(( bp::arg("coords") )) );
        bp::implicitly_convertible< std::vector< double >, ChastePoint< 3 > >();
        ChastePoint3_exposer.def( bp::init< boost::numeric::ublas::c_vector< double, 3 > >(( bp::arg("location") )) );
        bp::implicitly_convertible< boost::numeric::ublas::c_vector< double, 3 >, ChastePoint< 3 > >();
        { //::ChastePoint< 3 >::GetWithDefault
        
            typedef ChastePoint< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetWithDefault_function_type)( unsigned int,double ) const;
            
            ChastePoint3_exposer.def( 
                "GetWithDefault"
                , GetWithDefault_function_type( &::ChastePoint< 3 >::GetWithDefault )
                , ( bp::arg("i"), bp::arg("def")=0. ) );
        
        }
        { //::ChastePoint< 3 >::IsSamePoint
        
            typedef ChastePoint< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsSamePoint_function_type)( ::ChastePoint< 3 > const & ) const;
            
            ChastePoint3_exposer.def( 
                "IsSamePoint"
                , IsSamePoint_function_type( &::ChastePoint< 3 >::IsSamePoint )
                , ( bp::arg("rPoint") ) );
        
        }
        { //::ChastePoint< 3 >::SetCoordinate
        
            typedef ChastePoint< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetCoordinate_function_type)( unsigned int,double ) ;
            
            ChastePoint3_exposer.def( 
                "SetCoordinate"
                , SetCoordinate_function_type( &::ChastePoint< 3 >::SetCoordinate )
                , ( bp::arg("i"), bp::arg("value") ) );
        
        }
        { //::ChastePoint< 3 >::operator[]
        
            typedef ChastePoint< 3 > exported_class_t;
            typedef double ( exported_class_t::*__getitem___function_type)( unsigned int ) const;
            
            ChastePoint3_exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::ChastePoint< 3 >::operator[] )
                , ( bp::arg("i") ) );
        
        }
        { //::ChastePoint< 3 >::rGetLocation
        
            typedef ChastePoint< 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > const & ( exported_class_t::*rGetLocation_function_type)(  ) const;
            
            ChastePoint3_exposer.def( 
                "rGetLocation"
                , rGetLocation_function_type( &::ChastePoint< 3 >::rGetLocation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
    }

    bp::class_< TetrahedralMesh_less__2_comma__2__greater__wrapper, bp::bases< AbstractTetrahedralMesh< 2, 2 > >, boost::noncopyable >( "TetrahedralMesh2_2", bp::init< >() )    
        .def( 
            "CheckIsConforming"
            , (bool ( ::TetrahedralMesh<2, 2>::* )(  ))( &::TetrahedralMesh< 2, 2 >::CheckIsConforming ) )    
        .def( 
            "Clear"
            , (void ( ::TetrahedralMesh<2, 2>::* )(  ))(&::TetrahedralMesh< 2, 2 >::Clear)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_Clear) )    
        .def( 
            "ConstructFromMeshReader"
            , (void ( ::TetrahedralMesh<2, 2>::* )( ::AbstractMeshReader< 2, 2 > & ))(&::TetrahedralMesh< 2, 2 >::ConstructFromMeshReader)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::AbstractMeshReader< 2, 2 > & ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_ConstructFromMeshReader)
            , ( bp::arg("rMeshReader") ) )    
        .def( 
            "EdgesBegin"
            , (::TetrahedralMesh< 2, 2 >::EdgeIterator ( ::TetrahedralMesh<2, 2>::* )(  ))( &::TetrahedralMesh< 2, 2 >::EdgesBegin ) )    
        .def( 
            "EdgesEnd"
            , (::TetrahedralMesh< 2, 2 >::EdgeIterator ( ::TetrahedralMesh<2, 2>::* )(  ))( &::TetrahedralMesh< 2, 2 >::EdgesEnd ) )    
        .def( 
            "GetAngleBetweenNodes"
            , (double ( ::TetrahedralMesh<2, 2>::* )( unsigned int,unsigned int ))( &::TetrahedralMesh< 2, 2 >::GetAngleBetweenNodes )
            , ( bp::arg("indexA"), bp::arg("indexB") ) )    
        .def( 
            "GetContainingElementIndexWithInitialGuess"
            , (unsigned int ( ::TetrahedralMesh<2, 2>::* )( ::ChastePoint< 2 > const &,unsigned int,bool ))( &::TetrahedralMesh< 2, 2 >::GetContainingElementIndexWithInitialGuess )
            , ( bp::arg("rTestPoint"), bp::arg("startingElementGuess"), bp::arg("strict")=(bool)(false) ) )    
        .def( 
            "GetContainingElementIndices"
            , (::std::vector< unsigned int > ( ::TetrahedralMesh<2, 2>::* )( ::ChastePoint< 2 > const & ))( &::TetrahedralMesh< 2, 2 >::GetContainingElementIndices )
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetInverseJacobianForElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & )const)(&::TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetInverseJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) )    
        .def( 
            "GetJacobianForElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double & )const)(&::TetrahedralMesh< 2, 2 >::GetJacobianForElement)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double & )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetNearestElementIndex"
            , (unsigned int ( ::TetrahedralMesh<2, 2>::* )( ::ChastePoint< 2 > const & ))( &::TetrahedralMesh< 2, 2 >::GetNearestElementIndex )
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetSurfaceArea"
            , (double ( ::TetrahedralMesh<2, 2>::* )(  ))( &::TetrahedralMesh< 2, 2 >::GetSurfaceArea ) )    
        .def( 
            "GetVolume"
            , (double ( ::TetrahedralMesh<2, 2>::* )(  ))( &::TetrahedralMesh< 2, 2 >::GetVolume ) )    
        .def( 
            "GetWeightedDirectionForBoundaryElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetWeightedDirectionForElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetWeightedDirectionForElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<2, 2>::* )(  ))(&::TetrahedralMesh< 2, 2 >::PermuteNodes)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<2, 2>::* )( ::std::vector< unsigned int > const & ))( &::TetrahedralMesh< 2, 2 >::PermuteNodes )
            , ( bp::arg("perm") ) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::TetrahedralMesh<2, 2>::* )( ::std::string const & ))(&::TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::std::string const & ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshJacobianCachedData"
            , (void ( ::TetrahedralMesh<2, 2>::* )(  ))(&::TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_RefreshJacobianCachedData) )    
        .def( 
            "RefreshMesh"
            , (void ( ::TetrahedralMesh<2, 2>::* )(  ))(&::TetrahedralMesh< 2, 2 >::RefreshMesh)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "SolveBoundaryElementMapping"
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_SolveBoundaryElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveElementMapping"
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_SolveElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveNodeMapping"
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_SolveNodeMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<2> ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::std::vector<Node<2> *, std::allocator<Node<2> *> > const & )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 2 > ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
            , (::ChasteCuboid< 2 > ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "CalculateDesignatedOwnershipOfBoundaryElement"
            , (bool ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement)
            , (bool ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
            , ( bp::arg("faceIndex") ) )    
        .def( 
            "CalculateDesignatedOwnershipOfElement"
            , (bool ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement)
            , (bool ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
            , ( bp::arg("elementIndex") ) )    
        .def( 
            "CalculateMinMaxEdgeLengths"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractTetrahedralMesh<2, 2>::* )(  ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_CalculateMinMaxEdgeLengths) )    
        .def( 
            "ConstructCuboid"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,unsigned int,unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,unsigned int,unsigned int ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_ConstructCuboid)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) )    
        .def( 
            "ConstructLinearMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_ConstructLinearMesh)
            , ( bp::arg("width") ) )    
        .def( 
            "ConstructRectangularMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,unsigned int,bool ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int,unsigned int,bool ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_ConstructRectangularMesh)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) )    
        .def( 
            "GetHaloNodeIndices"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( ::std::vector< unsigned int > & )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::std::vector< unsigned int > & )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetHaloNodeIndices)
            , ( bp::arg("rHaloIndices") ) )    
        .def( 
            "GetMaximumNodeIndex"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  ))(&::AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetMaximumNodeIndex) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )( ::ChastePoint< 2 > const & ))(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::ChastePoint< 2 > const & ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumBoundaryElements)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumBoundaryElements) )    
        .def( 
            "GetNumCableElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumCableElements) )    
        .def( 
            "GetNumElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumElements)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumElements) )    
        .def( 
            "GetNumLocalBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumLocalBoundaryElements) )    
        .def( 
            "GetNumLocalElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumLocalElements) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::GetNumNodes)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetNumVertices"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumVertices)
            , (unsigned int ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetNumVertices) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWidth"
            , (double ( ::AbstractMesh<2, 2>::* )( unsigned int const & )const)(&::AbstractMesh< 2, 2 >::GetWidth)
            , (double ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( unsigned int const & )const)(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&::AbstractMesh< 2, 2 >::Rotate)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))(&::AbstractMesh< 2, 2 >::Scale)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( double const,double const,double const ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<2, 2>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::DistributedVectorFactory * ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )(  ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::Translate)
            , (void ( TetrahedralMesh_less__2_comma__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&TetrahedralMesh_less__2_comma__2__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))( &::AbstractMesh< 2, 2 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    { //::MutableMesh< 2, 2 >
        typedef bp::class_< MutableMesh_less__2_comma__2__greater__wrapper, bp::bases< TetrahedralMesh< 2, 2 > >, boost::noncopyable > MutableMesh2_2_exposer_t;
        MutableMesh2_2_exposer_t MutableMesh2_2_exposer = MutableMesh2_2_exposer_t( "MutableMesh2_2", bp::init< >() );
        bp::scope MutableMesh2_2_scope( MutableMesh2_2_exposer );
        MutableMesh2_2_exposer.def( bp::init< std::vector< Node<2> * > >(( bp::arg("nodes") )) );
        bp::implicitly_convertible< std::vector< Node<2> * >, MutableMesh< 2, 2 > >();
        { //::MutableMesh< 2, 2 >::AddElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddElement_function_type)( ::Element< 2, 2 > * ) ;
            
            MutableMesh2_2_exposer.def( 
                "AddElement"
                , AddElement_function_type( &::MutableMesh< 2, 2 >::AddElement )
                , ( bp::arg("pNewElement") ) );
        
        }
        { //::MutableMesh< 2, 2 >::AddNode
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddNode_function_type)( ::Node< 2 > * ) ;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_AddNode_function_type)( ::Node< 2 > * ) ;
            
            MutableMesh2_2_exposer.def( 
                "AddNode"
                , AddNode_function_type(&::MutableMesh< 2, 2 >::AddNode)
                , default_AddNode_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_AddNode)
                , ( bp::arg("pNewNode") ) );
        
        }
        { //::MutableMesh< 2, 2 >::CheckIsVoronoi
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef bool ( exported_class_t::*CheckIsVoronoi_function_type)( double ) ;
            
            MutableMesh2_2_exposer.def( 
                "CheckIsVoronoi"
                , CheckIsVoronoi_function_type( &::MutableMesh< 2, 2 >::CheckIsVoronoi )
                , ( bp::arg("maxPenetration")=0. ) );
        
        }
        { //::MutableMesh< 2, 2 >::Clear
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Clear_function_type)(  ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_Clear_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "Clear"
                , Clear_function_type(&::MutableMesh< 2, 2 >::Clear)
                , default_Clear_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_Clear) );
        
        }
        { //::MutableMesh< 2, 2 >::DeleteBoundaryNodeAt
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteBoundaryNodeAt_function_type)( unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "DeleteBoundaryNodeAt"
                , DeleteBoundaryNodeAt_function_type( &::MutableMesh< 2, 2 >::DeleteBoundaryNodeAt )
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 2, 2 >::DeleteElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteElement_function_type)( unsigned int ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_DeleteElement_function_type)( unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "DeleteElement"
                , DeleteElement_function_type(&::MutableMesh< 2, 2 >::DeleteElement)
                , default_DeleteElement_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_DeleteElement)
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 2, 2 >::DeleteNode
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteNode_function_type)( unsigned int ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_DeleteNode_function_type)( unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "DeleteNode"
                , DeleteNode_function_type(&::MutableMesh< 2, 2 >::DeleteNode)
                , default_DeleteNode_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_DeleteNode)
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 2, 2 >::DeleteNodePriorToReMesh
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteNodePriorToReMesh_function_type)( unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "DeleteNodePriorToReMesh"
                , DeleteNodePriorToReMesh_function_type( &::MutableMesh< 2, 2 >::DeleteNodePriorToReMesh )
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 2, 2 >::GetNumBoundaryElements
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumBoundaryElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumBoundaryElements_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumBoundaryElements"
                , GetNumBoundaryElements_function_type(&::MutableMesh< 2, 2 >::GetNumBoundaryElements)
                , default_GetNumBoundaryElements_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumBoundaryElements) );
        
        }
        { //::MutableMesh< 2, 2 >::GetNumElements
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumElements_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumElements"
                , GetNumElements_function_type(&::MutableMesh< 2, 2 >::GetNumElements)
                , default_GetNumElements_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumElements) );
        
        }
        { //::MutableMesh< 2, 2 >::GetNumNodes
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodes_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumNodes_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumNodes"
                , GetNumNodes_function_type(&::MutableMesh< 2, 2 >::GetNumNodes)
                , default_GetNumNodes_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumNodes) );
        
        }
        { //::MutableMesh< 2, 2 >::MoveMergeNode
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*MoveMergeNode_function_type)( unsigned int,unsigned int,bool ) ;
            
            MutableMesh2_2_exposer.def( 
                "MoveMergeNode"
                , MoveMergeNode_function_type( &::MutableMesh< 2, 2 >::MoveMergeNode )
                , ( bp::arg("index"), bp::arg("targetIndex"), bp::arg("concreteMove")=(bool)(true) ) );
        
        }
        { //::MutableMesh< 2, 2 >::ReIndex
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReIndex_function_type)( ::NodeMap & ) ;
            
            MutableMesh2_2_exposer.def( 
                "ReIndex"
                , ReIndex_function_type( &::MutableMesh< 2, 2 >::ReIndex )
                , ( bp::arg("map") ) );
        
        }
        { //::MutableMesh< 2, 2 >::ReMesh
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReMesh_function_type)( ::NodeMap & ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_ReMesh_function_type)( ::NodeMap & ) ;
            
            MutableMesh2_2_exposer.def( 
                "ReMesh"
                , ReMesh_function_type(&::MutableMesh< 2, 2 >::ReMesh)
                , default_ReMesh_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_ReMesh)
                , ( bp::arg("map") ) );
        
        }
        { //::MutableMesh< 2, 2 >::ReMesh
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReMesh_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "ReMesh"
                , ReMesh_function_type( &::MutableMesh< 2, 2 >::ReMesh ) );
        
        }
        { //::MutableMesh< 2, 2 >::RefineElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*RefineElement_function_type)( ::Element< 2, 2 > *,::ChastePoint< 2 > ) ;
            
            MutableMesh2_2_exposer.def( 
                "RefineElement"
                , RefineElement_function_type( &::MutableMesh< 2, 2 >::RefineElement )
                , ( bp::arg("pElement"), bp::arg("point") ) );
        
        }
        { //::MutableMesh< 2, 2 >::SetNode
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNode_function_type)( unsigned int,::ChastePoint< 2 >,bool ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_SetNode_function_type)( unsigned int,::ChastePoint< 2 >,bool ) ;
            
            MutableMesh2_2_exposer.def( 
                "SetNode"
                , SetNode_function_type(&::MutableMesh< 2, 2 >::SetNode)
                , default_SetNode_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_SetNode)
                , ( bp::arg("index"), bp::arg("point"), bp::arg("concreteMove")=(bool)(true) ) );
        
        }
        { //::MutableMesh< 2, 2 >::SplitEdge
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< unsigned int, 3 > ( exported_class_t::*SplitEdge_function_type)( ::Node< 2 > *,::Node< 2 > * ) ;
            
            MutableMesh2_2_exposer.def( 
                "SplitEdge"
                , SplitEdge_function_type( &::MutableMesh< 2, 2 >::SplitEdge )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) );
        
        }
        { //::MutableMesh< 2, 2 >::SplitLongEdges
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<unsigned int, 5> > ( exported_class_t::*SplitLongEdges_function_type)( double ) ;
            
            MutableMesh2_2_exposer.def( 
                "SplitLongEdges"
                , SplitLongEdges_function_type( &::MutableMesh< 2, 2 >::SplitLongEdges )
                , ( bp::arg("cutoffLength") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( MutableMesh_less__2_comma__2__greater__wrapper::*CalculateBoundingBox_function_type)( ::std::vector< Node<2> * > const & ) const;
            
            MutableMesh2_2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type( &MutableMesh_less__2_comma__2__greater__wrapper::CalculateBoundingBox )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( exported_class_t::*CalculateBoundingBox_function_type)(  ) const;
            typedef ::ChasteCuboid< 2 > ( MutableMesh_less__2_comma__2__greater__wrapper::*default_CalculateBoundingBox_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
                , default_CalculateBoundingBox_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_CalculateBoundingBox) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef bool ( exported_class_t::*CalculateDesignatedOwnershipOfBoundaryElement_function_type)( unsigned int ) ;
            typedef bool ( MutableMesh_less__2_comma__2__greater__wrapper::*default_CalculateDesignatedOwnershipOfBoundaryElement_function_type)( unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "CalculateDesignatedOwnershipOfBoundaryElement"
                , CalculateDesignatedOwnershipOfBoundaryElement_function_type(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement)
                , default_CalculateDesignatedOwnershipOfBoundaryElement_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
                , ( bp::arg("faceIndex") ) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef bool ( exported_class_t::*CalculateDesignatedOwnershipOfElement_function_type)( unsigned int ) ;
            typedef bool ( MutableMesh_less__2_comma__2__greater__wrapper::*default_CalculateDesignatedOwnershipOfElement_function_type)( unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "CalculateDesignatedOwnershipOfElement"
                , CalculateDesignatedOwnershipOfElement_function_type(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement)
                , default_CalculateDesignatedOwnershipOfElement_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*CalculateMinMaxEdgeLengths_function_type)(  ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( MutableMesh_less__2_comma__2__greater__wrapper::*default_CalculateMinMaxEdgeLengths_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "CalculateMinMaxEdgeLengths"
                , CalculateMinMaxEdgeLengths_function_type(&::AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths)
                , default_CalculateMinMaxEdgeLengths_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_CalculateMinMaxEdgeLengths) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ConstructCuboid_function_type)( unsigned int,unsigned int,unsigned int ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_ConstructCuboid_function_type)( unsigned int,unsigned int,unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "ConstructCuboid"
                , ConstructCuboid_function_type(&::AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid)
                , default_ConstructCuboid_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_ConstructCuboid)
                , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::ConstructFromMeshReader
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 2, 2 > & ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 2, 2 > & ) ;
            
            MutableMesh2_2_exposer.def( 
                "ConstructFromMeshReader"
                , ConstructFromMeshReader_function_type(&::TetrahedralMesh< 2, 2 >::ConstructFromMeshReader)
                , default_ConstructFromMeshReader_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_ConstructFromMeshReader)
                , ( bp::arg("rMeshReader") ) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ConstructLinearMesh_function_type)( unsigned int ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_ConstructLinearMesh_function_type)( unsigned int ) ;
            
            MutableMesh2_2_exposer.def( 
                "ConstructLinearMesh"
                , ConstructLinearMesh_function_type(&::AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh)
                , default_ConstructLinearMesh_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_ConstructLinearMesh)
                , ( bp::arg("width") ) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ConstructRectangularMesh_function_type)( unsigned int,unsigned int,bool ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_ConstructRectangularMesh_function_type)( unsigned int,unsigned int,bool ) ;
            
            MutableMesh2_2_exposer.def( 
                "ConstructRectangularMesh"
                , ConstructRectangularMesh_function_type(&::AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh)
                , default_ConstructRectangularMesh_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_ConstructRectangularMesh)
                , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*GetHaloNodeIndices_function_type)( ::std::vector< unsigned int > & ) const;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetHaloNodeIndices_function_type)( ::std::vector< unsigned int > & ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetHaloNodeIndices"
                , GetHaloNodeIndices_function_type(&::AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices)
                , default_GetHaloNodeIndices_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetHaloNodeIndices)
                , ( bp::arg("rHaloIndices") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*GetInverseJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & ) const;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetInverseJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetInverseJacobianForElement"
                , GetInverseJacobianForElement_function_type(&::TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement)
                , default_GetInverseJacobianForElement_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetInverseJacobianForElement)
                , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::GetJacobianForElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*GetJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double & ) const;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double & ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetJacobianForElement"
                , GetJacobianForElement_function_type(&::TetrahedralMesh< 2, 2 >::GetJacobianForElement)
                , default_GetJacobianForElement_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetJacobianForElement)
                , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant") ) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetMaximumNodeIndex_function_type)(  ) ;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetMaximumNodeIndex_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "GetMaximumNodeIndex"
                , GetMaximumNodeIndex_function_type(&::AbstractTetrahedralMesh< 2, 2 >::GetMaximumNodeIndex)
                , default_GetMaximumNodeIndex_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetMaximumNodeIndex) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNearestNodeIndex
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            
            MutableMesh2_2_exposer.def( 
                "GetNearestNodeIndex"
                , GetNearestNodeIndex_function_type(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
                , default_GetNearestNodeIndex_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNearestNodeIndex)
                , ( bp::arg("rTestPoint") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNumAllNodes
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllNodes_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumAllNodes_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumAllNodes"
                , GetNumAllNodes_function_type(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
                , default_GetNumAllNodes_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumAllNodes) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumCableElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumCableElements_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumCableElements"
                , GetNumCableElements_function_type(&::AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements)
                , default_GetNumCableElements_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumCableElements) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumLocalBoundaryElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumLocalBoundaryElements_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumLocalBoundaryElements"
                , GetNumLocalBoundaryElements_function_type(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements)
                , default_GetNumLocalBoundaryElements_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumLocalBoundaryElements) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumLocalElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumLocalElements_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumLocalElements"
                , GetNumLocalElements_function_type(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements)
                , default_GetNumLocalElements_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumLocalElements) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::GetNumVertices
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumVertices_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetNumVertices_function_type)(  ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetNumVertices"
                , GetNumVertices_function_type(&::AbstractTetrahedralMesh< 2, 2 >::GetNumVertices)
                , default_GetNumVertices_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetNumVertices) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetVectorFromAtoB
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            MutableMesh2_2_exposer.def( 
                "GetVectorFromAtoB"
                , GetVectorFromAtoB_function_type(&::AbstractMesh< 2, 2 >::GetVectorFromAtoB)
                , default_GetVectorFromAtoB_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetVectorFromAtoB)
                , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*GetWeightedDirectionForBoundaryElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & ) const;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetWeightedDirectionForBoundaryElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetWeightedDirectionForBoundaryElement"
                , GetWeightedDirectionForBoundaryElement_function_type(&::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement)
                , default_GetWeightedDirectionForBoundaryElement_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
                , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*GetWeightedDirectionForElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & ) const;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetWeightedDirectionForElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetWeightedDirectionForElement"
                , GetWeightedDirectionForElement_function_type(&::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement)
                , default_GetWeightedDirectionForElement_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetWeightedDirectionForElement)
                , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetWidth
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetWidth_function_type)( unsigned int const & ) const;
            typedef double ( MutableMesh_less__2_comma__2__greater__wrapper::*default_GetWidth_function_type)( unsigned int const & ) const;
            
            MutableMesh2_2_exposer.def( 
                "GetWidth"
                , GetWidth_function_type(&::AbstractMesh< 2, 2 >::GetWidth)
                , default_GetWidth_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_GetWidth)
                , ( bp::arg("rDimension") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::PermuteNodes
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)(  ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_PermuteNodes_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type(&::TetrahedralMesh< 2, 2 >::PermuteNodes)
                , default_PermuteNodes_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_PermuteNodes) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::PermuteNodes
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)( ::std::vector< unsigned int > const & ) ;
            
            MutableMesh2_2_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type( &::TetrahedralMesh< 2, 2 >::PermuteNodes )
                , ( bp::arg("perm") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            
            MutableMesh2_2_exposer.def( 
                "ReadNodesPerProcessorFile"
                , ReadNodesPerProcessorFile_function_type(&::TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile)
                , default_ReadNodesPerProcessorFile_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_ReadNodesPerProcessorFile)
                , ( bp::arg("rNodesPerProcessorFile") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*RefreshJacobianCachedData_function_type)(  ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_RefreshJacobianCachedData_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "RefreshJacobianCachedData"
                , RefreshJacobianCachedData_function_type(&::TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData)
                , default_RefreshJacobianCachedData_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_RefreshJacobianCachedData) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::RefreshMesh
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*RefreshMesh_function_type)(  ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_RefreshMesh_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "RefreshMesh"
                , RefreshMesh_function_type(&::TetrahedralMesh< 2, 2 >::RefreshMesh)
                , default_RefreshMesh_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_RefreshMesh) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            
            MutableMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type(&::AbstractMesh< 2, 2 >::Rotate)
                , default_Rotate_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_Rotate)
                , ( bp::arg("rotationMatrix") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            MutableMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("axis"), bp::arg("angle") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( double ) ;
            
            MutableMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("theta") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Scale
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Scale_function_type)( double const,double const,double const ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_Scale_function_type)( double const,double const,double const ) ;
            
            MutableMesh2_2_exposer.def( 
                "Scale"
                , Scale_function_type(&::AbstractMesh< 2, 2 >::Scale)
                , default_Scale_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_Scale)
                , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) );
        
        }
        { //::AbstractMesh< 2, 2 >::SetDistributedVectorFactory
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            
            MutableMesh2_2_exposer.def( 
                "SetDistributedVectorFactory"
                , SetDistributedVectorFactory_function_type(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
                , default_SetDistributedVectorFactory_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_SetDistributedVectorFactory)
                , ( bp::arg("pFactory") ) );
        
        }
        { //::AbstractTetrahedralMesh< 2, 2 >::SetElementOwnerships
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*SetElementOwnerships_function_type)(  ) ;
            
            MutableMesh2_2_exposer.def( 
                "SetElementOwnerships"
                , SetElementOwnerships_function_type( &MutableMesh_less__2_comma__2__greater__wrapper::default_SetElementOwnerships ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::SolveBoundaryElementMapping
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*SolveBoundaryElementMapping_function_type)( unsigned int ) const;
            
            MutableMesh2_2_exposer.def( 
                "SolveBoundaryElementMapping"
                , SolveBoundaryElementMapping_function_type( &MutableMesh_less__2_comma__2__greater__wrapper::default_SolveBoundaryElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::SolveElementMapping
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*SolveElementMapping_function_type)( unsigned int ) const;
            
            MutableMesh2_2_exposer.def( 
                "SolveElementMapping"
                , SolveElementMapping_function_type( &MutableMesh_less__2_comma__2__greater__wrapper::default_SolveElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::TetrahedralMesh< 2, 2 >::SolveNodeMapping
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableMesh_less__2_comma__2__greater__wrapper::*SolveNodeMapping_function_type)( unsigned int ) const;
            
            MutableMesh2_2_exposer.def( 
                "SolveNodeMapping"
                , SolveNodeMapping_function_type( &MutableMesh_less__2_comma__2__greater__wrapper::default_SolveNodeMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef void ( MutableMesh_less__2_comma__2__greater__wrapper::*default_Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            MutableMesh2_2_exposer.def( 
                "Translate"
                , Translate_function_type(&::AbstractMesh< 2, 2 >::Translate)
                , default_Translate_function_type(&MutableMesh_less__2_comma__2__greater__wrapper::default_Translate)
                , ( bp::arg("rDisplacement") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef MutableMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( double const,double const,double const ) ;
            
            MutableMesh2_2_exposer.def( 
                "Translate"
                , Translate_function_type( &::AbstractMesh< 2, 2 >::Translate )
                , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< MutableMesh<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< MutableMesh< 2, 2 > >, boost::shared_ptr< TetrahedralMesh< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< MutableMesh< 2, 2 > >, boost::shared_ptr< AbstractTetrahedralMesh< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< MutableMesh< 2, 2 > >, boost::shared_ptr< AbstractMesh< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< NodesOnlyMesh< 2 > >, boost::shared_ptr< MutableMesh< 2, 2 > > >();
    }

    bp::class_< TetrahedralMesh_less__3_comma__3__greater__wrapper, bp::bases< AbstractTetrahedralMesh< 3, 3 > >, boost::noncopyable >( "TetrahedralMesh3_3", bp::init< >() )    
        .def( 
            "CheckIsConforming"
            , (bool ( ::TetrahedralMesh<3, 3>::* )(  ))( &::TetrahedralMesh< 3, 3 >::CheckIsConforming ) )    
        .def( 
            "Clear"
            , (void ( ::TetrahedralMesh<3, 3>::* )(  ))(&::TetrahedralMesh< 3, 3 >::Clear)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_Clear) )    
        .def( 
            "ConstructFromMeshReader"
            , (void ( ::TetrahedralMesh<3, 3>::* )( ::AbstractMeshReader< 3, 3 > & ))(&::TetrahedralMesh< 3, 3 >::ConstructFromMeshReader)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::AbstractMeshReader< 3, 3 > & ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_ConstructFromMeshReader)
            , ( bp::arg("rMeshReader") ) )    
        .def( 
            "EdgesBegin"
            , (::TetrahedralMesh< 3, 3 >::EdgeIterator ( ::TetrahedralMesh<3, 3>::* )(  ))( &::TetrahedralMesh< 3, 3 >::EdgesBegin ) )    
        .def( 
            "EdgesEnd"
            , (::TetrahedralMesh< 3, 3 >::EdgeIterator ( ::TetrahedralMesh<3, 3>::* )(  ))( &::TetrahedralMesh< 3, 3 >::EdgesEnd ) )    
        .def( 
            "GetAngleBetweenNodes"
            , (double ( ::TetrahedralMesh<3, 3>::* )( unsigned int,unsigned int ))( &::TetrahedralMesh< 3, 3 >::GetAngleBetweenNodes )
            , ( bp::arg("indexA"), bp::arg("indexB") ) )    
        .def( 
            "GetContainingElementIndexWithInitialGuess"
            , (unsigned int ( ::TetrahedralMesh<3, 3>::* )( ::ChastePoint< 3 > const &,unsigned int,bool ))( &::TetrahedralMesh< 3, 3 >::GetContainingElementIndexWithInitialGuess )
            , ( bp::arg("rTestPoint"), bp::arg("startingElementGuess"), bp::arg("strict")=(bool)(false) ) )    
        .def( 
            "GetContainingElementIndices"
            , (::std::vector< unsigned int > ( ::TetrahedralMesh<3, 3>::* )( ::ChastePoint< 3 > const & ))( &::TetrahedralMesh< 3, 3 >::GetContainingElementIndices )
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetInverseJacobianForElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & )const)(&::TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetInverseJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) )    
        .def( 
            "GetJacobianForElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double & )const)(&::TetrahedralMesh< 3, 3 >::GetJacobianForElement)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double & )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetNearestElementIndex"
            , (unsigned int ( ::TetrahedralMesh<3, 3>::* )( ::ChastePoint< 3 > const & ))( &::TetrahedralMesh< 3, 3 >::GetNearestElementIndex )
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetSurfaceArea"
            , (double ( ::TetrahedralMesh<3, 3>::* )(  ))( &::TetrahedralMesh< 3, 3 >::GetSurfaceArea ) )    
        .def( 
            "GetVolume"
            , (double ( ::TetrahedralMesh<3, 3>::* )(  ))( &::TetrahedralMesh< 3, 3 >::GetVolume ) )    
        .def( 
            "GetWeightedDirectionForBoundaryElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetWeightedDirectionForElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetWeightedDirectionForElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<3, 3>::* )(  ))(&::TetrahedralMesh< 3, 3 >::PermuteNodes)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<3, 3>::* )( ::std::vector< unsigned int > const & ))( &::TetrahedralMesh< 3, 3 >::PermuteNodes )
            , ( bp::arg("perm") ) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::TetrahedralMesh<3, 3>::* )( ::std::string const & ))(&::TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::std::string const & ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshJacobianCachedData"
            , (void ( ::TetrahedralMesh<3, 3>::* )(  ))(&::TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_RefreshJacobianCachedData) )    
        .def( 
            "RefreshMesh"
            , (void ( ::TetrahedralMesh<3, 3>::* )(  ))(&::TetrahedralMesh< 3, 3 >::RefreshMesh)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "SolveBoundaryElementMapping"
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_SolveBoundaryElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveElementMapping"
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_SolveElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveNodeMapping"
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_SolveNodeMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<3> ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::std::vector<Node<3> *, std::allocator<Node<3> *> > const & )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 3 > ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
            , (::ChasteCuboid< 3 > ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "CalculateDesignatedOwnershipOfBoundaryElement"
            , (bool ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement)
            , (bool ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
            , ( bp::arg("faceIndex") ) )    
        .def( 
            "CalculateDesignatedOwnershipOfElement"
            , (bool ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement)
            , (bool ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
            , ( bp::arg("elementIndex") ) )    
        .def( 
            "CalculateMinMaxEdgeLengths"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractTetrahedralMesh<3, 3>::* )(  ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_CalculateMinMaxEdgeLengths) )    
        .def( 
            "ConstructCuboid"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,unsigned int,unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,unsigned int,unsigned int ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_ConstructCuboid)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) )    
        .def( 
            "ConstructLinearMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_ConstructLinearMesh)
            , ( bp::arg("width") ) )    
        .def( 
            "ConstructRectangularMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,unsigned int,bool ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,unsigned int,bool ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_ConstructRectangularMesh)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) )    
        .def( 
            "GetHaloNodeIndices"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( ::std::vector< unsigned int > & )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::std::vector< unsigned int > & )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetHaloNodeIndices)
            , ( bp::arg("rHaloIndices") ) )    
        .def( 
            "GetMaximumNodeIndex"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  ))(&::AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetMaximumNodeIndex) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )( ::ChastePoint< 3 > const & ))(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::ChastePoint< 3 > const & ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumBoundaryElements)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumBoundaryElements) )    
        .def( 
            "GetNumCableElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumCableElements) )    
        .def( 
            "GetNumElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumElements)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumElements) )    
        .def( 
            "GetNumLocalBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumLocalBoundaryElements) )    
        .def( 
            "GetNumLocalElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumLocalElements) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumNodes)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetNumVertices"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumVertices)
            , (unsigned int ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetNumVertices) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 3 > ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWidth"
            , (double ( ::AbstractMesh<3, 3>::* )( unsigned int const & )const)(&::AbstractMesh< 3, 3 >::GetWidth)
            , (double ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( unsigned int const & )const)(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&::AbstractMesh< 3, 3 >::Rotate)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))(&::AbstractMesh< 3, 3 >::Scale)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( double const,double const,double const ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<3, 3>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::DistributedVectorFactory * ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )(  ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::Translate)
            , (void ( TetrahedralMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&TetrahedralMesh_less__3_comma__3__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))( &::AbstractMesh< 3, 3 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    { //::MutableMesh< 3, 3 >
        typedef bp::class_< MutableMesh_less__3_comma__3__greater__wrapper, bp::bases< TetrahedralMesh< 3, 3 > >, boost::noncopyable > MutableMesh3_3_exposer_t;
        MutableMesh3_3_exposer_t MutableMesh3_3_exposer = MutableMesh3_3_exposer_t( "MutableMesh3_3", bp::init< >() );
        bp::scope MutableMesh3_3_scope( MutableMesh3_3_exposer );
        MutableMesh3_3_exposer.def( bp::init< std::vector< Node<3> * > >(( bp::arg("nodes") )) );
        bp::implicitly_convertible< std::vector< Node<3> * >, MutableMesh< 3, 3 > >();
        { //::MutableMesh< 3, 3 >::AddElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddElement_function_type)( ::Element< 3, 3 > * ) ;
            
            MutableMesh3_3_exposer.def( 
                "AddElement"
                , AddElement_function_type( &::MutableMesh< 3, 3 >::AddElement )
                , ( bp::arg("pNewElement") ) );
        
        }
        { //::MutableMesh< 3, 3 >::AddNode
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddNode_function_type)( ::Node< 3 > * ) ;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_AddNode_function_type)( ::Node< 3 > * ) ;
            
            MutableMesh3_3_exposer.def( 
                "AddNode"
                , AddNode_function_type(&::MutableMesh< 3, 3 >::AddNode)
                , default_AddNode_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_AddNode)
                , ( bp::arg("pNewNode") ) );
        
        }
        { //::MutableMesh< 3, 3 >::CheckIsVoronoi
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef bool ( exported_class_t::*CheckIsVoronoi_function_type)( double ) ;
            
            MutableMesh3_3_exposer.def( 
                "CheckIsVoronoi"
                , CheckIsVoronoi_function_type( &::MutableMesh< 3, 3 >::CheckIsVoronoi )
                , ( bp::arg("maxPenetration")=0. ) );
        
        }
        { //::MutableMesh< 3, 3 >::Clear
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Clear_function_type)(  ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_Clear_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "Clear"
                , Clear_function_type(&::MutableMesh< 3, 3 >::Clear)
                , default_Clear_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_Clear) );
        
        }
        { //::MutableMesh< 3, 3 >::DeleteBoundaryNodeAt
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*DeleteBoundaryNodeAt_function_type)( unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "DeleteBoundaryNodeAt"
                , DeleteBoundaryNodeAt_function_type( &::MutableMesh< 3, 3 >::DeleteBoundaryNodeAt )
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 3, 3 >::DeleteElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*DeleteElement_function_type)( unsigned int ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_DeleteElement_function_type)( unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "DeleteElement"
                , DeleteElement_function_type(&::MutableMesh< 3, 3 >::DeleteElement)
                , default_DeleteElement_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_DeleteElement)
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 3, 3 >::DeleteNode
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*DeleteNode_function_type)( unsigned int ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_DeleteNode_function_type)( unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "DeleteNode"
                , DeleteNode_function_type(&::MutableMesh< 3, 3 >::DeleteNode)
                , default_DeleteNode_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_DeleteNode)
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 3, 3 >::DeleteNodePriorToReMesh
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*DeleteNodePriorToReMesh_function_type)( unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "DeleteNodePriorToReMesh"
                , DeleteNodePriorToReMesh_function_type( &::MutableMesh< 3, 3 >::DeleteNodePriorToReMesh )
                , ( bp::arg("index") ) );
        
        }
        { //::MutableMesh< 3, 3 >::GetNumBoundaryElements
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumBoundaryElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumBoundaryElements_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumBoundaryElements"
                , GetNumBoundaryElements_function_type(&::MutableMesh< 3, 3 >::GetNumBoundaryElements)
                , default_GetNumBoundaryElements_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumBoundaryElements) );
        
        }
        { //::MutableMesh< 3, 3 >::GetNumElements
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumElements_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumElements"
                , GetNumElements_function_type(&::MutableMesh< 3, 3 >::GetNumElements)
                , default_GetNumElements_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumElements) );
        
        }
        { //::MutableMesh< 3, 3 >::GetNumNodes
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodes_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumNodes_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumNodes"
                , GetNumNodes_function_type(&::MutableMesh< 3, 3 >::GetNumNodes)
                , default_GetNumNodes_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumNodes) );
        
        }
        { //::MutableMesh< 3, 3 >::MoveMergeNode
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*MoveMergeNode_function_type)( unsigned int,unsigned int,bool ) ;
            
            MutableMesh3_3_exposer.def( 
                "MoveMergeNode"
                , MoveMergeNode_function_type( &::MutableMesh< 3, 3 >::MoveMergeNode )
                , ( bp::arg("index"), bp::arg("targetIndex"), bp::arg("concreteMove")=(bool)(true) ) );
        
        }
        { //::MutableMesh< 3, 3 >::ReIndex
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ReIndex_function_type)( ::NodeMap & ) ;
            
            MutableMesh3_3_exposer.def( 
                "ReIndex"
                , ReIndex_function_type( &::MutableMesh< 3, 3 >::ReIndex )
                , ( bp::arg("map") ) );
        
        }
        { //::MutableMesh< 3, 3 >::ReMesh
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ReMesh_function_type)( ::NodeMap & ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_ReMesh_function_type)( ::NodeMap & ) ;
            
            MutableMesh3_3_exposer.def( 
                "ReMesh"
                , ReMesh_function_type(&::MutableMesh< 3, 3 >::ReMesh)
                , default_ReMesh_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_ReMesh)
                , ( bp::arg("map") ) );
        
        }
        { //::MutableMesh< 3, 3 >::ReMesh
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ReMesh_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "ReMesh"
                , ReMesh_function_type( &::MutableMesh< 3, 3 >::ReMesh ) );
        
        }
        { //::MutableMesh< 3, 3 >::RefineElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*RefineElement_function_type)( ::Element< 3, 3 > *,::ChastePoint< 3 > ) ;
            
            MutableMesh3_3_exposer.def( 
                "RefineElement"
                , RefineElement_function_type( &::MutableMesh< 3, 3 >::RefineElement )
                , ( bp::arg("pElement"), bp::arg("point") ) );
        
        }
        { //::MutableMesh< 3, 3 >::SetNode
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNode_function_type)( unsigned int,::ChastePoint< 3 >,bool ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_SetNode_function_type)( unsigned int,::ChastePoint< 3 >,bool ) ;
            
            MutableMesh3_3_exposer.def( 
                "SetNode"
                , SetNode_function_type(&::MutableMesh< 3, 3 >::SetNode)
                , default_SetNode_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_SetNode)
                , ( bp::arg("index"), bp::arg("point"), bp::arg("concreteMove")=(bool)(true) ) );
        
        }
        { //::MutableMesh< 3, 3 >::SplitEdge
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< unsigned int, 3 > ( exported_class_t::*SplitEdge_function_type)( ::Node< 3 > *,::Node< 3 > * ) ;
            
            MutableMesh3_3_exposer.def( 
                "SplitEdge"
                , SplitEdge_function_type( &::MutableMesh< 3, 3 >::SplitEdge )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) );
        
        }
        { //::MutableMesh< 3, 3 >::SplitLongEdges
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<unsigned int, 5> > ( exported_class_t::*SplitLongEdges_function_type)( double ) ;
            
            MutableMesh3_3_exposer.def( 
                "SplitLongEdges"
                , SplitLongEdges_function_type( &::MutableMesh< 3, 3 >::SplitLongEdges )
                , ( bp::arg("cutoffLength") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::CalculateBoundingBox
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef ::ChasteCuboid< 3 > ( MutableMesh_less__3_comma__3__greater__wrapper::*CalculateBoundingBox_function_type)( ::std::vector< Node<3> * > const & ) const;
            
            MutableMesh3_3_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type( &MutableMesh_less__3_comma__3__greater__wrapper::CalculateBoundingBox )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::CalculateBoundingBox
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef ::ChasteCuboid< 3 > ( exported_class_t::*CalculateBoundingBox_function_type)(  ) const;
            typedef ::ChasteCuboid< 3 > ( MutableMesh_less__3_comma__3__greater__wrapper::*default_CalculateBoundingBox_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
                , default_CalculateBoundingBox_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_CalculateBoundingBox) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef bool ( exported_class_t::*CalculateDesignatedOwnershipOfBoundaryElement_function_type)( unsigned int ) ;
            typedef bool ( MutableMesh_less__3_comma__3__greater__wrapper::*default_CalculateDesignatedOwnershipOfBoundaryElement_function_type)( unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "CalculateDesignatedOwnershipOfBoundaryElement"
                , CalculateDesignatedOwnershipOfBoundaryElement_function_type(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement)
                , default_CalculateDesignatedOwnershipOfBoundaryElement_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
                , ( bp::arg("faceIndex") ) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef bool ( exported_class_t::*CalculateDesignatedOwnershipOfElement_function_type)( unsigned int ) ;
            typedef bool ( MutableMesh_less__3_comma__3__greater__wrapper::*default_CalculateDesignatedOwnershipOfElement_function_type)( unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "CalculateDesignatedOwnershipOfElement"
                , CalculateDesignatedOwnershipOfElement_function_type(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement)
                , default_CalculateDesignatedOwnershipOfElement_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*CalculateMinMaxEdgeLengths_function_type)(  ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( MutableMesh_less__3_comma__3__greater__wrapper::*default_CalculateMinMaxEdgeLengths_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "CalculateMinMaxEdgeLengths"
                , CalculateMinMaxEdgeLengths_function_type(&::AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths)
                , default_CalculateMinMaxEdgeLengths_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_CalculateMinMaxEdgeLengths) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ConstructCuboid_function_type)( unsigned int,unsigned int,unsigned int ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_ConstructCuboid_function_type)( unsigned int,unsigned int,unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "ConstructCuboid"
                , ConstructCuboid_function_type(&::AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid)
                , default_ConstructCuboid_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_ConstructCuboid)
                , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::ConstructFromMeshReader
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 3, 3 > & ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 3, 3 > & ) ;
            
            MutableMesh3_3_exposer.def( 
                "ConstructFromMeshReader"
                , ConstructFromMeshReader_function_type(&::TetrahedralMesh< 3, 3 >::ConstructFromMeshReader)
                , default_ConstructFromMeshReader_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_ConstructFromMeshReader)
                , ( bp::arg("rMeshReader") ) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ConstructLinearMesh_function_type)( unsigned int ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_ConstructLinearMesh_function_type)( unsigned int ) ;
            
            MutableMesh3_3_exposer.def( 
                "ConstructLinearMesh"
                , ConstructLinearMesh_function_type(&::AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh)
                , default_ConstructLinearMesh_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_ConstructLinearMesh)
                , ( bp::arg("width") ) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ConstructRectangularMesh_function_type)( unsigned int,unsigned int,bool ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_ConstructRectangularMesh_function_type)( unsigned int,unsigned int,bool ) ;
            
            MutableMesh3_3_exposer.def( 
                "ConstructRectangularMesh"
                , ConstructRectangularMesh_function_type(&::AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh)
                , default_ConstructRectangularMesh_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_ConstructRectangularMesh)
                , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*GetHaloNodeIndices_function_type)( ::std::vector< unsigned int > & ) const;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetHaloNodeIndices_function_type)( ::std::vector< unsigned int > & ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetHaloNodeIndices"
                , GetHaloNodeIndices_function_type(&::AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices)
                , default_GetHaloNodeIndices_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetHaloNodeIndices)
                , ( bp::arg("rHaloIndices") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*GetInverseJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & ) const;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetInverseJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetInverseJacobianForElement"
                , GetInverseJacobianForElement_function_type(&::TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement)
                , default_GetInverseJacobianForElement_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetInverseJacobianForElement)
                , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::GetJacobianForElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*GetJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double & ) const;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetJacobianForElement_function_type)( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double & ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetJacobianForElement"
                , GetJacobianForElement_function_type(&::TetrahedralMesh< 3, 3 >::GetJacobianForElement)
                , default_GetJacobianForElement_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetJacobianForElement)
                , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant") ) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetMaximumNodeIndex_function_type)(  ) ;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetMaximumNodeIndex_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "GetMaximumNodeIndex"
                , GetMaximumNodeIndex_function_type(&::AbstractTetrahedralMesh< 3, 3 >::GetMaximumNodeIndex)
                , default_GetMaximumNodeIndex_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetMaximumNodeIndex) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetNearestNodeIndex
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNearestNodeIndex_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNearestNodeIndex_function_type)( ::ChastePoint< 3 > const & ) ;
            
            MutableMesh3_3_exposer.def( 
                "GetNearestNodeIndex"
                , GetNearestNodeIndex_function_type(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
                , default_GetNearestNodeIndex_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNearestNodeIndex)
                , ( bp::arg("rTestPoint") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetNumAllNodes
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllNodes_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumAllNodes_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumAllNodes"
                , GetNumAllNodes_function_type(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
                , default_GetNumAllNodes_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumAllNodes) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumCableElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumCableElements_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumCableElements"
                , GetNumCableElements_function_type(&::AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements)
                , default_GetNumCableElements_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumCableElements) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumLocalBoundaryElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumLocalBoundaryElements_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumLocalBoundaryElements"
                , GetNumLocalBoundaryElements_function_type(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements)
                , default_GetNumLocalBoundaryElements_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumLocalBoundaryElements) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumLocalElements_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumLocalElements_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumLocalElements"
                , GetNumLocalElements_function_type(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements)
                , default_GetNumLocalElements_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumLocalElements) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::GetNumVertices
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumVertices_function_type)(  ) const;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetNumVertices_function_type)(  ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetNumVertices"
                , GetNumVertices_function_type(&::AbstractTetrahedralMesh< 3, 3 >::GetNumVertices)
                , default_GetNumVertices_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetNumVertices) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetVectorFromAtoB
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            
            MutableMesh3_3_exposer.def( 
                "GetVectorFromAtoB"
                , GetVectorFromAtoB_function_type(&::AbstractMesh< 3, 3 >::GetVectorFromAtoB)
                , default_GetVectorFromAtoB_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetVectorFromAtoB)
                , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*GetWeightedDirectionForBoundaryElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & ) const;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetWeightedDirectionForBoundaryElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetWeightedDirectionForBoundaryElement"
                , GetWeightedDirectionForBoundaryElement_function_type(&::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement)
                , default_GetWeightedDirectionForBoundaryElement_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
                , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*GetWeightedDirectionForElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & ) const;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetWeightedDirectionForElement_function_type)( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetWeightedDirectionForElement"
                , GetWeightedDirectionForElement_function_type(&::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement)
                , default_GetWeightedDirectionForElement_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetWeightedDirectionForElement)
                , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetWidth
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*GetWidth_function_type)( unsigned int const & ) const;
            typedef double ( MutableMesh_less__3_comma__3__greater__wrapper::*default_GetWidth_function_type)( unsigned int const & ) const;
            
            MutableMesh3_3_exposer.def( 
                "GetWidth"
                , GetWidth_function_type(&::AbstractMesh< 3, 3 >::GetWidth)
                , default_GetWidth_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_GetWidth)
                , ( bp::arg("rDimension") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::PermuteNodes
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)(  ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_PermuteNodes_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type(&::TetrahedralMesh< 3, 3 >::PermuteNodes)
                , default_PermuteNodes_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_PermuteNodes) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::PermuteNodes
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)( ::std::vector< unsigned int > const & ) ;
            
            MutableMesh3_3_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type( &::TetrahedralMesh< 3, 3 >::PermuteNodes )
                , ( bp::arg("perm") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            
            MutableMesh3_3_exposer.def( 
                "ReadNodesPerProcessorFile"
                , ReadNodesPerProcessorFile_function_type(&::TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile)
                , default_ReadNodesPerProcessorFile_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_ReadNodesPerProcessorFile)
                , ( bp::arg("rNodesPerProcessorFile") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*RefreshJacobianCachedData_function_type)(  ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_RefreshJacobianCachedData_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "RefreshJacobianCachedData"
                , RefreshJacobianCachedData_function_type(&::TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData)
                , default_RefreshJacobianCachedData_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_RefreshJacobianCachedData) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::RefreshMesh
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*RefreshMesh_function_type)(  ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_RefreshMesh_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "RefreshMesh"
                , RefreshMesh_function_type(&::TetrahedralMesh< 3, 3 >::RefreshMesh)
                , default_RefreshMesh_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_RefreshMesh) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ) ;
            
            MutableMesh3_3_exposer.def( 
                "Rotate"
                , Rotate_function_type(&::AbstractMesh< 3, 3 >::Rotate)
                , default_Rotate_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_Rotate)
                , ( bp::arg("rotationMatrix") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            MutableMesh3_3_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 3, 3 >::Rotate )
                , ( bp::arg("axis"), bp::arg("angle") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( double ) ;
            
            MutableMesh3_3_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 3, 3 >::Rotate )
                , ( bp::arg("theta") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Scale
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Scale_function_type)( double const,double const,double const ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_Scale_function_type)( double const,double const,double const ) ;
            
            MutableMesh3_3_exposer.def( 
                "Scale"
                , Scale_function_type(&::AbstractMesh< 3, 3 >::Scale)
                , default_Scale_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_Scale)
                , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) );
        
        }
        { //::AbstractMesh< 3, 3 >::SetDistributedVectorFactory
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            
            MutableMesh3_3_exposer.def( 
                "SetDistributedVectorFactory"
                , SetDistributedVectorFactory_function_type(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
                , default_SetDistributedVectorFactory_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_SetDistributedVectorFactory)
                , ( bp::arg("pFactory") ) );
        
        }
        { //::AbstractTetrahedralMesh< 3, 3 >::SetElementOwnerships
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*SetElementOwnerships_function_type)(  ) ;
            
            MutableMesh3_3_exposer.def( 
                "SetElementOwnerships"
                , SetElementOwnerships_function_type( &MutableMesh_less__3_comma__3__greater__wrapper::default_SetElementOwnerships ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::SolveBoundaryElementMapping
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*SolveBoundaryElementMapping_function_type)( unsigned int ) const;
            
            MutableMesh3_3_exposer.def( 
                "SolveBoundaryElementMapping"
                , SolveBoundaryElementMapping_function_type( &MutableMesh_less__3_comma__3__greater__wrapper::default_SolveBoundaryElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::SolveElementMapping
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*SolveElementMapping_function_type)( unsigned int ) const;
            
            MutableMesh3_3_exposer.def( 
                "SolveElementMapping"
                , SolveElementMapping_function_type( &MutableMesh_less__3_comma__3__greater__wrapper::default_SolveElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::TetrahedralMesh< 3, 3 >::SolveNodeMapping
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( MutableMesh_less__3_comma__3__greater__wrapper::*SolveNodeMapping_function_type)( unsigned int ) const;
            
            MutableMesh3_3_exposer.def( 
                "SolveNodeMapping"
                , SolveNodeMapping_function_type( &MutableMesh_less__3_comma__3__greater__wrapper::default_SolveNodeMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Translate
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            typedef void ( MutableMesh_less__3_comma__3__greater__wrapper::*default_Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            
            MutableMesh3_3_exposer.def( 
                "Translate"
                , Translate_function_type(&::AbstractMesh< 3, 3 >::Translate)
                , default_Translate_function_type(&MutableMesh_less__3_comma__3__greater__wrapper::default_Translate)
                , ( bp::arg("rDisplacement") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Translate
        
            typedef MutableMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( double const,double const,double const ) ;
            
            MutableMesh3_3_exposer.def( 
                "Translate"
                , Translate_function_type( &::AbstractMesh< 3, 3 >::Translate )
                , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );
        
        }
    }

    { //::VertexMesh< 2, 2 >
        typedef bp::class_< VertexMesh_less__2_comma__2__greater__wrapper, bp::bases< AbstractMesh< 2, 2 > >, boost::noncopyable > VertexMesh2_2_exposer_t;
        VertexMesh2_2_exposer_t VertexMesh2_2_exposer = VertexMesh2_2_exposer_t( "VertexMesh2_2", bp::init< std::vector< Node<2> * >, std::vector< VertexElement<2, 2> * > >(( bp::arg("nodes"), bp::arg("vertexElements") )) );
        bp::scope VertexMesh2_2_scope( VertexMesh2_2_exposer );
        VertexMesh2_2_exposer.def( bp::init< std::vector< Node<2> * >, std::vector< VertexElement<1, 2> * >, std::vector< VertexElement<2, 2> * > >(( bp::arg("nodes"), bp::arg("faces"), bp::arg("vertexElements") )) );
        VertexMesh2_2_exposer.def( bp::init< TetrahedralMesh< 2, 2 > &, bp::optional< bool > >(( bp::arg("rMesh"), bp::arg("isPeriodic")=(bool)(false) )) );
        bp::implicitly_convertible< TetrahedralMesh< 2, 2 > &, VertexMesh< 2, 2 > >();
        VertexMesh2_2_exposer.def( bp::init< >() );
        { //::VertexMesh< 2, 2 >::CalculateAreaOfFace
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*CalculateAreaOfFace_function_type)( ::VertexElement< 1, 2 > * ) ;
            typedef double ( VertexMesh_less__2_comma__2__greater__wrapper::*default_CalculateAreaOfFace_function_type)( ::VertexElement< 1, 2 > * ) ;
            
            VertexMesh2_2_exposer.def( 
                "CalculateAreaOfFace"
                , CalculateAreaOfFace_function_type(&::VertexMesh< 2, 2 >::CalculateAreaOfFace)
                , default_CalculateAreaOfFace_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_CalculateAreaOfFace)
                , ( bp::arg("pFace") ) );
        
        }
        { //::VertexMesh< 2, 2 >::CalculateMomentsOfElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*CalculateMomentsOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( VertexMesh_less__2_comma__2__greater__wrapper::*default_CalculateMomentsOfElement_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "CalculateMomentsOfElement"
                , CalculateMomentsOfElement_function_type(&::VertexMesh< 2, 2 >::CalculateMomentsOfElement)
                , default_CalculateMomentsOfElement_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_CalculateMomentsOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::CalculateUnitNormalToFaceWithArea
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*CalculateUnitNormalToFaceWithArea_function_type)( ::VertexElement< 1, 2 > *,::boost::numeric::ublas::c_vector< double, 2 > & ) ;
            
            VertexMesh2_2_exposer.def( 
                "CalculateUnitNormalToFaceWithArea"
                , CalculateUnitNormalToFaceWithArea_function_type( &::VertexMesh< 2, 2 >::CalculateUnitNormalToFaceWithArea )
                , ( bp::arg("pFace"), bp::arg("rNormal") ) );
        
        }
        { //::VertexMesh< 2, 2 >::Clear
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Clear_function_type)(  ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_Clear_function_type)(  ) ;
            
            VertexMesh2_2_exposer.def( 
                "Clear"
                , Clear_function_type(&::VertexMesh< 2, 2 >::Clear)
                , default_Clear_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_Clear) );
        
        }
        { //::VertexMesh< 2, 2 >::ConstructFromMeshReader
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 2, 2 > & ) ;
            
            VertexMesh2_2_exposer.def( 
                "ConstructFromMeshReader"
                , ConstructFromMeshReader_function_type( &::VertexMesh< 2, 2 >::ConstructFromMeshReader )
                , ( bp::arg("rMeshReader") ) );
        
        }
        { //::VertexMesh< 2, 2 >::ElementIncludesPoint
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef bool ( VertexMesh_less__2_comma__2__greater__wrapper::*ElementIncludesPoint_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "ElementIncludesPoint"
                , ElementIncludesPoint_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::ElementIncludesPoint )
                , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GenerateVerticesFromElementCircumcentres
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*GenerateVerticesFromElementCircumcentres_function_type)( ::TetrahedralMesh< 2, 2 > & ) ;
            
            VertexMesh2_2_exposer.def( 
                "GenerateVerticesFromElementCircumcentres"
                , GenerateVerticesFromElementCircumcentres_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::GenerateVerticesFromElementCircumcentres )
                , ( bp::arg("rMesh") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetAreaGradientOfElementAtNode
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetAreaGradientOfElementAtNode_function_type)( ::VertexElement< 2, 2 > *,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetAreaGradientOfElementAtNode"
                , GetAreaGradientOfElementAtNode_function_type( &::VertexMesh< 2, 2 >::GetAreaGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetCentroidOfElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetCentroidOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetCentroidOfElement_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetCentroidOfElement"
                , GetCentroidOfElement_function_type(&::VertexMesh< 2, 2 >::GetCentroidOfElement)
                , default_GetCentroidOfElement_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetCentroidOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex"
                , GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex_function_type( &::VertexMesh< 2, 2 >::GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetEdgeLength
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetEdgeLength_function_type)( unsigned int,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetEdgeLength"
                , GetEdgeLength_function_type( &::VertexMesh< 2, 2 >::GetEdgeLength )
                , ( bp::arg("elementIndex1"), bp::arg("elementIndex2") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetElementIteratorBegin
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::VertexMesh< 2, 2 >::VertexElementIterator ( exported_class_t::*GetElementIteratorBegin_function_type)( bool ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetElementIteratorBegin"
                , GetElementIteratorBegin_function_type( &::VertexMesh< 2, 2 >::GetElementIteratorBegin )
                , ( bp::arg("skipDeletedElements")=(bool)(true) ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetElementIteratorEnd
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::VertexMesh< 2, 2 >::VertexElementIterator ( exported_class_t::*GetElementIteratorEnd_function_type)(  ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetElementIteratorEnd"
                , GetElementIteratorEnd_function_type( &::VertexMesh< 2, 2 >::GetElementIteratorEnd ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetElongationShapeFactorOfElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetElongationShapeFactorOfElement_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetElongationShapeFactorOfElement"
                , GetElongationShapeFactorOfElement_function_type( &::VertexMesh< 2, 2 >::GetElongationShapeFactorOfElement )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetLocalIndexForElementEdgeClosestToPoint
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*GetLocalIndexForElementEdgeClosestToPoint_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetLocalIndexForElementEdgeClosestToPoint"
                , GetLocalIndexForElementEdgeClosestToPoint_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::GetLocalIndexForElementEdgeClosestToPoint )
                , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNeighbouringElementIndices
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringElementIndices_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetNeighbouringElementIndices"
                , GetNeighbouringElementIndices_function_type( &::VertexMesh< 2, 2 >::GetNeighbouringElementIndices )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNeighbouringNodeIndices
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringNodeIndices_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetNeighbouringNodeIndices"
                , GetNeighbouringNodeIndices_function_type( &::VertexMesh< 2, 2 >::GetNeighbouringNodeIndices )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNeighbouringNodeNotAlsoInElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringNodeNotAlsoInElement_function_type)( unsigned int,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetNeighbouringNodeNotAlsoInElement"
                , GetNeighbouringNodeNotAlsoInElement_function_type( &::VertexMesh< 2, 2 >::GetNeighbouringNodeNotAlsoInElement )
                , ( bp::arg("nodeIndex"), bp::arg("elemIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNextEdgeGradientOfElementAtNode
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetNextEdgeGradientOfElementAtNode_function_type)( ::VertexElement< 2, 2 > *,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetNextEdgeGradientOfElementAtNode"
                , GetNextEdgeGradientOfElementAtNode_function_type( &::VertexMesh< 2, 2 >::GetNextEdgeGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNumAllElements
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllElements_function_type)(  ) const;
            
            VertexMesh2_2_exposer.def( 
                "GetNumAllElements"
                , GetNumAllElements_function_type( &::VertexMesh< 2, 2 >::GetNumAllElements ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNumElements
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumElements_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumElements_function_type)(  ) const;
            
            VertexMesh2_2_exposer.def( 
                "GetNumElements"
                , GetNumElements_function_type(&::VertexMesh< 2, 2 >::GetNumElements)
                , default_GetNumElements_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetNumElements) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNumFaces
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumFaces_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumFaces_function_type)(  ) const;
            
            VertexMesh2_2_exposer.def( 
                "GetNumFaces"
                , GetNumFaces_function_type(&::VertexMesh< 2, 2 >::GetNumFaces)
                , default_GetNumFaces_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetNumFaces) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNumNodes
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodes_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumNodes_function_type)(  ) const;
            
            VertexMesh2_2_exposer.def( 
                "GetNumNodes"
                , GetNumNodes_function_type(&::VertexMesh< 2, 2 >::GetNumNodes)
                , default_GetNumNodes_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetNumNodes) );
        
        }
        { //::VertexMesh< 2, 2 >::GetPerimeterGradientOfElementAtNode
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetPerimeterGradientOfElementAtNode_function_type)( ::VertexElement< 2, 2 > *,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetPerimeterGradientOfElementAtNode"
                , GetPerimeterGradientOfElementAtNode_function_type( &::VertexMesh< 2, 2 >::GetPerimeterGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetPreviousEdgeGradientOfElementAtNode
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetPreviousEdgeGradientOfElementAtNode_function_type)( ::VertexElement< 2, 2 > *,unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetPreviousEdgeGradientOfElementAtNode"
                , GetPreviousEdgeGradientOfElementAtNode_function_type( &::VertexMesh< 2, 2 >::GetPreviousEdgeGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetRosetteRankOfElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetRosetteRankOfElement_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetRosetteRankOfElement"
                , GetRosetteRankOfElement_function_type( &::VertexMesh< 2, 2 >::GetRosetteRankOfElement )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetShortAxisOfElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetShortAxisOfElement_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetShortAxisOfElement"
                , GetShortAxisOfElement_function_type( &::VertexMesh< 2, 2 >::GetShortAxisOfElement )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetSurfaceAreaOfElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            typedef double ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetSurfaceAreaOfElement"
                , GetSurfaceAreaOfElement_function_type(&::VertexMesh< 2, 2 >::GetSurfaceAreaOfElement)
                , default_GetSurfaceAreaOfElement_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetSurfaceAreaOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetVectorFromAtoB
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetVectorFromAtoB"
                , GetVectorFromAtoB_function_type(&::VertexMesh< 2, 2 >::GetVectorFromAtoB)
                , default_GetVectorFromAtoB_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetVectorFromAtoB)
                , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetVolumeOfElement
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetVolumeOfElement_function_type)( unsigned int ) ;
            typedef double ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetVolumeOfElement_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetVolumeOfElement"
                , GetVolumeOfElement_function_type(&::VertexMesh< 2, 2 >::GetVolumeOfElement)
                , default_GetVolumeOfElement_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetVolumeOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex_function_type)( unsigned int ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex"
                , GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex_function_type( &::VertexMesh< 2, 2 >::GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::SolveBoundaryElementMapping
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*SolveBoundaryElementMapping_function_type)( unsigned int ) const;
            
            VertexMesh2_2_exposer.def( 
                "SolveBoundaryElementMapping"
                , SolveBoundaryElementMapping_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::SolveBoundaryElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::SolveElementMapping
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*SolveElementMapping_function_type)( unsigned int ) const;
            
            VertexMesh2_2_exposer.def( 
                "SolveElementMapping"
                , SolveElementMapping_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::SolveElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::SolveNodeMapping
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*SolveNodeMapping_function_type)( unsigned int ) const;
            
            VertexMesh2_2_exposer.def( 
                "SolveNodeMapping"
                , SolveNodeMapping_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::default_SolveNodeMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( VertexMesh_less__2_comma__2__greater__wrapper::*CalculateBoundingBox_function_type)( ::std::vector< Node<2> * > const & ) const;
            
            VertexMesh2_2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::CalculateBoundingBox )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( exported_class_t::*CalculateBoundingBox_function_type)(  ) const;
            typedef ::ChasteCuboid< 2 > ( VertexMesh_less__2_comma__2__greater__wrapper::*default_CalculateBoundingBox_function_type)(  ) const;
            
            VertexMesh2_2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
                , default_CalculateBoundingBox_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_CalculateBoundingBox) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNearestNodeIndex
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            
            VertexMesh2_2_exposer.def( 
                "GetNearestNodeIndex"
                , GetNearestNodeIndex_function_type(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
                , default_GetNearestNodeIndex_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetNearestNodeIndex)
                , ( bp::arg("rTestPoint") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNumAllNodes
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllNodes_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumAllNodes_function_type)(  ) const;
            
            VertexMesh2_2_exposer.def( 
                "GetNumAllNodes"
                , GetNumAllNodes_function_type(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
                , default_GetNumAllNodes_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetNumAllNodes) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetWidth
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetWidth_function_type)( unsigned int const & ) const;
            typedef double ( VertexMesh_less__2_comma__2__greater__wrapper::*default_GetWidth_function_type)( unsigned int const & ) const;
            
            VertexMesh2_2_exposer.def( 
                "GetWidth"
                , GetWidth_function_type(&::AbstractMesh< 2, 2 >::GetWidth)
                , default_GetWidth_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_GetWidth)
                , ( bp::arg("rDimension") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::PermuteNodes
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)(  ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_PermuteNodes_function_type)(  ) ;
            
            VertexMesh2_2_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type(&::AbstractMesh< 2, 2 >::PermuteNodes)
                , default_PermuteNodes_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_PermuteNodes) );
        
        }
        { //::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            
            VertexMesh2_2_exposer.def( 
                "ReadNodesPerProcessorFile"
                , ReadNodesPerProcessorFile_function_type(&::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile)
                , default_ReadNodesPerProcessorFile_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_ReadNodesPerProcessorFile)
                , ( bp::arg("rNodesPerProcessorFile") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::RefreshMesh
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*RefreshMesh_function_type)(  ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_RefreshMesh_function_type)(  ) ;
            
            VertexMesh2_2_exposer.def( 
                "RefreshMesh"
                , RefreshMesh_function_type(&::AbstractMesh< 2, 2 >::RefreshMesh)
                , default_RefreshMesh_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_RefreshMesh) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            
            VertexMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type(&::AbstractMesh< 2, 2 >::Rotate)
                , default_Rotate_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_Rotate)
                , ( bp::arg("rotationMatrix") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            VertexMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("axis"), bp::arg("angle") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( double ) ;
            
            VertexMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("theta") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Scale
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Scale_function_type)( double const,double const,double const ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_Scale_function_type)( double const,double const,double const ) ;
            
            VertexMesh2_2_exposer.def( 
                "Scale"
                , Scale_function_type(&::AbstractMesh< 2, 2 >::Scale)
                , default_Scale_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_Scale)
                , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) );
        
        }
        { //::AbstractMesh< 2, 2 >::SetDistributedVectorFactory
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            
            VertexMesh2_2_exposer.def( 
                "SetDistributedVectorFactory"
                , SetDistributedVectorFactory_function_type(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
                , default_SetDistributedVectorFactory_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_SetDistributedVectorFactory)
                , ( bp::arg("pFactory") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::SetElementOwnerships
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*SetElementOwnerships_function_type)(  ) ;
            
            VertexMesh2_2_exposer.def( 
                "SetElementOwnerships"
                , SetElementOwnerships_function_type( &VertexMesh_less__2_comma__2__greater__wrapper::default_SetElementOwnerships ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef void ( VertexMesh_less__2_comma__2__greater__wrapper::*default_Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            VertexMesh2_2_exposer.def( 
                "Translate"
                , Translate_function_type(&::AbstractMesh< 2, 2 >::Translate)
                , default_Translate_function_type(&VertexMesh_less__2_comma__2__greater__wrapper::default_Translate)
                , ( bp::arg("rDisplacement") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef VertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( double const,double const,double const ) ;
            
            VertexMesh2_2_exposer.def( 
                "Translate"
                , Translate_function_type( &::AbstractMesh< 2, 2 >::Translate )
                , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );
        
        }
    }

    { //::MutableVertexMesh< 2, 2 >
        typedef bp::class_< MutableVertexMesh_less__2_comma__2__greater__wrapper, bp::bases< VertexMesh< 2, 2 > >, boost::noncopyable > MutableVertexMesh2_2_exposer_t;
        MutableVertexMesh2_2_exposer_t MutableVertexMesh2_2_exposer = MutableVertexMesh2_2_exposer_t( "MutableVertexMesh2_2", bp::init< std::vector< Node<2> * >, std::vector< VertexElement<2, 2> * >, bp::optional< double, double, double, double, double, double > >(( bp::arg("nodes"), bp::arg("vertexElements"), bp::arg("cellRearrangementThreshold")=0.01, bp::arg("t2Threshold")=0.001, bp::arg("cellRearrangementRatio")=1.5, bp::arg("protorosetteFormationProbability")=0., bp::arg("protorosetteResolutionProbabilityPerTimestep")=0., bp::arg("rosetteResolutionProbabilityPerTimestep")=0. )) );
        bp::scope MutableVertexMesh2_2_scope( MutableVertexMesh2_2_exposer );
        MutableVertexMesh2_2_exposer.def( bp::init< >() );
        { //::MutableVertexMesh< 2, 2 >::AddElement
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddElement_function_type)( ::VertexElement< 2, 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "AddElement"
                , AddElement_function_type( &::MutableVertexMesh< 2, 2 >::AddElement )
                , ( bp::arg("pNewElement") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::AddNode
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddNode_function_type)( ::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "AddNode"
                , AddNode_function_type( &::MutableVertexMesh< 2, 2 >::AddNode )
                , ( bp::arg("pNewNode") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::CheckForIntersections
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef bool ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*CheckForIntersections_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "CheckForIntersections"
                , CheckForIntersections_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::CheckForIntersections ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::CheckForRosettes
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*CheckForRosettes_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "CheckForRosettes"
                , CheckForRosettes_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::CheckForRosettes ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::CheckForSwapsFromShortEdges
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef bool ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*CheckForSwapsFromShortEdges_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "CheckForSwapsFromShortEdges"
                , CheckForSwapsFromShortEdges_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::CheckForSwapsFromShortEdges ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::CheckForT2Swaps
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef bool ( exported_class_t::*CheckForT2Swaps_function_type)( ::VertexElementMap & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "CheckForT2Swaps"
                , CheckForT2Swaps_function_type( &::MutableVertexMesh< 2, 2 >::CheckForT2Swaps )
                , ( bp::arg("rElementMap") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::Clear
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Clear_function_type)(  ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_Clear_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "Clear"
                , Clear_function_type(&::MutableVertexMesh< 2, 2 >::Clear)
                , default_Clear_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_Clear) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::ClearLocationsOfT1Swaps
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ClearLocationsOfT1Swaps_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "ClearLocationsOfT1Swaps"
                , ClearLocationsOfT1Swaps_function_type( &::MutableVertexMesh< 2, 2 >::ClearLocationsOfT1Swaps ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::ClearLocationsOfT3Swaps
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ClearLocationsOfT3Swaps_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "ClearLocationsOfT3Swaps"
                , ClearLocationsOfT3Swaps_function_type( &::MutableVertexMesh< 2, 2 >::ClearLocationsOfT3Swaps ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::DeleteElementPriorToReMesh
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteElementPriorToReMesh_function_type)( unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "DeleteElementPriorToReMesh"
                , DeleteElementPriorToReMesh_function_type( &::MutableVertexMesh< 2, 2 >::DeleteElementPriorToReMesh )
                , ( bp::arg("index") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::DeleteNodePriorToReMesh
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteNodePriorToReMesh_function_type)( unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "DeleteNodePriorToReMesh"
                , DeleteNodePriorToReMesh_function_type( &::MutableVertexMesh< 2, 2 >::DeleteNodePriorToReMesh )
                , ( bp::arg("index") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::DivideEdge
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*DivideEdge_function_type)( ::Node< 2 > *,::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "DivideEdge"
                , DivideEdge_function_type( &::MutableVertexMesh< 2, 2 >::DivideEdge )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::DivideElement
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*DivideElement_function_type)( ::VertexElement< 2, 2 > *,unsigned int,unsigned int,bool ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "DivideElement"
                , DivideElement_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::DivideElement )
                , ( bp::arg("pElement"), bp::arg("nodeAIndex"), bp::arg("nodeBIndex"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::DivideElementAlongGivenAxis
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*DivideElementAlongGivenAxis_function_type)( ::VertexElement< 2, 2 > *,::boost::numeric::ublas::c_vector< double, 2 >,bool ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "DivideElementAlongGivenAxis"
                , DivideElementAlongGivenAxis_function_type( &::MutableVertexMesh< 2, 2 >::DivideElementAlongGivenAxis )
                , ( bp::arg("pElement"), bp::arg("axisOfDivision"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::DivideElementAlongShortAxis
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*DivideElementAlongShortAxis_function_type)( ::VertexElement< 2, 2 > *,bool ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "DivideElementAlongShortAxis"
                , DivideElementAlongShortAxis_function_type( &::MutableVertexMesh< 2, 2 >::DivideElementAlongShortAxis )
                , ( bp::arg("pElement"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetCellRearrangementRatio
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetCellRearrangementRatio_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetCellRearrangementRatio"
                , GetCellRearrangementRatio_function_type( &::MutableVertexMesh< 2, 2 >::GetCellRearrangementRatio ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetCellRearrangementThreshold
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetCellRearrangementThreshold_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetCellRearrangementThreshold"
                , GetCellRearrangementThreshold_function_type( &::MutableVertexMesh< 2, 2 >::GetCellRearrangementThreshold ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetCheckForInternalIntersections
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef bool ( exported_class_t::*GetCheckForInternalIntersections_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetCheckForInternalIntersections"
                , GetCheckForInternalIntersections_function_type( &::MutableVertexMesh< 2, 2 >::GetCheckForInternalIntersections ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetLastT2SwapLocation
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetLastT2SwapLocation_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetLastT2SwapLocation"
                , GetLastT2SwapLocation_function_type( &::MutableVertexMesh< 2, 2 >::GetLastT2SwapLocation ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetLocationsOfT1Swaps
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 2> > ( exported_class_t::*GetLocationsOfT1Swaps_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetLocationsOfT1Swaps"
                , GetLocationsOfT1Swaps_function_type( &::MutableVertexMesh< 2, 2 >::GetLocationsOfT1Swaps ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetLocationsOfT3Swaps
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::std::vector< boost::numeric::ublas::c_vector<double, 2> > ( exported_class_t::*GetLocationsOfT3Swaps_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetLocationsOfT3Swaps"
                , GetLocationsOfT3Swaps_function_type( &::MutableVertexMesh< 2, 2 >::GetLocationsOfT3Swaps ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetNumElements
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumElements_function_type)(  ) const;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumElements_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetNumElements"
                , GetNumElements_function_type(&::MutableVertexMesh< 2, 2 >::GetNumElements)
                , default_GetNumElements_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetNumElements) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetNumNodes
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodes_function_type)(  ) const;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumNodes_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetNumNodes"
                , GetNumNodes_function_type(&::MutableVertexMesh< 2, 2 >::GetNumNodes)
                , default_GetNumNodes_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetNumNodes) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetProtorosetteFormationProbability
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetProtorosetteFormationProbability_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetProtorosetteFormationProbability"
                , GetProtorosetteFormationProbability_function_type( &::MutableVertexMesh< 2, 2 >::GetProtorosetteFormationProbability ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetProtorosetteResolutionProbabilityPerTimestep
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetProtorosetteResolutionProbabilityPerTimestep_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetProtorosetteResolutionProbabilityPerTimestep"
                , GetProtorosetteResolutionProbabilityPerTimestep_function_type( &::MutableVertexMesh< 2, 2 >::GetProtorosetteResolutionProbabilityPerTimestep ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetRosetteResolutionProbabilityPerTimestep
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetRosetteResolutionProbabilityPerTimestep_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetRosetteResolutionProbabilityPerTimestep"
                , GetRosetteResolutionProbabilityPerTimestep_function_type( &::MutableVertexMesh< 2, 2 >::GetRosetteResolutionProbabilityPerTimestep ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::GetT2Threshold
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetT2Threshold_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetT2Threshold"
                , GetT2Threshold_function_type( &::MutableVertexMesh< 2, 2 >::GetT2Threshold ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::HandleHighOrderJunctions
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*HandleHighOrderJunctions_function_type)( ::Node< 2 > *,::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "HandleHighOrderJunctions"
                , HandleHighOrderJunctions_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::default_HandleHighOrderJunctions )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::IdentifySwapType
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*IdentifySwapType_function_type)( ::Node< 2 > *,::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "IdentifySwapType"
                , IdentifySwapType_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::default_IdentifySwapType )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformIntersectionSwap
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformIntersectionSwap_function_type)( ::Node< 2 > *,unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformIntersectionSwap"
                , PerformIntersectionSwap_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformIntersectionSwap )
                , ( bp::arg("pNode"), bp::arg("elementIndex") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformNodeMerge
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformNodeMerge_function_type)( ::Node< 2 > *,::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformNodeMerge"
                , PerformNodeMerge_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformNodeMerge )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformProtorosetteResolution
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformProtorosetteResolution_function_type)( ::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformProtorosetteResolution"
                , PerformProtorosetteResolution_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformProtorosetteResolution )
                , ( bp::arg("pProtorosetteNode") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformRosetteRankDecrease
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformRosetteRankDecrease_function_type)( ::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformRosetteRankDecrease"
                , PerformRosetteRankDecrease_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformRosetteRankDecrease )
                , ( bp::arg("pRosetteNode") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformRosetteRankIncrease
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformRosetteRankIncrease_function_type)( ::Node< 2 > *,::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformRosetteRankIncrease"
                , PerformRosetteRankIncrease_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformRosetteRankIncrease )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformT1Swap
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformT1Swap_function_type)( ::Node< 2 > *,::Node< 2 > *,::std::set< unsigned int > & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformT1Swap"
                , PerformT1Swap_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformT1Swap )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB"), bp::arg("rElementsContainingNodes") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformT2Swap
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformT2Swap_function_type)( ::VertexElement< 2, 2 > & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformT2Swap"
                , PerformT2Swap_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformT2Swap )
                , ( bp::arg("rElement") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformT3Swap
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformT3Swap_function_type)( ::Node< 2 > *,unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformT3Swap"
                , PerformT3Swap_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformT3Swap )
                , ( bp::arg("pNode"), bp::arg("elementIndex") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::PerformVoidRemoval
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*PerformVoidRemoval_function_type)( ::Node< 2 > *,::Node< 2 > *,::Node< 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PerformVoidRemoval"
                , PerformVoidRemoval_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::PerformVoidRemoval )
                , ( bp::arg("pNodeA"), bp::arg("pNodeB"), bp::arg("pNodeC") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::ReMesh
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReMesh_function_type)( ::VertexElementMap & ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_ReMesh_function_type)( ::VertexElementMap & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "ReMesh"
                , ReMesh_function_type(&::MutableVertexMesh< 2, 2 >::ReMesh)
                , default_ReMesh_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_ReMesh)
                , ( bp::arg("rElementMap") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::ReMesh
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReMesh_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "ReMesh"
                , ReMesh_function_type( &::MutableVertexMesh< 2, 2 >::ReMesh ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::RemoveDeletedNodes
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveDeletedNodes_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "RemoveDeletedNodes"
                , RemoveDeletedNodes_function_type( &::MutableVertexMesh< 2, 2 >::RemoveDeletedNodes ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::RemoveDeletedNodesAndElements
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveDeletedNodesAndElements_function_type)( ::VertexElementMap & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "RemoveDeletedNodesAndElements"
                , RemoveDeletedNodesAndElements_function_type( &::MutableVertexMesh< 2, 2 >::RemoveDeletedNodesAndElements )
                , ( bp::arg("rElementMap") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetCellRearrangementRatio
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellRearrangementRatio_function_type)( double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetCellRearrangementRatio"
                , SetCellRearrangementRatio_function_type( &::MutableVertexMesh< 2, 2 >::SetCellRearrangementRatio )
                , ( bp::arg("cellRearrangementRatio") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetCellRearrangementThreshold
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCellRearrangementThreshold_function_type)( double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetCellRearrangementThreshold"
                , SetCellRearrangementThreshold_function_type( &::MutableVertexMesh< 2, 2 >::SetCellRearrangementThreshold )
                , ( bp::arg("cellRearrangementThreshold") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetCheckForInternalIntersections
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetCheckForInternalIntersections_function_type)( bool ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetCheckForInternalIntersections"
                , SetCheckForInternalIntersections_function_type( &::MutableVertexMesh< 2, 2 >::SetCheckForInternalIntersections )
                , ( bp::arg("checkForInternalIntersections") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetNode
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNode_function_type)( unsigned int,::ChastePoint< 2 > ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_SetNode_function_type)( unsigned int,::ChastePoint< 2 > ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetNode"
                , SetNode_function_type(&::MutableVertexMesh< 2, 2 >::SetNode)
                , default_SetNode_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_SetNode)
                , ( bp::arg("nodeIndex"), bp::arg("point") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetProtorosetteFormationProbability
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetProtorosetteFormationProbability_function_type)( double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetProtorosetteFormationProbability"
                , SetProtorosetteFormationProbability_function_type( &::MutableVertexMesh< 2, 2 >::SetProtorosetteFormationProbability )
                , ( bp::arg("protorosetteFormationProbability") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetProtorosetteResolutionProbabilityPerTimestep
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetProtorosetteResolutionProbabilityPerTimestep_function_type)( double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetProtorosetteResolutionProbabilityPerTimestep"
                , SetProtorosetteResolutionProbabilityPerTimestep_function_type( &::MutableVertexMesh< 2, 2 >::SetProtorosetteResolutionProbabilityPerTimestep )
                , ( bp::arg("protorosetteResolutionProbabilityPerTimestep") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetRosetteResolutionProbabilityPerTimestep
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRosetteResolutionProbabilityPerTimestep_function_type)( double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetRosetteResolutionProbabilityPerTimestep"
                , SetRosetteResolutionProbabilityPerTimestep_function_type( &::MutableVertexMesh< 2, 2 >::SetRosetteResolutionProbabilityPerTimestep )
                , ( bp::arg("rosetteResolutionProbabilityPerTimestep") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::SetT2Threshold
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetT2Threshold_function_type)( double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetT2Threshold"
                , SetT2Threshold_function_type( &::MutableVertexMesh< 2, 2 >::SetT2Threshold )
                , ( bp::arg("t2Threshold") ) );
        
        }
        { //::MutableVertexMesh< 2, 2 >::WidenEdgeOrCorrectIntersectionLocationIfNecessary
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*WidenEdgeOrCorrectIntersectionLocationIfNecessary_function_type)( unsigned int,unsigned int,::boost::numeric::ublas::c_vector< double, 2 > ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "WidenEdgeOrCorrectIntersectionLocationIfNecessary"
                , WidenEdgeOrCorrectIntersectionLocationIfNecessary_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::WidenEdgeOrCorrectIntersectionLocationIfNecessary )
                , ( bp::arg("indexA"), bp::arg("indexB"), bp::arg("intersection") ) );
        
        }
        { //::VertexMesh< 2, 2 >::CalculateAreaOfFace
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*CalculateAreaOfFace_function_type)( ::VertexElement< 1, 2 > * ) ;
            typedef double ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_CalculateAreaOfFace_function_type)( ::VertexElement< 1, 2 > * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "CalculateAreaOfFace"
                , CalculateAreaOfFace_function_type(&::VertexMesh< 2, 2 >::CalculateAreaOfFace)
                , default_CalculateAreaOfFace_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_CalculateAreaOfFace)
                , ( bp::arg("pFace") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*CalculateBoundingBox_function_type)( ::std::vector< Node<2> * > const & ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::CalculateBoundingBox )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( exported_class_t::*CalculateBoundingBox_function_type)(  ) const;
            typedef ::ChasteCuboid< 2 > ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_CalculateBoundingBox_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
                , default_CalculateBoundingBox_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_CalculateBoundingBox) );
        
        }
        { //::VertexMesh< 2, 2 >::CalculateMomentsOfElement
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*CalculateMomentsOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_CalculateMomentsOfElement_function_type)( unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "CalculateMomentsOfElement"
                , CalculateMomentsOfElement_function_type(&::VertexMesh< 2, 2 >::CalculateMomentsOfElement)
                , default_CalculateMomentsOfElement_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_CalculateMomentsOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::ElementIncludesPoint
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef bool ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*ElementIncludesPoint_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "ElementIncludesPoint"
                , ElementIncludesPoint_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::ElementIncludesPoint )
                , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GenerateVerticesFromElementCircumcentres
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*GenerateVerticesFromElementCircumcentres_function_type)( ::TetrahedralMesh< 2, 2 > & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GenerateVerticesFromElementCircumcentres"
                , GenerateVerticesFromElementCircumcentres_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::GenerateVerticesFromElementCircumcentres )
                , ( bp::arg("rMesh") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetCentroidOfElement
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetCentroidOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetCentroidOfElement_function_type)( unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetCentroidOfElement"
                , GetCentroidOfElement_function_type(&::VertexMesh< 2, 2 >::GetCentroidOfElement)
                , default_GetCentroidOfElement_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetCentroidOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetLocalIndexForElementEdgeClosestToPoint
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*GetLocalIndexForElementEdgeClosestToPoint_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetLocalIndexForElementEdgeClosestToPoint"
                , GetLocalIndexForElementEdgeClosestToPoint_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::GetLocalIndexForElementEdgeClosestToPoint )
                , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNearestNodeIndex
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetNearestNodeIndex"
                , GetNearestNodeIndex_function_type(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
                , default_GetNearestNodeIndex_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetNearestNodeIndex)
                , ( bp::arg("rTestPoint") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNumAllNodes
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllNodes_function_type)(  ) const;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumAllNodes_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetNumAllNodes"
                , GetNumAllNodes_function_type(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
                , default_GetNumAllNodes_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetNumAllNodes) );
        
        }
        { //::VertexMesh< 2, 2 >::GetNumFaces
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumFaces_function_type)(  ) const;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetNumFaces_function_type)(  ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetNumFaces"
                , GetNumFaces_function_type(&::VertexMesh< 2, 2 >::GetNumFaces)
                , default_GetNumFaces_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetNumFaces) );
        
        }
        { //::VertexMesh< 2, 2 >::GetSurfaceAreaOfElement
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            typedef double ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetSurfaceAreaOfElement"
                , GetSurfaceAreaOfElement_function_type(&::VertexMesh< 2, 2 >::GetSurfaceAreaOfElement)
                , default_GetSurfaceAreaOfElement_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetSurfaceAreaOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetVectorFromAtoB
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetVectorFromAtoB"
                , GetVectorFromAtoB_function_type(&::VertexMesh< 2, 2 >::GetVectorFromAtoB)
                , default_GetVectorFromAtoB_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetVectorFromAtoB)
                , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) );
        
        }
        { //::VertexMesh< 2, 2 >::GetVolumeOfElement
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetVolumeOfElement_function_type)( unsigned int ) ;
            typedef double ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetVolumeOfElement_function_type)( unsigned int ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetVolumeOfElement"
                , GetVolumeOfElement_function_type(&::VertexMesh< 2, 2 >::GetVolumeOfElement)
                , default_GetVolumeOfElement_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetVolumeOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetWidth
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef double ( exported_class_t::*GetWidth_function_type)( unsigned int const & ) const;
            typedef double ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_GetWidth_function_type)( unsigned int const & ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "GetWidth"
                , GetWidth_function_type(&::AbstractMesh< 2, 2 >::GetWidth)
                , default_GetWidth_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_GetWidth)
                , ( bp::arg("rDimension") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::PermuteNodes
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)(  ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_PermuteNodes_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type(&::AbstractMesh< 2, 2 >::PermuteNodes)
                , default_PermuteNodes_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_PermuteNodes) );
        
        }
        { //::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "ReadNodesPerProcessorFile"
                , ReadNodesPerProcessorFile_function_type(&::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile)
                , default_ReadNodesPerProcessorFile_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_ReadNodesPerProcessorFile)
                , ( bp::arg("rNodesPerProcessorFile") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::RefreshMesh
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*RefreshMesh_function_type)(  ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_RefreshMesh_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "RefreshMesh"
                , RefreshMesh_function_type(&::AbstractMesh< 2, 2 >::RefreshMesh)
                , default_RefreshMesh_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_RefreshMesh) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type(&::AbstractMesh< 2, 2 >::Rotate)
                , default_Rotate_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_Rotate)
                , ( bp::arg("rotationMatrix") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("axis"), bp::arg("angle") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( double ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("theta") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Scale
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Scale_function_type)( double const,double const,double const ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_Scale_function_type)( double const,double const,double const ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "Scale"
                , Scale_function_type(&::AbstractMesh< 2, 2 >::Scale)
                , default_Scale_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_Scale)
                , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) );
        
        }
        { //::AbstractMesh< 2, 2 >::SetDistributedVectorFactory
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetDistributedVectorFactory"
                , SetDistributedVectorFactory_function_type(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
                , default_SetDistributedVectorFactory_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_SetDistributedVectorFactory)
                , ( bp::arg("pFactory") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::SetElementOwnerships
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*SetElementOwnerships_function_type)(  ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "SetElementOwnerships"
                , SetElementOwnerships_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::default_SetElementOwnerships ) );
        
        }
        { //::VertexMesh< 2, 2 >::SolveBoundaryElementMapping
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*SolveBoundaryElementMapping_function_type)( unsigned int ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "SolveBoundaryElementMapping"
                , SolveBoundaryElementMapping_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::SolveBoundaryElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::SolveElementMapping
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*SolveElementMapping_function_type)( unsigned int ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "SolveElementMapping"
                , SolveElementMapping_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::SolveElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 2, 2 >::SolveNodeMapping
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef unsigned int ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*SolveNodeMapping_function_type)( unsigned int ) const;
            
            MutableVertexMesh2_2_exposer.def( 
                "SolveNodeMapping"
                , SolveNodeMapping_function_type( &MutableVertexMesh_less__2_comma__2__greater__wrapper::default_SolveNodeMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef void ( MutableVertexMesh_less__2_comma__2__greater__wrapper::*default_Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "Translate"
                , Translate_function_type(&::AbstractMesh< 2, 2 >::Translate)
                , default_Translate_function_type(&MutableVertexMesh_less__2_comma__2__greater__wrapper::default_Translate)
                , ( bp::arg("rDisplacement") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef MutableVertexMesh< 2, 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( double const,double const,double const ) ;
            
            MutableVertexMesh2_2_exposer.def( 
                "Translate"
                , Translate_function_type( &::AbstractMesh< 2, 2 >::Translate )
                , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< MutableVertexMesh<2, 2> > >();
        bp::implicitly_convertible< boost::shared_ptr< MutableVertexMesh< 2, 2 > >, boost::shared_ptr< VertexMesh< 2, 2 > > >();
        bp::implicitly_convertible< boost::shared_ptr< MutableVertexMesh< 2, 2 > >, boost::shared_ptr< AbstractMesh< 2, 2 > > >();
    }

    { //::VertexMesh< 3, 3 >
        typedef bp::class_< VertexMesh_less__3_comma__3__greater__wrapper, bp::bases< AbstractMesh< 3, 3 > >, boost::noncopyable > VertexMesh3_3_exposer_t;
        VertexMesh3_3_exposer_t VertexMesh3_3_exposer = VertexMesh3_3_exposer_t( "VertexMesh3_3", bp::init< std::vector< Node<3> * >, std::vector< VertexElement<3, 3> * > >(( bp::arg("nodes"), bp::arg("vertexElements") )) );
        bp::scope VertexMesh3_3_scope( VertexMesh3_3_exposer );
        VertexMesh3_3_exposer.def( bp::init< TetrahedralMesh< 3, 3 > & >(( bp::arg("rMesh") )) );
        bp::implicitly_convertible< TetrahedralMesh< 3, 3 > &, VertexMesh< 3, 3 > >();
        VertexMesh3_3_exposer.def( bp::init< >() );
        { //::VertexMesh< 3, 3 >::CalculateAreaOfFace
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*CalculateAreaOfFace_function_type)( ::VertexElement< 2, 3 > * ) ;
            typedef double ( VertexMesh_less__3_comma__3__greater__wrapper::*default_CalculateAreaOfFace_function_type)( ::VertexElement< 2, 3 > * ) ;
            
            VertexMesh3_3_exposer.def( 
                "CalculateAreaOfFace"
                , CalculateAreaOfFace_function_type(&::VertexMesh< 3, 3 >::CalculateAreaOfFace)
                , default_CalculateAreaOfFace_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_CalculateAreaOfFace)
                , ( bp::arg("pFace") ) );
        
        }
        { //::VertexMesh< 3, 3 >::CalculateMomentsOfElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*CalculateMomentsOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( VertexMesh_less__3_comma__3__greater__wrapper::*default_CalculateMomentsOfElement_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "CalculateMomentsOfElement"
                , CalculateMomentsOfElement_function_type(&::VertexMesh< 3, 3 >::CalculateMomentsOfElement)
                , default_CalculateMomentsOfElement_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_CalculateMomentsOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::CalculateUnitNormalToFaceWithArea
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*CalculateUnitNormalToFaceWithArea_function_type)( ::VertexElement< 2, 3 > *,::boost::numeric::ublas::c_vector< double, 3 > & ) ;
            
            VertexMesh3_3_exposer.def( 
                "CalculateUnitNormalToFaceWithArea"
                , CalculateUnitNormalToFaceWithArea_function_type( &::VertexMesh< 3, 3 >::CalculateUnitNormalToFaceWithArea )
                , ( bp::arg("pFace"), bp::arg("rNormal") ) );
        
        }
        { //::VertexMesh< 3, 3 >::Clear
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Clear_function_type)(  ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_Clear_function_type)(  ) ;
            
            VertexMesh3_3_exposer.def( 
                "Clear"
                , Clear_function_type(&::VertexMesh< 3, 3 >::Clear)
                , default_Clear_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_Clear) );
        
        }
        { //::VertexMesh< 3, 3 >::ConstructFromMeshReader
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 3, 3 > & ) ;
            
            VertexMesh3_3_exposer.def( 
                "ConstructFromMeshReader"
                , ConstructFromMeshReader_function_type( &::VertexMesh< 3, 3 >::ConstructFromMeshReader )
                , ( bp::arg("rMeshReader") ) );
        
        }
        { //::VertexMesh< 3, 3 >::ElementIncludesPoint
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef bool ( VertexMesh_less__3_comma__3__greater__wrapper::*ElementIncludesPoint_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "ElementIncludesPoint"
                , ElementIncludesPoint_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::ElementIncludesPoint )
                , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GenerateVerticesFromElementCircumcentres
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*GenerateVerticesFromElementCircumcentres_function_type)( ::TetrahedralMesh< 3, 3 > & ) ;
            
            VertexMesh3_3_exposer.def( 
                "GenerateVerticesFromElementCircumcentres"
                , GenerateVerticesFromElementCircumcentres_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::GenerateVerticesFromElementCircumcentres )
                , ( bp::arg("rMesh") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetAreaGradientOfElementAtNode
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetAreaGradientOfElementAtNode_function_type)( ::VertexElement< 3, 3 > *,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetAreaGradientOfElementAtNode"
                , GetAreaGradientOfElementAtNode_function_type( &::VertexMesh< 3, 3 >::GetAreaGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetCentroidOfElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetCentroidOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetCentroidOfElement_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetCentroidOfElement"
                , GetCentroidOfElement_function_type(&::VertexMesh< 3, 3 >::GetCentroidOfElement)
                , default_GetCentroidOfElement_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetCentroidOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex"
                , GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex_function_type( &::VertexMesh< 3, 3 >::GetDelaunayNodeIndexCorrespondingToVoronoiElementIndex )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetEdgeLength
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*GetEdgeLength_function_type)( unsigned int,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetEdgeLength"
                , GetEdgeLength_function_type( &::VertexMesh< 3, 3 >::GetEdgeLength )
                , ( bp::arg("elementIndex1"), bp::arg("elementIndex2") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetElementIteratorBegin
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::VertexMesh< 3, 3 >::VertexElementIterator ( exported_class_t::*GetElementIteratorBegin_function_type)( bool ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetElementIteratorBegin"
                , GetElementIteratorBegin_function_type( &::VertexMesh< 3, 3 >::GetElementIteratorBegin )
                , ( bp::arg("skipDeletedElements")=(bool)(true) ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetElementIteratorEnd
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::VertexMesh< 3, 3 >::VertexElementIterator ( exported_class_t::*GetElementIteratorEnd_function_type)(  ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetElementIteratorEnd"
                , GetElementIteratorEnd_function_type( &::VertexMesh< 3, 3 >::GetElementIteratorEnd ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetElongationShapeFactorOfElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*GetElongationShapeFactorOfElement_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetElongationShapeFactorOfElement"
                , GetElongationShapeFactorOfElement_function_type( &::VertexMesh< 3, 3 >::GetElongationShapeFactorOfElement )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetLocalIndexForElementEdgeClosestToPoint
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*GetLocalIndexForElementEdgeClosestToPoint_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetLocalIndexForElementEdgeClosestToPoint"
                , GetLocalIndexForElementEdgeClosestToPoint_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::GetLocalIndexForElementEdgeClosestToPoint )
                , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNeighbouringElementIndices
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringElementIndices_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetNeighbouringElementIndices"
                , GetNeighbouringElementIndices_function_type( &::VertexMesh< 3, 3 >::GetNeighbouringElementIndices )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNeighbouringNodeIndices
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringNodeIndices_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetNeighbouringNodeIndices"
                , GetNeighbouringNodeIndices_function_type( &::VertexMesh< 3, 3 >::GetNeighbouringNodeIndices )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNeighbouringNodeNotAlsoInElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringNodeNotAlsoInElement_function_type)( unsigned int,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetNeighbouringNodeNotAlsoInElement"
                , GetNeighbouringNodeNotAlsoInElement_function_type( &::VertexMesh< 3, 3 >::GetNeighbouringNodeNotAlsoInElement )
                , ( bp::arg("nodeIndex"), bp::arg("elemIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNextEdgeGradientOfElementAtNode
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetNextEdgeGradientOfElementAtNode_function_type)( ::VertexElement< 3, 3 > *,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetNextEdgeGradientOfElementAtNode"
                , GetNextEdgeGradientOfElementAtNode_function_type( &::VertexMesh< 3, 3 >::GetNextEdgeGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNumAllElements
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllElements_function_type)(  ) const;
            
            VertexMesh3_3_exposer.def( 
                "GetNumAllElements"
                , GetNumAllElements_function_type( &::VertexMesh< 3, 3 >::GetNumAllElements ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNumElements
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumElements_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetNumElements_function_type)(  ) const;
            
            VertexMesh3_3_exposer.def( 
                "GetNumElements"
                , GetNumElements_function_type(&::VertexMesh< 3, 3 >::GetNumElements)
                , default_GetNumElements_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetNumElements) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNumFaces
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumFaces_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetNumFaces_function_type)(  ) const;
            
            VertexMesh3_3_exposer.def( 
                "GetNumFaces"
                , GetNumFaces_function_type(&::VertexMesh< 3, 3 >::GetNumFaces)
                , default_GetNumFaces_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetNumFaces) );
        
        }
        { //::VertexMesh< 3, 3 >::GetNumNodes
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodes_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetNumNodes_function_type)(  ) const;
            
            VertexMesh3_3_exposer.def( 
                "GetNumNodes"
                , GetNumNodes_function_type(&::VertexMesh< 3, 3 >::GetNumNodes)
                , default_GetNumNodes_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetNumNodes) );
        
        }
        { //::VertexMesh< 3, 3 >::GetPerimeterGradientOfElementAtNode
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetPerimeterGradientOfElementAtNode_function_type)( ::VertexElement< 3, 3 > *,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetPerimeterGradientOfElementAtNode"
                , GetPerimeterGradientOfElementAtNode_function_type( &::VertexMesh< 3, 3 >::GetPerimeterGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetPreviousEdgeGradientOfElementAtNode
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetPreviousEdgeGradientOfElementAtNode_function_type)( ::VertexElement< 3, 3 > *,unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetPreviousEdgeGradientOfElementAtNode"
                , GetPreviousEdgeGradientOfElementAtNode_function_type( &::VertexMesh< 3, 3 >::GetPreviousEdgeGradientOfElementAtNode )
                , ( bp::arg("pElement"), bp::arg("localIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetRosetteRankOfElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetRosetteRankOfElement_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetRosetteRankOfElement"
                , GetRosetteRankOfElement_function_type( &::VertexMesh< 3, 3 >::GetRosetteRankOfElement )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetShortAxisOfElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetShortAxisOfElement_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetShortAxisOfElement"
                , GetShortAxisOfElement_function_type( &::VertexMesh< 3, 3 >::GetShortAxisOfElement )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetSurfaceAreaOfElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            typedef double ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetSurfaceAreaOfElement"
                , GetSurfaceAreaOfElement_function_type(&::VertexMesh< 3, 3 >::GetSurfaceAreaOfElement)
                , default_GetSurfaceAreaOfElement_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetSurfaceAreaOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetVectorFromAtoB
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetVectorFromAtoB"
                , GetVectorFromAtoB_function_type(&::VertexMesh< 3, 3 >::GetVectorFromAtoB)
                , default_GetVectorFromAtoB_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetVectorFromAtoB)
                , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetVolumeOfElement
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*GetVolumeOfElement_function_type)( unsigned int ) ;
            typedef double ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetVolumeOfElement_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetVolumeOfElement"
                , GetVolumeOfElement_function_type(&::VertexMesh< 3, 3 >::GetVolumeOfElement)
                , default_GetVolumeOfElement_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetVolumeOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex_function_type)( unsigned int ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex"
                , GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex_function_type( &::VertexMesh< 3, 3 >::GetVoronoiElementIndexCorrespondingToDelaunayNodeIndex )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::VertexMesh< 3, 3 >::SolveBoundaryElementMapping
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*SolveBoundaryElementMapping_function_type)( unsigned int ) const;
            
            VertexMesh3_3_exposer.def( 
                "SolveBoundaryElementMapping"
                , SolveBoundaryElementMapping_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::SolveBoundaryElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::SolveElementMapping
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*SolveElementMapping_function_type)( unsigned int ) const;
            
            VertexMesh3_3_exposer.def( 
                "SolveElementMapping"
                , SolveElementMapping_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::SolveElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::VertexMesh< 3, 3 >::SolveNodeMapping
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*SolveNodeMapping_function_type)( unsigned int ) const;
            
            VertexMesh3_3_exposer.def( 
                "SolveNodeMapping"
                , SolveNodeMapping_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::default_SolveNodeMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::CalculateBoundingBox
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::ChasteCuboid< 3 > ( VertexMesh_less__3_comma__3__greater__wrapper::*CalculateBoundingBox_function_type)( ::std::vector< Node<3> * > const & ) const;
            
            VertexMesh3_3_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::CalculateBoundingBox )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::CalculateBoundingBox
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef ::ChasteCuboid< 3 > ( exported_class_t::*CalculateBoundingBox_function_type)(  ) const;
            typedef ::ChasteCuboid< 3 > ( VertexMesh_less__3_comma__3__greater__wrapper::*default_CalculateBoundingBox_function_type)(  ) const;
            
            VertexMesh3_3_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
                , default_CalculateBoundingBox_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_CalculateBoundingBox) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetNearestNodeIndex
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNearestNodeIndex_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetNearestNodeIndex_function_type)( ::ChastePoint< 3 > const & ) ;
            
            VertexMesh3_3_exposer.def( 
                "GetNearestNodeIndex"
                , GetNearestNodeIndex_function_type(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
                , default_GetNearestNodeIndex_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetNearestNodeIndex)
                , ( bp::arg("rTestPoint") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetNumAllNodes
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllNodes_function_type)(  ) const;
            typedef unsigned int ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetNumAllNodes_function_type)(  ) const;
            
            VertexMesh3_3_exposer.def( 
                "GetNumAllNodes"
                , GetNumAllNodes_function_type(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
                , default_GetNumAllNodes_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetNumAllNodes) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetWidth
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef double ( exported_class_t::*GetWidth_function_type)( unsigned int const & ) const;
            typedef double ( VertexMesh_less__3_comma__3__greater__wrapper::*default_GetWidth_function_type)( unsigned int const & ) const;
            
            VertexMesh3_3_exposer.def( 
                "GetWidth"
                , GetWidth_function_type(&::AbstractMesh< 3, 3 >::GetWidth)
                , default_GetWidth_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_GetWidth)
                , ( bp::arg("rDimension") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::PermuteNodes
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)(  ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_PermuteNodes_function_type)(  ) ;
            
            VertexMesh3_3_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type(&::AbstractMesh< 3, 3 >::PermuteNodes)
                , default_PermuteNodes_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_PermuteNodes) );
        
        }
        { //::AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            
            VertexMesh3_3_exposer.def( 
                "ReadNodesPerProcessorFile"
                , ReadNodesPerProcessorFile_function_type(&::AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile)
                , default_ReadNodesPerProcessorFile_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_ReadNodesPerProcessorFile)
                , ( bp::arg("rNodesPerProcessorFile") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::RefreshMesh
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*RefreshMesh_function_type)(  ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_RefreshMesh_function_type)(  ) ;
            
            VertexMesh3_3_exposer.def( 
                "RefreshMesh"
                , RefreshMesh_function_type(&::AbstractMesh< 3, 3 >::RefreshMesh)
                , default_RefreshMesh_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_RefreshMesh) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ) ;
            
            VertexMesh3_3_exposer.def( 
                "Rotate"
                , Rotate_function_type(&::AbstractMesh< 3, 3 >::Rotate)
                , default_Rotate_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_Rotate)
                , ( bp::arg("rotationMatrix") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            VertexMesh3_3_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 3, 3 >::Rotate )
                , ( bp::arg("axis"), bp::arg("angle") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( double ) ;
            
            VertexMesh3_3_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 3, 3 >::Rotate )
                , ( bp::arg("theta") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Scale
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Scale_function_type)( double const,double const,double const ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_Scale_function_type)( double const,double const,double const ) ;
            
            VertexMesh3_3_exposer.def( 
                "Scale"
                , Scale_function_type(&::AbstractMesh< 3, 3 >::Scale)
                , default_Scale_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_Scale)
                , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) );
        
        }
        { //::AbstractMesh< 3, 3 >::SetDistributedVectorFactory
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            
            VertexMesh3_3_exposer.def( 
                "SetDistributedVectorFactory"
                , SetDistributedVectorFactory_function_type(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
                , default_SetDistributedVectorFactory_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_SetDistributedVectorFactory)
                , ( bp::arg("pFactory") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::SetElementOwnerships
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*SetElementOwnerships_function_type)(  ) ;
            
            VertexMesh3_3_exposer.def( 
                "SetElementOwnerships"
                , SetElementOwnerships_function_type( &VertexMesh_less__3_comma__3__greater__wrapper::default_SetElementOwnerships ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Translate
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            typedef void ( VertexMesh_less__3_comma__3__greater__wrapper::*default_Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            
            VertexMesh3_3_exposer.def( 
                "Translate"
                , Translate_function_type(&::AbstractMesh< 3, 3 >::Translate)
                , default_Translate_function_type(&VertexMesh_less__3_comma__3__greater__wrapper::default_Translate)
                , ( bp::arg("rDisplacement") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Translate
        
            typedef VertexMesh< 3, 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( double const,double const,double const ) ;
            
            VertexMesh3_3_exposer.def( 
                "Translate"
                , Translate_function_type( &::AbstractMesh< 3, 3 >::Translate )
                , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );
        
        }
    }

    bp::class_< MutableVertexMesh_less__3_comma__3__greater__wrapper, bp::bases< VertexMesh< 3, 3 > >, boost::noncopyable >( "MutableVertexMesh3_3", bp::init< std::vector< Node<3> * >, std::vector< VertexElement<3, 3> * >, bp::optional< double, double, double, double, double, double > >(( bp::arg("nodes"), bp::arg("vertexElements"), bp::arg("cellRearrangementThreshold")=0.01, bp::arg("t2Threshold")=0.001, bp::arg("cellRearrangementRatio")=1.5, bp::arg("protorosetteFormationProbability")=0., bp::arg("protorosetteResolutionProbabilityPerTimestep")=0., bp::arg("rosetteResolutionProbabilityPerTimestep")=0. )) )    
        .def( bp::init< >() )    
        .def( 
            "AddElement"
            , (unsigned int ( ::MutableVertexMesh<3, 3>::* )( ::VertexElement< 3, 3 > * ))( &::MutableVertexMesh< 3, 3 >::AddElement )
            , ( bp::arg("pNewElement") ) )    
        .def( 
            "AddNode"
            , (unsigned int ( ::MutableVertexMesh<3, 3>::* )( ::Node< 3 > * ))( &::MutableVertexMesh< 3, 3 >::AddNode )
            , ( bp::arg("pNewNode") ) )    
        .def( 
            "CheckForIntersections"
            , (bool ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::CheckForIntersections) )    
        .def( 
            "CheckForRosettes"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::CheckForRosettes) )    
        .def( 
            "CheckForSwapsFromShortEdges"
            , (bool ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::CheckForSwapsFromShortEdges) )    
        .def( 
            "CheckForT2Swaps"
            , (bool ( ::MutableVertexMesh<3, 3>::* )( ::VertexElementMap & ))( &::MutableVertexMesh< 3, 3 >::CheckForT2Swaps )
            , ( bp::arg("rElementMap") ) )    
        .def( 
            "Clear"
            , (void ( ::MutableVertexMesh<3, 3>::* )(  ))(&::MutableVertexMesh< 3, 3 >::Clear)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_Clear) )    
        .def( 
            "ClearLocationsOfT1Swaps"
            , (void ( ::MutableVertexMesh<3, 3>::* )(  ))( &::MutableVertexMesh< 3, 3 >::ClearLocationsOfT1Swaps ) )    
        .def( 
            "ClearLocationsOfT3Swaps"
            , (void ( ::MutableVertexMesh<3, 3>::* )(  ))( &::MutableVertexMesh< 3, 3 >::ClearLocationsOfT3Swaps ) )    
        .def( 
            "DeleteElementPriorToReMesh"
            , (void ( ::MutableVertexMesh<3, 3>::* )( unsigned int ))( &::MutableVertexMesh< 3, 3 >::DeleteElementPriorToReMesh )
            , ( bp::arg("index") ) )    
        .def( 
            "DeleteNodePriorToReMesh"
            , (void ( ::MutableVertexMesh<3, 3>::* )( unsigned int ))( &::MutableVertexMesh< 3, 3 >::DeleteNodePriorToReMesh )
            , ( bp::arg("index") ) )    
        .def( 
            "DivideEdge"
            , (void ( ::MutableVertexMesh<3, 3>::* )( ::Node< 3 > *,::Node< 3 > * ))( &::MutableVertexMesh< 3, 3 >::DivideEdge )
            , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) )    
        .def( 
            "DivideElement"
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::VertexElement<3, 3> *,unsigned int,unsigned int,bool ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::DivideElement)
            , ( bp::arg("pElement"), bp::arg("nodeAIndex"), bp::arg("nodeBIndex"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) )    
        .def( 
            "DivideElementAlongGivenAxis"
            , (unsigned int ( ::MutableVertexMesh<3, 3>::* )( ::VertexElement< 3, 3 > *,::boost::numeric::ublas::c_vector< double, 3 >,bool ))( &::MutableVertexMesh< 3, 3 >::DivideElementAlongGivenAxis )
            , ( bp::arg("pElement"), bp::arg("axisOfDivision"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) )    
        .def( 
            "DivideElementAlongShortAxis"
            , (unsigned int ( ::MutableVertexMesh<3, 3>::* )( ::VertexElement< 3, 3 > *,bool ))( &::MutableVertexMesh< 3, 3 >::DivideElementAlongShortAxis )
            , ( bp::arg("pElement"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) )    
        .def( 
            "GetCellRearrangementRatio"
            , (double ( ::MutableVertexMesh<3, 3>::* )(  )const)( &::MutableVertexMesh< 3, 3 >::GetCellRearrangementRatio ) )    
        .def( 
            "GetCellRearrangementThreshold"
            , (double ( ::MutableVertexMesh<3, 3>::* )(  )const)( &::MutableVertexMesh< 3, 3 >::GetCellRearrangementThreshold ) )    
        .def( 
            "GetCheckForInternalIntersections"
            , (bool ( ::MutableVertexMesh<3, 3>::* )(  )const)( &::MutableVertexMesh< 3, 3 >::GetCheckForInternalIntersections ) )    
        .def( 
            "GetLastT2SwapLocation"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::MutableVertexMesh<3, 3>::* )(  ))( &::MutableVertexMesh< 3, 3 >::GetLastT2SwapLocation ) )    
        .def( 
            "GetLocationsOfT1Swaps"
            , (::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( ::MutableVertexMesh<3, 3>::* )(  ))( &::MutableVertexMesh< 3, 3 >::GetLocationsOfT1Swaps ) )    
        .def( 
            "GetLocationsOfT3Swaps"
            , (::std::vector< boost::numeric::ublas::c_vector<double, 3> > ( ::MutableVertexMesh<3, 3>::* )(  ))( &::MutableVertexMesh< 3, 3 >::GetLocationsOfT3Swaps ) )    
        .def( 
            "GetNumElements"
            , (unsigned int ( ::MutableVertexMesh<3, 3>::* )(  )const)(&::MutableVertexMesh< 3, 3 >::GetNumElements)
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetNumElements) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::MutableVertexMesh<3, 3>::* )(  )const)(&::MutableVertexMesh< 3, 3 >::GetNumNodes)
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetProtorosetteFormationProbability"
            , (double ( ::MutableVertexMesh<3, 3>::* )(  )const)( &::MutableVertexMesh< 3, 3 >::GetProtorosetteFormationProbability ) )    
        .def( 
            "GetProtorosetteResolutionProbabilityPerTimestep"
            , (double ( ::MutableVertexMesh<3, 3>::* )(  )const)( &::MutableVertexMesh< 3, 3 >::GetProtorosetteResolutionProbabilityPerTimestep ) )    
        .def( 
            "GetRosetteResolutionProbabilityPerTimestep"
            , (double ( ::MutableVertexMesh<3, 3>::* )(  )const)( &::MutableVertexMesh< 3, 3 >::GetRosetteResolutionProbabilityPerTimestep ) )    
        .def( 
            "GetT2Threshold"
            , (double ( ::MutableVertexMesh<3, 3>::* )(  )const)( &::MutableVertexMesh< 3, 3 >::GetT2Threshold ) )    
        .def( 
            "HandleHighOrderJunctions"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node< 3 > *,::Node< 3 > * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_HandleHighOrderJunctions)
            , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) )    
        .def( 
            "IdentifySwapType"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node< 3 > *,::Node< 3 > * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_IdentifySwapType)
            , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) )    
        .def( 
            "PerformIntersectionSwap"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> *,unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformIntersectionSwap)
            , ( bp::arg("pNode"), bp::arg("elementIndex") ) )    
        .def( 
            "PerformNodeMerge"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> *,::Node<3> * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformNodeMerge)
            , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) )    
        .def( 
            "PerformProtorosetteResolution"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformProtorosetteResolution)
            , ( bp::arg("pProtorosetteNode") ) )    
        .def( 
            "PerformRosetteRankDecrease"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformRosetteRankDecrease)
            , ( bp::arg("pRosetteNode") ) )    
        .def( 
            "PerformRosetteRankIncrease"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> *,::Node<3> * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformRosetteRankIncrease)
            , ( bp::arg("pNodeA"), bp::arg("pNodeB") ) )    
        .def( 
            "PerformT1Swap"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> *,::Node<3> *,::std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformT1Swap)
            , ( bp::arg("pNodeA"), bp::arg("pNodeB"), bp::arg("rElementsContainingNodes") ) )    
        .def( 
            "PerformT2Swap"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::VertexElement<3, 3> & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformT2Swap)
            , ( bp::arg("rElement") ) )    
        .def( 
            "PerformT3Swap"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> *,unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformT3Swap)
            , ( bp::arg("pNode"), bp::arg("elementIndex") ) )    
        .def( 
            "PerformVoidRemoval"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::Node<3> *,::Node<3> *,::Node<3> * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::PerformVoidRemoval)
            , ( bp::arg("pNodeA"), bp::arg("pNodeB"), bp::arg("pNodeC") ) )    
        .def( 
            "ReMesh"
            , (void ( ::MutableVertexMesh<3, 3>::* )( ::VertexElementMap & ))(&::MutableVertexMesh< 3, 3 >::ReMesh)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::VertexElementMap & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_ReMesh)
            , ( bp::arg("rElementMap") ) )    
        .def( 
            "ReMesh"
            , (void ( ::MutableVertexMesh<3, 3>::* )(  ))( &::MutableVertexMesh< 3, 3 >::ReMesh ) )    
        .def( 
            "RemoveDeletedNodes"
            , (void ( ::MutableVertexMesh<3, 3>::* )(  ))( &::MutableVertexMesh< 3, 3 >::RemoveDeletedNodes ) )    
        .def( 
            "RemoveDeletedNodesAndElements"
            , (void ( ::MutableVertexMesh<3, 3>::* )( ::VertexElementMap & ))( &::MutableVertexMesh< 3, 3 >::RemoveDeletedNodesAndElements )
            , ( bp::arg("rElementMap") ) )    
        .def( 
            "SetCellRearrangementRatio"
            , (void ( ::MutableVertexMesh<3, 3>::* )( double ))( &::MutableVertexMesh< 3, 3 >::SetCellRearrangementRatio )
            , ( bp::arg("cellRearrangementRatio") ) )    
        .def( 
            "SetCellRearrangementThreshold"
            , (void ( ::MutableVertexMesh<3, 3>::* )( double ))( &::MutableVertexMesh< 3, 3 >::SetCellRearrangementThreshold )
            , ( bp::arg("cellRearrangementThreshold") ) )    
        .def( 
            "SetCheckForInternalIntersections"
            , (void ( ::MutableVertexMesh<3, 3>::* )( bool ))( &::MutableVertexMesh< 3, 3 >::SetCheckForInternalIntersections )
            , ( bp::arg("checkForInternalIntersections") ) )    
        .def( 
            "SetNode"
            , (void ( ::MutableVertexMesh<3, 3>::* )( unsigned int,::ChastePoint< 3 > ))(&::MutableVertexMesh< 3, 3 >::SetNode)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,::ChastePoint< 3 > ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_SetNode)
            , ( bp::arg("nodeIndex"), bp::arg("point") ) )    
        .def( 
            "SetProtorosetteFormationProbability"
            , (void ( ::MutableVertexMesh<3, 3>::* )( double ))( &::MutableVertexMesh< 3, 3 >::SetProtorosetteFormationProbability )
            , ( bp::arg("protorosetteFormationProbability") ) )    
        .def( 
            "SetProtorosetteResolutionProbabilityPerTimestep"
            , (void ( ::MutableVertexMesh<3, 3>::* )( double ))( &::MutableVertexMesh< 3, 3 >::SetProtorosetteResolutionProbabilityPerTimestep )
            , ( bp::arg("protorosetteResolutionProbabilityPerTimestep") ) )    
        .def( 
            "SetRosetteResolutionProbabilityPerTimestep"
            , (void ( ::MutableVertexMesh<3, 3>::* )( double ))( &::MutableVertexMesh< 3, 3 >::SetRosetteResolutionProbabilityPerTimestep )
            , ( bp::arg("rosetteResolutionProbabilityPerTimestep") ) )    
        .def( 
            "SetT2Threshold"
            , (void ( ::MutableVertexMesh<3, 3>::* )( double ))( &::MutableVertexMesh< 3, 3 >::SetT2Threshold )
            , ( bp::arg("t2Threshold") ) )    
        .def( 
            "WidenEdgeOrCorrectIntersectionLocationIfNecessary"
            , (::boost::numeric::ublas::c_vector<double, 2> ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int,unsigned int,::boost::numeric::ublas::c_vector<double, 2> ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::WidenEdgeOrCorrectIntersectionLocationIfNecessary)
            , ( bp::arg("indexA"), bp::arg("indexB"), bp::arg("intersection") ) )    
        .def( 
            "CalculateAreaOfFace"
            , (double ( ::VertexMesh<3, 3>::* )( ::VertexElement< 2, 3 > * ))(&::VertexMesh< 3, 3 >::CalculateAreaOfFace)
            , (double ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::VertexElement< 2, 3 > * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_CalculateAreaOfFace)
            , ( bp::arg("pFace") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<3> ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::std::vector<Node<3> *, std::allocator<Node<3> *> > const & )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 3 > ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
            , (::ChasteCuboid< 3 > ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "CalculateMomentsOfElement"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::VertexMesh<3, 3>::* )( unsigned int ))(&::VertexMesh< 3, 3 >::CalculateMomentsOfElement)
            , (::boost::numeric::ublas::c_vector< double, 3 > ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_CalculateMomentsOfElement)
            , ( bp::arg("index") ) )    
        .def( 
            "ElementIncludesPoint"
            , (bool ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector<double, 3> const &,unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::ElementIncludesPoint)
            , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) )    
        .def( 
            "GenerateVerticesFromElementCircumcentres"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::TetrahedralMesh<3, 3> & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::GenerateVerticesFromElementCircumcentres)
            , ( bp::arg("rMesh") ) )    
        .def( 
            "GetCentroidOfElement"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::VertexMesh<3, 3>::* )( unsigned int ))(&::VertexMesh< 3, 3 >::GetCentroidOfElement)
            , (::boost::numeric::ublas::c_vector< double, 3 > ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetCentroidOfElement)
            , ( bp::arg("index") ) )    
        .def( 
            "GetLocalIndexForElementEdgeClosestToPoint"
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector<double, 3> const &,unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::GetLocalIndexForElementEdgeClosestToPoint)
            , ( bp::arg("rTestPoint"), bp::arg("elementIndex") ) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )( ::ChastePoint< 3 > const & ))(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::ChastePoint< 3 > const & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumFaces"
            , (unsigned int ( ::VertexMesh<3, 3>::* )(  )const)(&::VertexMesh< 3, 3 >::GetNumFaces)
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetNumFaces) )    
        .def( 
            "GetSurfaceAreaOfElement"
            , (double ( ::VertexMesh<3, 3>::* )( unsigned int ))(&::VertexMesh< 3, 3 >::GetSurfaceAreaOfElement)
            , (double ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetSurfaceAreaOfElement)
            , ( bp::arg("index") ) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::VertexMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::VertexMesh< 3, 3 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 3 > ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetVolumeOfElement"
            , (double ( ::VertexMesh<3, 3>::* )( unsigned int ))(&::VertexMesh< 3, 3 >::GetVolumeOfElement)
            , (double ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetVolumeOfElement)
            , ( bp::arg("index") ) )    
        .def( 
            "GetWidth"
            , (double ( ::AbstractMesh<3, 3>::* )( unsigned int const & )const)(&::AbstractMesh< 3, 3 >::GetWidth)
            , (double ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int const & )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::AbstractMesh<3, 3>::* )(  ))(&::AbstractMesh< 3, 3 >::PermuteNodes)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::AbstractMesh<3, 3>::* )( ::std::string const & ))(&::AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::std::string const & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshMesh"
            , (void ( ::AbstractMesh<3, 3>::* )(  ))(&::AbstractMesh< 3, 3 >::RefreshMesh)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&::AbstractMesh< 3, 3 >::Rotate)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))(&::AbstractMesh< 3, 3 >::Scale)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( double const,double const,double const ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<3, 3>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::DistributedVectorFactory * ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )(  ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "SolveBoundaryElementMapping"
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::SolveBoundaryElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveElementMapping"
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::SolveElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveNodeMapping"
            , (unsigned int ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( unsigned int )const)(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_SolveNodeMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::Translate)
            , (void ( MutableVertexMesh_less__3_comma__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&MutableVertexMesh_less__3_comma__3__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))( &::AbstractMesh< 3, 3 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    { //::Node< 2 >
        typedef bp::class_< Node< 2 > > Node2_exposer_t;
        Node2_exposer_t Node2_exposer = Node2_exposer_t( "Node2", bp::init< unsigned int, ChastePoint< 2 >, bp::optional< bool > >(( bp::arg("index"), bp::arg("point"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        bp::scope Node2_scope( Node2_exposer );
        Node2_exposer.def( bp::init< unsigned int, std::vector< double >, bp::optional< bool > >(( bp::arg("index"), bp::arg("coords"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        Node2_exposer.def( bp::init< unsigned int, boost::numeric::ublas::c_vector< double, 2 >, bp::optional< bool > >(( bp::arg("index"), bp::arg("location"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        Node2_exposer.def( bp::init< unsigned int, bp::optional< bool, double, double, double > >(( bp::arg("index"), bp::arg("isBoundaryNode")=(bool)(false), bp::arg("v1")=0, bp::arg("v2")=0, bp::arg("v3")=0 )) );
        bp::implicitly_convertible< unsigned int, Node< 2 > >();
        Node2_exposer.def( bp::init< unsigned int, double *, bp::optional< bool > >(( bp::arg("index"), bp::arg("location"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        { //::Node< 2 >::AddAppliedForceContribution
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddAppliedForceContribution_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > & ) ;
            
            Node2_exposer.def( 
                "AddAppliedForceContribution"
                , AddAppliedForceContribution_function_type( &::Node< 2 >::AddAppliedForceContribution )
                , ( bp::arg("forceContribution") ) );
        
        }
        { //::Node< 2 >::AddBoundaryElement
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddBoundaryElement_function_type)( unsigned int ) ;
            
            Node2_exposer.def( 
                "AddBoundaryElement"
                , AddBoundaryElement_function_type( &::Node< 2 >::AddBoundaryElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 2 >::AddElement
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddElement_function_type)( unsigned int ) ;
            
            Node2_exposer.def( 
                "AddElement"
                , AddElement_function_type( &::Node< 2 >::AddElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 2 >::AddNeighbour
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddNeighbour_function_type)( unsigned int ) ;
            
            Node2_exposer.def( 
                "AddNeighbour"
                , AddNeighbour_function_type( &::Node< 2 >::AddNeighbour )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 2 >::AddNodeAttribute
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*AddNodeAttribute_function_type)( double ) ;
            
            Node2_exposer.def( 
                "AddNodeAttribute"
                , AddNodeAttribute_function_type( &::Node< 2 >::AddNodeAttribute )
                , ( bp::arg("attribute") ) );
        
        }
        { //::Node< 2 >::ClearAppliedForce
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*ClearAppliedForce_function_type)(  ) ;
            
            Node2_exposer.def( 
                "ClearAppliedForce"
                , ClearAppliedForce_function_type( &::Node< 2 >::ClearAppliedForce ) );
        
        }
        { //::Node< 2 >::ClearNeighbours
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*ClearNeighbours_function_type)(  ) ;
            
            Node2_exposer.def( 
                "ClearNeighbours"
                , ClearNeighbours_function_type( &::Node< 2 >::ClearNeighbours ) );
        
        }
        { //::Node< 2 >::ContainingBoundaryElementsBegin
        
            typedef Node< 2 > exported_class_t;
            typedef ::Node< 2 >::ContainingBoundaryElementIterator ( exported_class_t::*ContainingBoundaryElementsBegin_function_type)(  ) const;
            
            Node2_exposer.def( 
                "ContainingBoundaryElementsBegin"
                , ContainingBoundaryElementsBegin_function_type( &::Node< 2 >::ContainingBoundaryElementsBegin ) );
        
        }
        { //::Node< 2 >::ContainingBoundaryElementsEnd
        
            typedef Node< 2 > exported_class_t;
            typedef ::Node< 2 >::ContainingBoundaryElementIterator ( exported_class_t::*ContainingBoundaryElementsEnd_function_type)(  ) const;
            
            Node2_exposer.def( 
                "ContainingBoundaryElementsEnd"
                , ContainingBoundaryElementsEnd_function_type( &::Node< 2 >::ContainingBoundaryElementsEnd ) );
        
        }
        { //::Node< 2 >::ContainingElementsBegin
        
            typedef Node< 2 > exported_class_t;
            typedef ::Node< 2 >::ContainingElementIterator ( exported_class_t::*ContainingElementsBegin_function_type)(  ) const;
            
            Node2_exposer.def( 
                "ContainingElementsBegin"
                , ContainingElementsBegin_function_type( &::Node< 2 >::ContainingElementsBegin ) );
        
        }
        { //::Node< 2 >::ContainingElementsEnd
        
            typedef Node< 2 > exported_class_t;
            typedef ::Node< 2 >::ContainingElementIterator ( exported_class_t::*ContainingElementsEnd_function_type)(  ) const;
            
            Node2_exposer.def( 
                "ContainingElementsEnd"
                , ContainingElementsEnd_function_type( &::Node< 2 >::ContainingElementsEnd ) );
        
        }
        { //::Node< 2 >::GetIndex
        
            typedef Node< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetIndex_function_type)(  ) const;
            
            Node2_exposer.def( 
                "GetIndex"
                , GetIndex_function_type( &::Node< 2 >::GetIndex ) );
        
        }
        { //::Node< 2 >::GetNeighboursSetUp
        
            typedef Node< 2 > exported_class_t;
            typedef bool ( exported_class_t::*GetNeighboursSetUp_function_type)(  ) ;
            
            Node2_exposer.def( 
                "GetNeighboursSetUp"
                , GetNeighboursSetUp_function_type( &::Node< 2 >::GetNeighboursSetUp ) );
        
        }
        { //::Node< 2 >::GetNumBoundaryElements
        
            typedef Node< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumBoundaryElements_function_type)(  ) const;
            
            Node2_exposer.def( 
                "GetNumBoundaryElements"
                , GetNumBoundaryElements_function_type( &::Node< 2 >::GetNumBoundaryElements ) );
        
        }
        { //::Node< 2 >::GetNumContainingElements
        
            typedef Node< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumContainingElements_function_type)(  ) const;
            
            Node2_exposer.def( 
                "GetNumContainingElements"
                , GetNumContainingElements_function_type( &::Node< 2 >::GetNumContainingElements ) );
        
        }
        { //::Node< 2 >::GetNumNodeAttributes
        
            typedef Node< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodeAttributes_function_type)(  ) ;
            
            Node2_exposer.def( 
                "GetNumNodeAttributes"
                , GetNumNodeAttributes_function_type( &::Node< 2 >::GetNumNodeAttributes ) );
        
        }
        { //::Node< 2 >::GetPoint
        
            typedef Node< 2 > exported_class_t;
            typedef ::ChastePoint< 2 > ( exported_class_t::*GetPoint_function_type)(  ) const;
            
            Node2_exposer.def( 
                "GetPoint"
                , GetPoint_function_type( &::Node< 2 >::GetPoint ) );
        
        }
        { //::Node< 2 >::GetRadius
        
            typedef Node< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetRadius_function_type)(  ) ;
            
            Node2_exposer.def( 
                "GetRadius"
                , GetRadius_function_type( &::Node< 2 >::GetRadius ) );
        
        }
        { //::Node< 2 >::GetRegion
        
            typedef Node< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetRegion_function_type)(  ) const;
            
            Node2_exposer.def( 
                "GetRegion"
                , GetRegion_function_type( &::Node< 2 >::GetRegion ) );
        
        }
        { //::Node< 2 >::HasNodeAttributes
        
            typedef Node< 2 > exported_class_t;
            typedef bool ( exported_class_t::*HasNodeAttributes_function_type)(  ) ;
            
            Node2_exposer.def( 
                "HasNodeAttributes"
                , HasNodeAttributes_function_type( &::Node< 2 >::HasNodeAttributes ) );
        
        }
        { //::Node< 2 >::IsBoundaryNode
        
            typedef Node< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsBoundaryNode_function_type)(  ) const;
            
            Node2_exposer.def( 
                "IsBoundaryNode"
                , IsBoundaryNode_function_type( &::Node< 2 >::IsBoundaryNode ) );
        
        }
        { //::Node< 2 >::IsDeleted
        
            typedef Node< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsDeleted_function_type)(  ) const;
            
            Node2_exposer.def( 
                "IsDeleted"
                , IsDeleted_function_type( &::Node< 2 >::IsDeleted ) );
        
        }
        { //::Node< 2 >::IsInternal
        
            typedef Node< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsInternal_function_type)(  ) const;
            
            Node2_exposer.def( 
                "IsInternal"
                , IsInternal_function_type( &::Node< 2 >::IsInternal ) );
        
        }
        { //::Node< 2 >::IsParticle
        
            typedef Node< 2 > exported_class_t;
            typedef bool ( exported_class_t::*IsParticle_function_type)(  ) ;
            
            Node2_exposer.def( 
                "IsParticle"
                , IsParticle_function_type( &::Node< 2 >::IsParticle ) );
        
        }
        { //::Node< 2 >::MarkAsDeleted
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*MarkAsDeleted_function_type)(  ) ;
            
            Node2_exposer.def( 
                "MarkAsDeleted"
                , MarkAsDeleted_function_type( &::Node< 2 >::MarkAsDeleted ) );
        
        }
        { //::Node< 2 >::MarkAsInternal
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*MarkAsInternal_function_type)(  ) ;
            
            Node2_exposer.def( 
                "MarkAsInternal"
                , MarkAsInternal_function_type( &::Node< 2 >::MarkAsInternal ) );
        
        }
        { //::Node< 2 >::NeighboursIsEmpty
        
            typedef Node< 2 > exported_class_t;
            typedef bool ( exported_class_t::*NeighboursIsEmpty_function_type)(  ) ;
            
            Node2_exposer.def( 
                "NeighboursIsEmpty"
                , NeighboursIsEmpty_function_type( &::Node< 2 >::NeighboursIsEmpty ) );
        
        }
        { //::Node< 2 >::RemoveBoundaryElement
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveBoundaryElement_function_type)( unsigned int ) ;
            
            Node2_exposer.def( 
                "RemoveBoundaryElement"
                , RemoveBoundaryElement_function_type( &::Node< 2 >::RemoveBoundaryElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 2 >::RemoveDuplicateNeighbours
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveDuplicateNeighbours_function_type)(  ) ;
            
            Node2_exposer.def( 
                "RemoveDuplicateNeighbours"
                , RemoveDuplicateNeighbours_function_type( &::Node< 2 >::RemoveDuplicateNeighbours ) );
        
        }
        { //::Node< 2 >::RemoveElement
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveElement_function_type)( unsigned int ) ;
            
            Node2_exposer.def( 
                "RemoveElement"
                , RemoveElement_function_type( &::Node< 2 >::RemoveElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 2 >::SetAsBoundaryNode
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetAsBoundaryNode_function_type)( bool ) ;
            
            Node2_exposer.def( 
                "SetAsBoundaryNode"
                , SetAsBoundaryNode_function_type( &::Node< 2 >::SetAsBoundaryNode )
                , ( bp::arg("value")=(bool)(true) ) );
        
        }
        { //::Node< 2 >::SetIndex
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIndex_function_type)( unsigned int ) ;
            
            Node2_exposer.def( 
                "SetIndex"
                , SetIndex_function_type( &::Node< 2 >::SetIndex )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 2 >::SetIsParticle
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetIsParticle_function_type)( bool ) ;
            
            Node2_exposer.def( 
                "SetIsParticle"
                , SetIsParticle_function_type( &::Node< 2 >::SetIsParticle )
                , ( bp::arg("isParticle") ) );
        
        }
        { //::Node< 2 >::SetNeighboursSetUp
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetNeighboursSetUp_function_type)( bool ) ;
            
            Node2_exposer.def( 
                "SetNeighboursSetUp"
                , SetNeighboursSetUp_function_type( &::Node< 2 >::SetNeighboursSetUp )
                , ( bp::arg("flag") ) );
        
        }
        { //::Node< 2 >::SetPoint
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetPoint_function_type)( ::ChastePoint< 2 > ) ;
            
            Node2_exposer.def( 
                "SetPoint"
                , SetPoint_function_type( &::Node< 2 >::SetPoint )
                , ( bp::arg("point") ) );
        
        }
        { //::Node< 2 >::SetRadius
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( double ) ;
            
            Node2_exposer.def( 
                "SetRadius"
                , SetRadius_function_type( &::Node< 2 >::SetRadius )
                , ( bp::arg("radius") ) );
        
        }
        { //::Node< 2 >::SetRegion
        
            typedef Node< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetRegion_function_type)( unsigned int ) ;
            
            Node2_exposer.def( 
                "SetRegion"
                , SetRegion_function_type( &::Node< 2 >::SetRegion )
                , ( bp::arg("region") ) );
        
        }
        { //::Node< 2 >::rGetLocation
        
            typedef Node< 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > const & ( exported_class_t::*rGetLocation_function_type)(  ) const;
            
            Node2_exposer.def( 
                "rGetLocation"
                , rGetLocation_function_type( &::Node< 2 >::rGetLocation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< Node<2> > >();
    }

    { //::Node< 3 >
        typedef bp::class_< Node< 3 > > Node3_exposer_t;
        Node3_exposer_t Node3_exposer = Node3_exposer_t( "Node3", bp::init< unsigned int, ChastePoint< 3 >, bp::optional< bool > >(( bp::arg("index"), bp::arg("point"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        bp::scope Node3_scope( Node3_exposer );
        Node3_exposer.def( bp::init< unsigned int, std::vector< double >, bp::optional< bool > >(( bp::arg("index"), bp::arg("coords"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        Node3_exposer.def( bp::init< unsigned int, boost::numeric::ublas::c_vector< double, 3 >, bp::optional< bool > >(( bp::arg("index"), bp::arg("location"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        Node3_exposer.def( bp::init< unsigned int, bp::optional< bool, double, double, double > >(( bp::arg("index"), bp::arg("isBoundaryNode")=(bool)(false), bp::arg("v1")=0, bp::arg("v2")=0, bp::arg("v3")=0 )) );
        bp::implicitly_convertible< unsigned int, Node< 3 > >();
        Node3_exposer.def( bp::init< unsigned int, double *, bp::optional< bool > >(( bp::arg("index"), bp::arg("location"), bp::arg("isBoundaryNode")=(bool)(false) )) );
        { //::Node< 3 >::AddAppliedForceContribution
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddAppliedForceContribution_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > & ) ;
            
            Node3_exposer.def( 
                "AddAppliedForceContribution"
                , AddAppliedForceContribution_function_type( &::Node< 3 >::AddAppliedForceContribution )
                , ( bp::arg("forceContribution") ) );
        
        }
        { //::Node< 3 >::AddBoundaryElement
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddBoundaryElement_function_type)( unsigned int ) ;
            
            Node3_exposer.def( 
                "AddBoundaryElement"
                , AddBoundaryElement_function_type( &::Node< 3 >::AddBoundaryElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 3 >::AddElement
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddElement_function_type)( unsigned int ) ;
            
            Node3_exposer.def( 
                "AddElement"
                , AddElement_function_type( &::Node< 3 >::AddElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 3 >::AddNeighbour
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddNeighbour_function_type)( unsigned int ) ;
            
            Node3_exposer.def( 
                "AddNeighbour"
                , AddNeighbour_function_type( &::Node< 3 >::AddNeighbour )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 3 >::AddNodeAttribute
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*AddNodeAttribute_function_type)( double ) ;
            
            Node3_exposer.def( 
                "AddNodeAttribute"
                , AddNodeAttribute_function_type( &::Node< 3 >::AddNodeAttribute )
                , ( bp::arg("attribute") ) );
        
        }
        { //::Node< 3 >::ClearAppliedForce
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*ClearAppliedForce_function_type)(  ) ;
            
            Node3_exposer.def( 
                "ClearAppliedForce"
                , ClearAppliedForce_function_type( &::Node< 3 >::ClearAppliedForce ) );
        
        }
        { //::Node< 3 >::ClearNeighbours
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*ClearNeighbours_function_type)(  ) ;
            
            Node3_exposer.def( 
                "ClearNeighbours"
                , ClearNeighbours_function_type( &::Node< 3 >::ClearNeighbours ) );
        
        }
        { //::Node< 3 >::ContainingBoundaryElementsBegin
        
            typedef Node< 3 > exported_class_t;
            typedef ::Node< 3 >::ContainingBoundaryElementIterator ( exported_class_t::*ContainingBoundaryElementsBegin_function_type)(  ) const;
            
            Node3_exposer.def( 
                "ContainingBoundaryElementsBegin"
                , ContainingBoundaryElementsBegin_function_type( &::Node< 3 >::ContainingBoundaryElementsBegin ) );
        
        }
        { //::Node< 3 >::ContainingBoundaryElementsEnd
        
            typedef Node< 3 > exported_class_t;
            typedef ::Node< 3 >::ContainingBoundaryElementIterator ( exported_class_t::*ContainingBoundaryElementsEnd_function_type)(  ) const;
            
            Node3_exposer.def( 
                "ContainingBoundaryElementsEnd"
                , ContainingBoundaryElementsEnd_function_type( &::Node< 3 >::ContainingBoundaryElementsEnd ) );
        
        }
        { //::Node< 3 >::ContainingElementsBegin
        
            typedef Node< 3 > exported_class_t;
            typedef ::Node< 3 >::ContainingElementIterator ( exported_class_t::*ContainingElementsBegin_function_type)(  ) const;
            
            Node3_exposer.def( 
                "ContainingElementsBegin"
                , ContainingElementsBegin_function_type( &::Node< 3 >::ContainingElementsBegin ) );
        
        }
        { //::Node< 3 >::ContainingElementsEnd
        
            typedef Node< 3 > exported_class_t;
            typedef ::Node< 3 >::ContainingElementIterator ( exported_class_t::*ContainingElementsEnd_function_type)(  ) const;
            
            Node3_exposer.def( 
                "ContainingElementsEnd"
                , ContainingElementsEnd_function_type( &::Node< 3 >::ContainingElementsEnd ) );
        
        }
        { //::Node< 3 >::GetIndex
        
            typedef Node< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetIndex_function_type)(  ) const;
            
            Node3_exposer.def( 
                "GetIndex"
                , GetIndex_function_type( &::Node< 3 >::GetIndex ) );
        
        }
        { //::Node< 3 >::GetNeighboursSetUp
        
            typedef Node< 3 > exported_class_t;
            typedef bool ( exported_class_t::*GetNeighboursSetUp_function_type)(  ) ;
            
            Node3_exposer.def( 
                "GetNeighboursSetUp"
                , GetNeighboursSetUp_function_type( &::Node< 3 >::GetNeighboursSetUp ) );
        
        }
        { //::Node< 3 >::GetNumBoundaryElements
        
            typedef Node< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumBoundaryElements_function_type)(  ) const;
            
            Node3_exposer.def( 
                "GetNumBoundaryElements"
                , GetNumBoundaryElements_function_type( &::Node< 3 >::GetNumBoundaryElements ) );
        
        }
        { //::Node< 3 >::GetNumContainingElements
        
            typedef Node< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumContainingElements_function_type)(  ) const;
            
            Node3_exposer.def( 
                "GetNumContainingElements"
                , GetNumContainingElements_function_type( &::Node< 3 >::GetNumContainingElements ) );
        
        }
        { //::Node< 3 >::GetNumNodeAttributes
        
            typedef Node< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodeAttributes_function_type)(  ) ;
            
            Node3_exposer.def( 
                "GetNumNodeAttributes"
                , GetNumNodeAttributes_function_type( &::Node< 3 >::GetNumNodeAttributes ) );
        
        }
        { //::Node< 3 >::GetPoint
        
            typedef Node< 3 > exported_class_t;
            typedef ::ChastePoint< 3 > ( exported_class_t::*GetPoint_function_type)(  ) const;
            
            Node3_exposer.def( 
                "GetPoint"
                , GetPoint_function_type( &::Node< 3 >::GetPoint ) );
        
        }
        { //::Node< 3 >::GetRadius
        
            typedef Node< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetRadius_function_type)(  ) ;
            
            Node3_exposer.def( 
                "GetRadius"
                , GetRadius_function_type( &::Node< 3 >::GetRadius ) );
        
        }
        { //::Node< 3 >::GetRegion
        
            typedef Node< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetRegion_function_type)(  ) const;
            
            Node3_exposer.def( 
                "GetRegion"
                , GetRegion_function_type( &::Node< 3 >::GetRegion ) );
        
        }
        { //::Node< 3 >::HasNodeAttributes
        
            typedef Node< 3 > exported_class_t;
            typedef bool ( exported_class_t::*HasNodeAttributes_function_type)(  ) ;
            
            Node3_exposer.def( 
                "HasNodeAttributes"
                , HasNodeAttributes_function_type( &::Node< 3 >::HasNodeAttributes ) );
        
        }
        { //::Node< 3 >::IsBoundaryNode
        
            typedef Node< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsBoundaryNode_function_type)(  ) const;
            
            Node3_exposer.def( 
                "IsBoundaryNode"
                , IsBoundaryNode_function_type( &::Node< 3 >::IsBoundaryNode ) );
        
        }
        { //::Node< 3 >::IsDeleted
        
            typedef Node< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsDeleted_function_type)(  ) const;
            
            Node3_exposer.def( 
                "IsDeleted"
                , IsDeleted_function_type( &::Node< 3 >::IsDeleted ) );
        
        }
        { //::Node< 3 >::IsInternal
        
            typedef Node< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsInternal_function_type)(  ) const;
            
            Node3_exposer.def( 
                "IsInternal"
                , IsInternal_function_type( &::Node< 3 >::IsInternal ) );
        
        }
        { //::Node< 3 >::IsParticle
        
            typedef Node< 3 > exported_class_t;
            typedef bool ( exported_class_t::*IsParticle_function_type)(  ) ;
            
            Node3_exposer.def( 
                "IsParticle"
                , IsParticle_function_type( &::Node< 3 >::IsParticle ) );
        
        }
        { //::Node< 3 >::MarkAsDeleted
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*MarkAsDeleted_function_type)(  ) ;
            
            Node3_exposer.def( 
                "MarkAsDeleted"
                , MarkAsDeleted_function_type( &::Node< 3 >::MarkAsDeleted ) );
        
        }
        { //::Node< 3 >::MarkAsInternal
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*MarkAsInternal_function_type)(  ) ;
            
            Node3_exposer.def( 
                "MarkAsInternal"
                , MarkAsInternal_function_type( &::Node< 3 >::MarkAsInternal ) );
        
        }
        { //::Node< 3 >::NeighboursIsEmpty
        
            typedef Node< 3 > exported_class_t;
            typedef bool ( exported_class_t::*NeighboursIsEmpty_function_type)(  ) ;
            
            Node3_exposer.def( 
                "NeighboursIsEmpty"
                , NeighboursIsEmpty_function_type( &::Node< 3 >::NeighboursIsEmpty ) );
        
        }
        { //::Node< 3 >::RemoveBoundaryElement
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveBoundaryElement_function_type)( unsigned int ) ;
            
            Node3_exposer.def( 
                "RemoveBoundaryElement"
                , RemoveBoundaryElement_function_type( &::Node< 3 >::RemoveBoundaryElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 3 >::RemoveDuplicateNeighbours
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveDuplicateNeighbours_function_type)(  ) ;
            
            Node3_exposer.def( 
                "RemoveDuplicateNeighbours"
                , RemoveDuplicateNeighbours_function_type( &::Node< 3 >::RemoveDuplicateNeighbours ) );
        
        }
        { //::Node< 3 >::RemoveElement
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveElement_function_type)( unsigned int ) ;
            
            Node3_exposer.def( 
                "RemoveElement"
                , RemoveElement_function_type( &::Node< 3 >::RemoveElement )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 3 >::SetAsBoundaryNode
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetAsBoundaryNode_function_type)( bool ) ;
            
            Node3_exposer.def( 
                "SetAsBoundaryNode"
                , SetAsBoundaryNode_function_type( &::Node< 3 >::SetAsBoundaryNode )
                , ( bp::arg("value")=(bool)(true) ) );
        
        }
        { //::Node< 3 >::SetIndex
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIndex_function_type)( unsigned int ) ;
            
            Node3_exposer.def( 
                "SetIndex"
                , SetIndex_function_type( &::Node< 3 >::SetIndex )
                , ( bp::arg("index") ) );
        
        }
        { //::Node< 3 >::SetIsParticle
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetIsParticle_function_type)( bool ) ;
            
            Node3_exposer.def( 
                "SetIsParticle"
                , SetIsParticle_function_type( &::Node< 3 >::SetIsParticle )
                , ( bp::arg("isParticle") ) );
        
        }
        { //::Node< 3 >::SetNeighboursSetUp
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetNeighboursSetUp_function_type)( bool ) ;
            
            Node3_exposer.def( 
                "SetNeighboursSetUp"
                , SetNeighboursSetUp_function_type( &::Node< 3 >::SetNeighboursSetUp )
                , ( bp::arg("flag") ) );
        
        }
        { //::Node< 3 >::SetPoint
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetPoint_function_type)( ::ChastePoint< 3 > ) ;
            
            Node3_exposer.def( 
                "SetPoint"
                , SetPoint_function_type( &::Node< 3 >::SetPoint )
                , ( bp::arg("point") ) );
        
        }
        { //::Node< 3 >::SetRadius
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRadius_function_type)( double ) ;
            
            Node3_exposer.def( 
                "SetRadius"
                , SetRadius_function_type( &::Node< 3 >::SetRadius )
                , ( bp::arg("radius") ) );
        
        }
        { //::Node< 3 >::SetRegion
        
            typedef Node< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetRegion_function_type)( unsigned int ) ;
            
            Node3_exposer.def( 
                "SetRegion"
                , SetRegion_function_type( &::Node< 3 >::SetRegion )
                , ( bp::arg("region") ) );
        
        }
        { //::Node< 3 >::rGetLocation
        
            typedef Node< 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > const & ( exported_class_t::*rGetLocation_function_type)(  ) const;
            
            Node3_exposer.def( 
                "rGetLocation"
                , rGetLocation_function_type( &::Node< 3 >::rGetLocation )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< Node<3> > >();
    }

    bp::class_< NodeAttributes< 2 > >( "NodeAttributes2", bp::init< >() )    
        .def( 
            "AddAppliedForceContribution"
            , (void ( ::NodeAttributes<2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > & ))( &::NodeAttributes< 2 >::AddAppliedForceContribution )
            , ( bp::arg("appliedForceContribution") ) )    
        .def( 
            "AddAttribute"
            , (void ( ::NodeAttributes<2>::* )( double ))( &::NodeAttributes< 2 >::AddAttribute )
            , ( bp::arg("attribute") ) )    
        .def( 
            "AddNeighbour"
            , (void ( ::NodeAttributes<2>::* )( unsigned int ))( &::NodeAttributes< 2 >::AddNeighbour )
            , ( bp::arg("index") ) )    
        .def( 
            "ClearAppliedForce"
            , (void ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::ClearAppliedForce ) )    
        .def( 
            "ClearNeighbours"
            , (void ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::ClearNeighbours ) )    
        .def( 
            "GetNeighboursSetUp"
            , (bool ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::GetNeighboursSetUp ) )    
        .def( 
            "GetRadius"
            , (double ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::GetRadius ) )    
        .def( 
            "GetRegion"
            , (unsigned int ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::GetRegion ) )    
        .def( 
            "IsParticle"
            , (bool ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::IsParticle ) )    
        .def( 
            "NeighboursIsEmpty"
            , (bool ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::NeighboursIsEmpty ) )    
        .def( 
            "RemoveDuplicateNeighbours"
            , (void ( ::NodeAttributes<2>::* )(  ))( &::NodeAttributes< 2 >::RemoveDuplicateNeighbours ) )    
        .def( 
            "SetIsParticle"
            , (void ( ::NodeAttributes<2>::* )( bool ))( &::NodeAttributes< 2 >::SetIsParticle )
            , ( bp::arg("isParticle") ) )    
        .def( 
            "SetNeighboursSetUp"
            , (void ( ::NodeAttributes<2>::* )( bool ))( &::NodeAttributes< 2 >::SetNeighboursSetUp )
            , ( bp::arg("flag") ) )    
        .def( 
            "SetRadius"
            , (void ( ::NodeAttributes<2>::* )( double ))( &::NodeAttributes< 2 >::SetRadius )
            , ( bp::arg("radius") ) )    
        .def( 
            "SetRegion"
            , (void ( ::NodeAttributes<2>::* )( unsigned int ))( &::NodeAttributes< 2 >::SetRegion )
            , ( bp::arg("region") ) );

    bp::class_< NodeAttributes< 3 > >( "NodeAttributes3", bp::init< >() )    
        .def( 
            "AddAppliedForceContribution"
            , (void ( ::NodeAttributes<3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > & ))( &::NodeAttributes< 3 >::AddAppliedForceContribution )
            , ( bp::arg("appliedForceContribution") ) )    
        .def( 
            "AddAttribute"
            , (void ( ::NodeAttributes<3>::* )( double ))( &::NodeAttributes< 3 >::AddAttribute )
            , ( bp::arg("attribute") ) )    
        .def( 
            "AddNeighbour"
            , (void ( ::NodeAttributes<3>::* )( unsigned int ))( &::NodeAttributes< 3 >::AddNeighbour )
            , ( bp::arg("index") ) )    
        .def( 
            "ClearAppliedForce"
            , (void ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::ClearAppliedForce ) )    
        .def( 
            "ClearNeighbours"
            , (void ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::ClearNeighbours ) )    
        .def( 
            "GetNeighboursSetUp"
            , (bool ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::GetNeighboursSetUp ) )    
        .def( 
            "GetRadius"
            , (double ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::GetRadius ) )    
        .def( 
            "GetRegion"
            , (unsigned int ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::GetRegion ) )    
        .def( 
            "IsParticle"
            , (bool ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::IsParticle ) )    
        .def( 
            "NeighboursIsEmpty"
            , (bool ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::NeighboursIsEmpty ) )    
        .def( 
            "RemoveDuplicateNeighbours"
            , (void ( ::NodeAttributes<3>::* )(  ))( &::NodeAttributes< 3 >::RemoveDuplicateNeighbours ) )    
        .def( 
            "SetIsParticle"
            , (void ( ::NodeAttributes<3>::* )( bool ))( &::NodeAttributes< 3 >::SetIsParticle )
            , ( bp::arg("isParticle") ) )    
        .def( 
            "SetNeighboursSetUp"
            , (void ( ::NodeAttributes<3>::* )( bool ))( &::NodeAttributes< 3 >::SetNeighboursSetUp )
            , ( bp::arg("flag") ) )    
        .def( 
            "SetRadius"
            , (void ( ::NodeAttributes<3>::* )( double ))( &::NodeAttributes< 3 >::SetRadius )
            , ( bp::arg("radius") ) )    
        .def( 
            "SetRegion"
            , (void ( ::NodeAttributes<3>::* )( unsigned int ))( &::NodeAttributes< 3 >::SetRegion )
            , ( bp::arg("region") ) );

    bp::class_< NodesOnlyMesh_less__2__greater__wrapper, bp::bases< MutableMesh< 2, 2 > >, boost::noncopyable >( "NodesOnlyMesh2", bp::init< >() )    
        .def( 
            "AddHaloNode"
            , (void ( ::NodesOnlyMesh<2>::* )( ::boost::shared_ptr< Node< 2 > > ))( &::NodesOnlyMesh< 2 >::AddHaloNode )
            , ( bp::arg("pNewNode") ) )    
        .def( 
            "AddHaloNodesToBoxes"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::AddHaloNodesToBoxes ) )    
        .def( 
            "AddMovedNode"
            , (void ( ::NodesOnlyMesh<2>::* )( ::boost::shared_ptr< Node< 2 > > ))( &::NodesOnlyMesh< 2 >::AddMovedNode )
            , ( bp::arg("pMovedNode") ) )    
        .def( 
            "AddNode"
            , (unsigned int ( ::NodesOnlyMesh<2>::* )( ::Node< 2 > * ))(&::NodesOnlyMesh< 2 >::AddNode)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::Node< 2 > * ))(&NodesOnlyMesh_less__2__greater__wrapper::default_AddNode)
            , ( bp::arg("pNewNode") ) )    
        .def( 
            "AddNodesToBoxes"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::AddNodesToBoxes ) )    
        .def( 
            "CalculateBoundaryNodePairs"
            , (void ( ::NodesOnlyMesh<2>::* )( ::std::vector< std::pair<Node<2> *, Node<2> *> > & ))( &::NodesOnlyMesh< 2 >::CalculateBoundaryNodePairs )
            , ( bp::arg("rNodePairs") ) )    
        .def( 
            "CalculateInteriorNodePairs"
            , (void ( ::NodesOnlyMesh<2>::* )( ::std::vector< std::pair<Node<2> *, Node<2> *> > & ))( &::NodesOnlyMesh< 2 >::CalculateInteriorNodePairs )
            , ( bp::arg("rNodePairs") ) )    
        .def( 
            "CalculateNodesOutsideLocalDomain"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::CalculateNodesOutsideLocalDomain ) )    
        .def( 
            "Clear"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))(&::NodesOnlyMesh< 2 >::Clear)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::default_Clear) )    
        .def( 
            "ClearBoxCollection"
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::ClearBoxCollection) )    
        .def( 
            "ClearHaloNodes"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::ClearHaloNodes ) )    
        .def( 
            "ConstructFromMeshReader"
            , (void ( ::NodesOnlyMesh<2>::* )( ::AbstractMeshReader< 2, 2 > & ))(&::NodesOnlyMesh< 2 >::ConstructFromMeshReader)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::AbstractMeshReader< 2, 2 > & ))(&NodesOnlyMesh_less__2__greater__wrapper::default_ConstructFromMeshReader)
            , ( bp::arg("rMeshReader") ) )    
        .def( 
            "ConstructNodesWithoutMesh"
            , (void ( ::NodesOnlyMesh<2>::* )( ::std::vector< Node<2> * > const &,double ))( &::NodesOnlyMesh< 2 >::ConstructNodesWithoutMesh )
            , ( bp::arg("rNodes"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "ConstructNodesWithoutMesh"
            , (void ( ::NodesOnlyMesh<2>::* )( ::std::vector< boost::shared_ptr<Node<2> > > const &,double ))( &::NodesOnlyMesh< 2 >::ConstructNodesWithoutMesh )
            , ( bp::arg("rNodes"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "ConstructNodesWithoutMesh"
            , (void ( ::NodesOnlyMesh<2>::* )( ::AbstractMesh< 2, 2 > const &,double ))( &::NodesOnlyMesh< 2 >::ConstructNodesWithoutMesh )
            , ( bp::arg("rGeneratingMesh"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "DeleteMovedNode"
            , (void ( ::NodesOnlyMesh<2>::* )( unsigned int ))( &::NodesOnlyMesh< 2 >::DeleteMovedNode )
            , ( bp::arg("index") ) )    
        .def( 
            "DeleteNode"
            , (void ( ::NodesOnlyMesh<2>::* )( unsigned int ))(&::NodesOnlyMesh< 2 >::DeleteNode)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__2__greater__wrapper::default_DeleteNode)
            , ( bp::arg("index") ) )    
        .def( 
            "GetMaximumInteractionDistance"
            , (double ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::GetMaximumInteractionDistance ) )    
        .def( 
            "GetMaximumNodeIndex"
            , (unsigned int ( ::NodesOnlyMesh<2>::* )(  ))(&::NodesOnlyMesh< 2 >::GetMaximumNodeIndex)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::default_GetMaximumNodeIndex) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::NodesOnlyMesh<2>::* )(  )const)(&::NodesOnlyMesh< 2 >::GetNumNodes)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetWidth"
            , (double ( ::NodesOnlyMesh<2>::* )( unsigned int const & )const)(&::NodesOnlyMesh< 2 >::GetWidth)
            , (double ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int const & )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "IsOwned"
            , (bool ( ::NodesOnlyMesh<2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > & ))( &::NodesOnlyMesh< 2 >::IsOwned )
            , ( bp::arg("location") ) )    
        .def( 
            "LoadBalanceMesh"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::LoadBalanceMesh ) )    
        .def( 
            "ReMesh"
            , (void ( ::NodesOnlyMesh<2>::* )( ::NodeMap & ))(&::NodesOnlyMesh< 2 >::ReMesh)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::NodeMap & ))(&NodesOnlyMesh_less__2__greater__wrapper::default_ReMesh)
            , ( bp::arg("rMap") ) )    
        .def( 
            "ResizeBoxCollection"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::ResizeBoxCollection ) )    
        .def( 
            "SetCalculateNodeNeighbours"
            , (void ( ::NodesOnlyMesh<2>::* )( bool ))( &::NodesOnlyMesh< 2 >::SetCalculateNodeNeighbours )
            , ( bp::arg("calculateNodeNeighbours") ) )    
        .def( 
            "SetInitialBoxCollection"
            , (void ( ::NodesOnlyMesh<2>::* )( ::boost::numeric::ublas::c_vector< double, 4 > const,double ))( &::NodesOnlyMesh< 2 >::SetInitialBoxCollection )
            , ( bp::arg("domainSize"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "SetMaximumInteractionDistance"
            , (void ( ::NodesOnlyMesh<2>::* )( double ))( &::NodesOnlyMesh< 2 >::SetMaximumInteractionDistance )
            , ( bp::arg("maxDistance") ) )    
        .def( 
            "SetMinimumNodeDomainBoundarySeparation"
            , (void ( ::NodesOnlyMesh<2>::* )( double ))( &::NodesOnlyMesh< 2 >::SetMinimumNodeDomainBoundarySeparation )
            , ( bp::arg("separation") ) )    
        .def( 
            "SetNode"
            , (void ( ::NodesOnlyMesh<2>::* )( unsigned int,::ChastePoint< 2 >,bool ))(&::NodesOnlyMesh< 2 >::SetNode)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int,::ChastePoint< 2 >,bool ))(&NodesOnlyMesh_less__2__greater__wrapper::default_SetNode)
            , ( bp::arg("nodeIndex"), bp::arg("point"), bp::arg("concreteMove")=(bool)(false) ) )    
        .def( 
            "SetUpBoxCollection"
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( double,::boost::numeric::ublas::c_vector< double, 4 >,int,bool ))(&NodesOnlyMesh_less__2__greater__wrapper::default_SetUpBoxCollection)
            , ( bp::arg("cutOffLength"), bp::arg("domainSize"), bp::arg("numLocalRows")=(int)(-1), bp::arg("isPeriodic")=(bool)(false) ) )    
        .def( 
            "SolveNodeMapping"
            , (unsigned int ( ::NodesOnlyMesh<2>::* )( unsigned int )const)(&::NodesOnlyMesh< 2 >::SolveNodeMapping)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_SolveNodeMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "UpdateBoxCollection"
            , (void ( ::NodesOnlyMesh<2>::* )(  ))( &::NodesOnlyMesh< 2 >::UpdateBoxCollection ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<2> ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::std::vector<Node<2> *, std::allocator<Node<2> *> > const & )const)(&NodesOnlyMesh_less__2__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 2 > ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
            , (::ChasteCuboid< 2 > ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "CalculateDesignatedOwnershipOfBoundaryElement"
            , (bool ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfBoundaryElement)
            , (bool ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__2__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
            , ( bp::arg("faceIndex") ) )    
        .def( 
            "CalculateDesignatedOwnershipOfElement"
            , (bool ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateDesignatedOwnershipOfElement)
            , (bool ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__2__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
            , ( bp::arg("elementIndex") ) )    
        .def( 
            "CalculateMinMaxEdgeLengths"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractTetrahedralMesh<2, 2>::* )(  ))(&::AbstractTetrahedralMesh< 2, 2 >::CalculateMinMaxEdgeLengths)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::default_CalculateMinMaxEdgeLengths) )    
        .def( 
            "ConstructCuboid"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,unsigned int,unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructCuboid)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int,unsigned int,unsigned int ))(&NodesOnlyMesh_less__2__greater__wrapper::default_ConstructCuboid)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) )    
        .def( 
            "ConstructLinearMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructLinearMesh)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__2__greater__wrapper::default_ConstructLinearMesh)
            , ( bp::arg("width") ) )    
        .def( 
            "ConstructRectangularMesh"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( unsigned int,unsigned int,bool ))(&::AbstractTetrahedralMesh< 2, 2 >::ConstructRectangularMesh)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int,unsigned int,bool ))(&NodesOnlyMesh_less__2__greater__wrapper::default_ConstructRectangularMesh)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) )    
        .def( 
            "DeleteElement"
            , (void ( ::MutableMesh<2, 2>::* )( unsigned int ))(&::MutableMesh< 2, 2 >::DeleteElement)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__2__greater__wrapper::default_DeleteElement)
            , ( bp::arg("index") ) )    
        .def( 
            "GetHaloNodeIndices"
            , (void ( ::AbstractTetrahedralMesh<2, 2>::* )( ::std::vector< unsigned int > & )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetHaloNodeIndices)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::std::vector< unsigned int > & )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetHaloNodeIndices)
            , ( bp::arg("rHaloIndices") ) )    
        .def( 
            "GetInverseJacobianForElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & )const)(&::TetrahedralMesh< 2, 2 >::GetInverseJacobianForElement)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double &,::boost::numeric::ublas::c_matrix< double, 2, 2 > & )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetInverseJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) )    
        .def( 
            "GetJacobianForElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double & )const)(&::TetrahedralMesh< 2, 2 >::GetJacobianForElement)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 2, 2 > &,double & )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )( ::ChastePoint< 2 > const & ))(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::ChastePoint< 2 > const & ))(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<2, 2>::* )(  )const)(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumBoundaryElements"
            , (unsigned int ( ::MutableMesh<2, 2>::* )(  )const)(&::MutableMesh< 2, 2 >::GetNumBoundaryElements)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumBoundaryElements) )    
        .def( 
            "GetNumCableElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumCableElements)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumCableElements) )    
        .def( 
            "GetNumElements"
            , (unsigned int ( ::MutableMesh<2, 2>::* )(  )const)(&::MutableMesh< 2, 2 >::GetNumElements)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumElements) )    
        .def( 
            "GetNumLocalBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalBoundaryElements)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumLocalBoundaryElements) )    
        .def( 
            "GetNumLocalElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumLocalElements)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumLocalElements) )    
        .def( 
            "GetNumVertices"
            , (unsigned int ( ::AbstractTetrahedralMesh<2, 2>::* )(  )const)(&::AbstractTetrahedralMesh< 2, 2 >::GetNumVertices)
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetNumVertices) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ))(&NodesOnlyMesh_less__2__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWeightedDirectionForBoundaryElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForBoundaryElement)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetWeightedDirectionForElement"
            , (void ( ::TetrahedralMesh<2, 2>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&::TetrahedralMesh< 2, 2 >::GetWeightedDirectionForElement)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 2 > &,double & )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_GetWeightedDirectionForElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<2, 2>::* )(  ))(&::TetrahedralMesh< 2, 2 >::PermuteNodes)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<2, 2>::* )( ::std::vector< unsigned int > const & ))( &::TetrahedralMesh< 2, 2 >::PermuteNodes )
            , ( bp::arg("perm") ) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::TetrahedralMesh<2, 2>::* )( ::std::string const & ))(&::TetrahedralMesh< 2, 2 >::ReadNodesPerProcessorFile)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::std::string const & ))(&NodesOnlyMesh_less__2__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshJacobianCachedData"
            , (void ( ::TetrahedralMesh<2, 2>::* )(  ))(&::TetrahedralMesh< 2, 2 >::RefreshJacobianCachedData)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::default_RefreshJacobianCachedData) )    
        .def( 
            "RefreshMesh"
            , (void ( ::TetrahedralMesh<2, 2>::* )(  ))(&::TetrahedralMesh< 2, 2 >::RefreshMesh)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&::AbstractMesh< 2, 2 >::Rotate)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ))(&NodesOnlyMesh_less__2__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<2, 2>::* )( double ))( &::AbstractMesh< 2, 2 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))(&::AbstractMesh< 2, 2 >::Scale)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( double const,double const,double const ))(&NodesOnlyMesh_less__2__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<2, 2>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::DistributedVectorFactory * ))(&NodesOnlyMesh_less__2__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__2__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "SolveBoundaryElementMapping"
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_SolveBoundaryElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveElementMapping"
            , (unsigned int ( NodesOnlyMesh_less__2__greater__wrapper::* )( unsigned int )const)(&NodesOnlyMesh_less__2__greater__wrapper::default_SolveElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&::AbstractMesh< 2, 2 >::Translate)
            , (void ( NodesOnlyMesh_less__2__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 2 > const & ))(&NodesOnlyMesh_less__2__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<2, 2>::* )( double const,double const,double const ))( &::AbstractMesh< 2, 2 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    bp::class_< NodesOnlyMesh_less__3__greater__wrapper, bp::bases< MutableMesh< 3, 3 > >, boost::noncopyable >( "NodesOnlyMesh3", bp::init< >() )    
        .def( 
            "AddHaloNode"
            , (void ( ::NodesOnlyMesh<3>::* )( ::boost::shared_ptr< Node< 3 > > ))( &::NodesOnlyMesh< 3 >::AddHaloNode )
            , ( bp::arg("pNewNode") ) )    
        .def( 
            "AddHaloNodesToBoxes"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::AddHaloNodesToBoxes ) )    
        .def( 
            "AddMovedNode"
            , (void ( ::NodesOnlyMesh<3>::* )( ::boost::shared_ptr< Node< 3 > > ))( &::NodesOnlyMesh< 3 >::AddMovedNode )
            , ( bp::arg("pMovedNode") ) )    
        .def( 
            "AddNode"
            , (unsigned int ( ::NodesOnlyMesh<3>::* )( ::Node< 3 > * ))(&::NodesOnlyMesh< 3 >::AddNode)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::Node< 3 > * ))(&NodesOnlyMesh_less__3__greater__wrapper::default_AddNode)
            , ( bp::arg("pNewNode") ) )    
        .def( 
            "AddNodesToBoxes"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::AddNodesToBoxes ) )    
        .def( 
            "CalculateBoundaryNodePairs"
            , (void ( ::NodesOnlyMesh<3>::* )( ::std::vector< std::pair<Node<3> *, Node<3> *> > & ))( &::NodesOnlyMesh< 3 >::CalculateBoundaryNodePairs )
            , ( bp::arg("rNodePairs") ) )    
        .def( 
            "CalculateInteriorNodePairs"
            , (void ( ::NodesOnlyMesh<3>::* )( ::std::vector< std::pair<Node<3> *, Node<3> *> > & ))( &::NodesOnlyMesh< 3 >::CalculateInteriorNodePairs )
            , ( bp::arg("rNodePairs") ) )    
        .def( 
            "CalculateNodesOutsideLocalDomain"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::CalculateNodesOutsideLocalDomain ) )    
        .def( 
            "Clear"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))(&::NodesOnlyMesh< 3 >::Clear)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::default_Clear) )    
        .def( 
            "ClearBoxCollection"
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::ClearBoxCollection) )    
        .def( 
            "ClearHaloNodes"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::ClearHaloNodes ) )    
        .def( 
            "ConstructFromMeshReader"
            , (void ( ::NodesOnlyMesh<3>::* )( ::AbstractMeshReader< 3, 3 > & ))(&::NodesOnlyMesh< 3 >::ConstructFromMeshReader)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::AbstractMeshReader< 3, 3 > & ))(&NodesOnlyMesh_less__3__greater__wrapper::default_ConstructFromMeshReader)
            , ( bp::arg("rMeshReader") ) )    
        .def( 
            "ConstructNodesWithoutMesh"
            , (void ( ::NodesOnlyMesh<3>::* )( ::std::vector< Node<3> * > const &,double ))( &::NodesOnlyMesh< 3 >::ConstructNodesWithoutMesh )
            , ( bp::arg("rNodes"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "ConstructNodesWithoutMesh"
            , (void ( ::NodesOnlyMesh<3>::* )( ::std::vector< boost::shared_ptr<Node<3> > > const &,double ))( &::NodesOnlyMesh< 3 >::ConstructNodesWithoutMesh )
            , ( bp::arg("rNodes"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "ConstructNodesWithoutMesh"
            , (void ( ::NodesOnlyMesh<3>::* )( ::AbstractMesh< 3, 3 > const &,double ))( &::NodesOnlyMesh< 3 >::ConstructNodesWithoutMesh )
            , ( bp::arg("rGeneratingMesh"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "DeleteMovedNode"
            , (void ( ::NodesOnlyMesh<3>::* )( unsigned int ))( &::NodesOnlyMesh< 3 >::DeleteMovedNode )
            , ( bp::arg("index") ) )    
        .def( 
            "DeleteNode"
            , (void ( ::NodesOnlyMesh<3>::* )( unsigned int ))(&::NodesOnlyMesh< 3 >::DeleteNode)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__3__greater__wrapper::default_DeleteNode)
            , ( bp::arg("index") ) )    
        .def( 
            "GetMaximumInteractionDistance"
            , (double ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::GetMaximumInteractionDistance ) )    
        .def( 
            "GetMaximumNodeIndex"
            , (unsigned int ( ::NodesOnlyMesh<3>::* )(  ))(&::NodesOnlyMesh< 3 >::GetMaximumNodeIndex)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::default_GetMaximumNodeIndex) )    
        .def( 
            "GetNumNodes"
            , (unsigned int ( ::NodesOnlyMesh<3>::* )(  )const)(&::NodesOnlyMesh< 3 >::GetNumNodes)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumNodes) )    
        .def( 
            "GetWidth"
            , (double ( ::NodesOnlyMesh<3>::* )( unsigned int const & )const)(&::NodesOnlyMesh< 3 >::GetWidth)
            , (double ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int const & )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetWidth)
            , ( bp::arg("rDimension") ) )    
        .def( 
            "IsOwned"
            , (bool ( ::NodesOnlyMesh<3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > & ))( &::NodesOnlyMesh< 3 >::IsOwned )
            , ( bp::arg("location") ) )    
        .def( 
            "LoadBalanceMesh"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::LoadBalanceMesh ) )    
        .def( 
            "ReMesh"
            , (void ( ::NodesOnlyMesh<3>::* )( ::NodeMap & ))(&::NodesOnlyMesh< 3 >::ReMesh)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::NodeMap & ))(&NodesOnlyMesh_less__3__greater__wrapper::default_ReMesh)
            , ( bp::arg("rMap") ) )    
        .def( 
            "ResizeBoxCollection"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::ResizeBoxCollection ) )    
        .def( 
            "SetCalculateNodeNeighbours"
            , (void ( ::NodesOnlyMesh<3>::* )( bool ))( &::NodesOnlyMesh< 3 >::SetCalculateNodeNeighbours )
            , ( bp::arg("calculateNodeNeighbours") ) )    
        .def( 
            "SetInitialBoxCollection"
            , (void ( ::NodesOnlyMesh<3>::* )( ::boost::numeric::ublas::c_vector< double, 6 > const,double ))( &::NodesOnlyMesh< 3 >::SetInitialBoxCollection )
            , ( bp::arg("domainSize"), bp::arg("maxInteractionDistance") ) )    
        .def( 
            "SetMaximumInteractionDistance"
            , (void ( ::NodesOnlyMesh<3>::* )( double ))( &::NodesOnlyMesh< 3 >::SetMaximumInteractionDistance )
            , ( bp::arg("maxDistance") ) )    
        .def( 
            "SetMinimumNodeDomainBoundarySeparation"
            , (void ( ::NodesOnlyMesh<3>::* )( double ))( &::NodesOnlyMesh< 3 >::SetMinimumNodeDomainBoundarySeparation )
            , ( bp::arg("separation") ) )    
        .def( 
            "SetNode"
            , (void ( ::NodesOnlyMesh<3>::* )( unsigned int,::ChastePoint< 3 >,bool ))(&::NodesOnlyMesh< 3 >::SetNode)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int,::ChastePoint< 3 >,bool ))(&NodesOnlyMesh_less__3__greater__wrapper::default_SetNode)
            , ( bp::arg("nodeIndex"), bp::arg("point"), bp::arg("concreteMove")=(bool)(false) ) )    
        .def( 
            "SetUpBoxCollection"
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( double,::boost::numeric::ublas::c_vector< double, 6 >,int,bool ))(&NodesOnlyMesh_less__3__greater__wrapper::default_SetUpBoxCollection)
            , ( bp::arg("cutOffLength"), bp::arg("domainSize"), bp::arg("numLocalRows")=(int)(-1), bp::arg("isPeriodic")=(bool)(false) ) )    
        .def( 
            "SolveNodeMapping"
            , (unsigned int ( ::NodesOnlyMesh<3>::* )( unsigned int )const)(&::NodesOnlyMesh< 3 >::SolveNodeMapping)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_SolveNodeMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "UpdateBoxCollection"
            , (void ( ::NodesOnlyMesh<3>::* )(  ))( &::NodesOnlyMesh< 3 >::UpdateBoxCollection ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid<3> ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::std::vector<Node<3> *, std::allocator<Node<3> *> > const & )const)(&NodesOnlyMesh_less__3__greater__wrapper::CalculateBoundingBox)
            , ( bp::arg("rNodes") ) )    
        .def( 
            "CalculateBoundingBox"
            , (::ChasteCuboid< 3 > ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
            , (::ChasteCuboid< 3 > ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_CalculateBoundingBox) )    
        .def( 
            "CalculateDesignatedOwnershipOfBoundaryElement"
            , (bool ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfBoundaryElement)
            , (bool ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__3__greater__wrapper::default_CalculateDesignatedOwnershipOfBoundaryElement)
            , ( bp::arg("faceIndex") ) )    
        .def( 
            "CalculateDesignatedOwnershipOfElement"
            , (bool ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateDesignatedOwnershipOfElement)
            , (bool ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__3__greater__wrapper::default_CalculateDesignatedOwnershipOfElement)
            , ( bp::arg("elementIndex") ) )    
        .def( 
            "CalculateMinMaxEdgeLengths"
            , (::boost::numeric::ublas::c_vector< double, 2 > ( ::AbstractTetrahedralMesh<3, 3>::* )(  ))(&::AbstractTetrahedralMesh< 3, 3 >::CalculateMinMaxEdgeLengths)
            , (::boost::numeric::ublas::c_vector< double, 2 > ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::default_CalculateMinMaxEdgeLengths) )    
        .def( 
            "ConstructCuboid"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,unsigned int,unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructCuboid)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int,unsigned int,unsigned int ))(&NodesOnlyMesh_less__3__greater__wrapper::default_ConstructCuboid)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("depth") ) )    
        .def( 
            "ConstructLinearMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructLinearMesh)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__3__greater__wrapper::default_ConstructLinearMesh)
            , ( bp::arg("width") ) )    
        .def( 
            "ConstructRectangularMesh"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( unsigned int,unsigned int,bool ))(&::AbstractTetrahedralMesh< 3, 3 >::ConstructRectangularMesh)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int,unsigned int,bool ))(&NodesOnlyMesh_less__3__greater__wrapper::default_ConstructRectangularMesh)
            , ( bp::arg("width"), bp::arg("height"), bp::arg("stagger")=(bool)(true) ) )    
        .def( 
            "DeleteElement"
            , (void ( ::MutableMesh<3, 3>::* )( unsigned int ))(&::MutableMesh< 3, 3 >::DeleteElement)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int ))(&NodesOnlyMesh_less__3__greater__wrapper::default_DeleteElement)
            , ( bp::arg("index") ) )    
        .def( 
            "GetHaloNodeIndices"
            , (void ( ::AbstractTetrahedralMesh<3, 3>::* )( ::std::vector< unsigned int > & )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetHaloNodeIndices)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::std::vector< unsigned int > & )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetHaloNodeIndices)
            , ( bp::arg("rHaloIndices") ) )    
        .def( 
            "GetInverseJacobianForElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & )const)(&::TetrahedralMesh< 3, 3 >::GetInverseJacobianForElement)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double &,::boost::numeric::ublas::c_matrix< double, 3, 3 > & )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetInverseJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant"), bp::arg("rInverseJacobian") ) )    
        .def( 
            "GetJacobianForElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double & )const)(&::TetrahedralMesh< 3, 3 >::GetJacobianForElement)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_matrix< double, 3, 3 > &,double & )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetJacobianForElement)
            , ( bp::arg("elementIndex"), bp::arg("rJacobian"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetNearestNodeIndex"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )( ::ChastePoint< 3 > const & ))(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::ChastePoint< 3 > const & ))(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNearestNodeIndex)
            , ( bp::arg("rTestPoint") ) )    
        .def( 
            "GetNumAllNodes"
            , (unsigned int ( ::AbstractMesh<3, 3>::* )(  )const)(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumAllNodes) )    
        .def( 
            "GetNumBoundaryElements"
            , (unsigned int ( ::MutableMesh<3, 3>::* )(  )const)(&::MutableMesh< 3, 3 >::GetNumBoundaryElements)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumBoundaryElements) )    
        .def( 
            "GetNumCableElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumCableElements)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumCableElements) )    
        .def( 
            "GetNumElements"
            , (unsigned int ( ::MutableMesh<3, 3>::* )(  )const)(&::MutableMesh< 3, 3 >::GetNumElements)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumElements) )    
        .def( 
            "GetNumLocalBoundaryElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalBoundaryElements)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumLocalBoundaryElements) )    
        .def( 
            "GetNumLocalElements"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumLocalElements)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumLocalElements) )    
        .def( 
            "GetNumVertices"
            , (unsigned int ( ::AbstractTetrahedralMesh<3, 3>::* )(  )const)(&::AbstractTetrahedralMesh< 3, 3 >::GetNumVertices)
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )(  )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetNumVertices) )    
        .def( 
            "GetVectorFromAtoB"
            , (::boost::numeric::ublas::c_vector< double, 3 > ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::GetVectorFromAtoB)
            , (::boost::numeric::ublas::c_vector< double, 3 > ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ))(&NodesOnlyMesh_less__3__greater__wrapper::default_GetVectorFromAtoB)
            , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) )    
        .def( 
            "GetWeightedDirectionForBoundaryElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForBoundaryElement)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetWeightedDirectionForBoundaryElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "GetWeightedDirectionForElement"
            , (void ( ::TetrahedralMesh<3, 3>::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&::TetrahedralMesh< 3, 3 >::GetWeightedDirectionForElement)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int,::boost::numeric::ublas::c_vector< double, 3 > &,double & )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_GetWeightedDirectionForElement)
            , ( bp::arg("elementIndex"), bp::arg("rWeightedDirection"), bp::arg("rJacobianDeterminant") ) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<3, 3>::* )(  ))(&::TetrahedralMesh< 3, 3 >::PermuteNodes)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::default_PermuteNodes) )    
        .def( 
            "PermuteNodes"
            , (void ( ::TetrahedralMesh<3, 3>::* )( ::std::vector< unsigned int > const & ))( &::TetrahedralMesh< 3, 3 >::PermuteNodes )
            , ( bp::arg("perm") ) )    
        .def( 
            "ReadNodesPerProcessorFile"
            , (void ( ::TetrahedralMesh<3, 3>::* )( ::std::string const & ))(&::TetrahedralMesh< 3, 3 >::ReadNodesPerProcessorFile)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::std::string const & ))(&NodesOnlyMesh_less__3__greater__wrapper::default_ReadNodesPerProcessorFile)
            , ( bp::arg("rNodesPerProcessorFile") ) )    
        .def( 
            "RefreshJacobianCachedData"
            , (void ( ::TetrahedralMesh<3, 3>::* )(  ))(&::TetrahedralMesh< 3, 3 >::RefreshJacobianCachedData)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::default_RefreshJacobianCachedData) )    
        .def( 
            "RefreshMesh"
            , (void ( ::TetrahedralMesh<3, 3>::* )(  ))(&::TetrahedralMesh< 3, 3 >::RefreshMesh)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::default_RefreshMesh) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&::AbstractMesh< 3, 3 >::Rotate)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ))(&NodesOnlyMesh_less__3__greater__wrapper::default_Rotate)
            , ( bp::arg("rotationMatrix") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 >,double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("axis"), bp::arg("angle") ) )    
        .def( 
            "Rotate"
            , (void ( ::AbstractMesh<3, 3>::* )( double ))( &::AbstractMesh< 3, 3 >::Rotate )
            , ( bp::arg("theta") ) )    
        .def( 
            "Scale"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))(&::AbstractMesh< 3, 3 >::Scale)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( double const,double const,double const ))(&NodesOnlyMesh_less__3__greater__wrapper::default_Scale)
            , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) )    
        .def( 
            "SetDistributedVectorFactory"
            , (void ( ::AbstractMesh<3, 3>::* )( ::DistributedVectorFactory * ))(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::DistributedVectorFactory * ))(&NodesOnlyMesh_less__3__greater__wrapper::default_SetDistributedVectorFactory)
            , ( bp::arg("pFactory") ) )    
        .def( 
            "SetElementOwnerships"
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )(  ))(&NodesOnlyMesh_less__3__greater__wrapper::default_SetElementOwnerships) )    
        .def( 
            "SolveBoundaryElementMapping"
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_SolveBoundaryElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "SolveElementMapping"
            , (unsigned int ( NodesOnlyMesh_less__3__greater__wrapper::* )( unsigned int )const)(&NodesOnlyMesh_less__3__greater__wrapper::default_SolveElementMapping)
            , ( bp::arg("index") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&::AbstractMesh< 3, 3 >::Translate)
            , (void ( NodesOnlyMesh_less__3__greater__wrapper::* )( ::boost::numeric::ublas::c_vector< double, 3 > const & ))(&NodesOnlyMesh_less__3__greater__wrapper::default_Translate)
            , ( bp::arg("rDisplacement") ) )    
        .def( 
            "Translate"
            , (void ( ::AbstractMesh<3, 3>::* )( double const,double const,double const ))( &::AbstractMesh< 3, 3 >::Translate )
            , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );

    { //::PottsMesh< 2 >
        typedef bp::class_< PottsMesh_less__2__greater__wrapper, bp::bases< AbstractMesh< 2, 2 > >, boost::noncopyable > PottsMesh2_exposer_t;
        PottsMesh2_exposer_t PottsMesh2_exposer = PottsMesh2_exposer_t( "PottsMesh2", bp::init< std::vector< Node<2> * >, std::vector< PottsElement<2> * >, std::vector< std::set< unsigned int > >, std::vector< std::set< unsigned int > > >(( bp::arg("nodes"), bp::arg("pottsElements"), bp::arg("vonNeumannNeighbouringNodeIndices"), bp::arg("mooreNeighbouringNodeIndices") )) );
        bp::scope PottsMesh2_scope( PottsMesh2_exposer );
        PottsMesh2_exposer.def( bp::init< >() );
        { //::PottsMesh< 2 >::AddElement
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddElement_function_type)( ::PottsElement< 2 > * ) ;
            
            PottsMesh2_exposer.def( 
                "AddElement"
                , AddElement_function_type( &::PottsMesh< 2 >::AddElement )
                , ( bp::arg("pNewElement") ) );
        
        }
        { //::PottsMesh< 2 >::Clear
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*Clear_function_type)(  ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_Clear_function_type)(  ) ;
            
            PottsMesh2_exposer.def( 
                "Clear"
                , Clear_function_type(&::PottsMesh< 2 >::Clear)
                , default_Clear_function_type(&PottsMesh_less__2__greater__wrapper::default_Clear) );
        
        }
        { //::PottsMesh< 2 >::ConstructFromMeshReader
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 2, 2 > & ) ;
            
            PottsMesh2_exposer.def( 
                "ConstructFromMeshReader"
                , ConstructFromMeshReader_function_type( &::PottsMesh< 2 >::ConstructFromMeshReader )
                , ( bp::arg("rMeshReader") ) );
        
        }
        { //::PottsMesh< 2 >::DeleteElement
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteElement_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "DeleteElement"
                , DeleteElement_function_type( &::PottsMesh< 2 >::DeleteElement )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 2 >::DeleteNode
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*DeleteNode_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "DeleteNode"
                , DeleteNode_function_type( &::PottsMesh< 2 >::DeleteNode )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 2 >::DivideElement
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*DivideElement_function_type)( ::PottsElement< 2 > *,bool ) ;
            
            PottsMesh2_exposer.def( 
                "DivideElement"
                , DivideElement_function_type( &::PottsMesh< 2 >::DivideElement )
                , ( bp::arg("pElement"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) );
        
        }
        { //::PottsMesh< 2 >::GetCentroidOfElement
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetCentroidOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( PottsMesh_less__2__greater__wrapper::*default_GetCentroidOfElement_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "GetCentroidOfElement"
                , GetCentroidOfElement_function_type(&::PottsMesh< 2 >::GetCentroidOfElement)
                , default_GetCentroidOfElement_function_type(&PottsMesh_less__2__greater__wrapper::default_GetCentroidOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 2 >::GetElementIteratorBegin
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::PottsMesh< 2 >::PottsElementIterator ( exported_class_t::*GetElementIteratorBegin_function_type)( bool ) ;
            
            PottsMesh2_exposer.def( 
                "GetElementIteratorBegin"
                , GetElementIteratorBegin_function_type( &::PottsMesh< 2 >::GetElementIteratorBegin )
                , ( bp::arg("skipDeletedElements")=(bool)(true) ) );
        
        }
        { //::PottsMesh< 2 >::GetElementIteratorEnd
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::PottsMesh< 2 >::PottsElementIterator ( exported_class_t::*GetElementIteratorEnd_function_type)(  ) ;
            
            PottsMesh2_exposer.def( 
                "GetElementIteratorEnd"
                , GetElementIteratorEnd_function_type( &::PottsMesh< 2 >::GetElementIteratorEnd ) );
        
        }
        { //::PottsMesh< 2 >::GetMooreNeighbouringNodeIndices
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetMooreNeighbouringNodeIndices_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "GetMooreNeighbouringNodeIndices"
                , GetMooreNeighbouringNodeIndices_function_type( &::PottsMesh< 2 >::GetMooreNeighbouringNodeIndices )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::PottsMesh< 2 >::GetNeighbouringElementIndices
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringElementIndices_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "GetNeighbouringElementIndices"
                , GetNeighbouringElementIndices_function_type( &::PottsMesh< 2 >::GetNeighbouringElementIndices )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::PottsMesh< 2 >::GetNumAllElements
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllElements_function_type)(  ) const;
            
            PottsMesh2_exposer.def( 
                "GetNumAllElements"
                , GetNumAllElements_function_type( &::PottsMesh< 2 >::GetNumAllElements ) );
        
        }
        { //::PottsMesh< 2 >::GetNumElements
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumElements_function_type)(  ) const;
            typedef unsigned int ( PottsMesh_less__2__greater__wrapper::*default_GetNumElements_function_type)(  ) const;
            
            PottsMesh2_exposer.def( 
                "GetNumElements"
                , GetNumElements_function_type(&::PottsMesh< 2 >::GetNumElements)
                , default_GetNumElements_function_type(&PottsMesh_less__2__greater__wrapper::default_GetNumElements) );
        
        }
        { //::PottsMesh< 2 >::GetNumNodes
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodes_function_type)(  ) const;
            typedef unsigned int ( PottsMesh_less__2__greater__wrapper::*default_GetNumNodes_function_type)(  ) const;
            
            PottsMesh2_exposer.def( 
                "GetNumNodes"
                , GetNumNodes_function_type(&::PottsMesh< 2 >::GetNumNodes)
                , default_GetNumNodes_function_type(&PottsMesh_less__2__greater__wrapper::default_GetNumNodes) );
        
        }
        { //::PottsMesh< 2 >::GetSurfaceAreaOfElement
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            typedef double ( PottsMesh_less__2__greater__wrapper::*default_GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "GetSurfaceAreaOfElement"
                , GetSurfaceAreaOfElement_function_type(&::PottsMesh< 2 >::GetSurfaceAreaOfElement)
                , default_GetSurfaceAreaOfElement_function_type(&PottsMesh_less__2__greater__wrapper::default_GetSurfaceAreaOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 2 >::GetVolumeOfElement
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetVolumeOfElement_function_type)( unsigned int ) ;
            typedef double ( PottsMesh_less__2__greater__wrapper::*default_GetVolumeOfElement_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "GetVolumeOfElement"
                , GetVolumeOfElement_function_type(&::PottsMesh< 2 >::GetVolumeOfElement)
                , default_GetVolumeOfElement_function_type(&PottsMesh_less__2__greater__wrapper::default_GetVolumeOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 2 >::GetVonNeumannNeighbouringNodeIndices
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetVonNeumannNeighbouringNodeIndices_function_type)( unsigned int ) ;
            
            PottsMesh2_exposer.def( 
                "GetVonNeumannNeighbouringNodeIndices"
                , GetVonNeumannNeighbouringNodeIndices_function_type( &::PottsMesh< 2 >::GetVonNeumannNeighbouringNodeIndices )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::PottsMesh< 2 >::RemoveDeletedElements
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*RemoveDeletedElements_function_type)(  ) ;
            
            PottsMesh2_exposer.def( 
                "RemoveDeletedElements"
                , RemoveDeletedElements_function_type( &::PottsMesh< 2 >::RemoveDeletedElements ) );
        
        }
        { //::PottsMesh< 2 >::SolveBoundaryElementMapping
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( PottsMesh_less__2__greater__wrapper::*SolveBoundaryElementMapping_function_type)( unsigned int ) const;
            
            PottsMesh2_exposer.def( 
                "SolveBoundaryElementMapping"
                , SolveBoundaryElementMapping_function_type( &PottsMesh_less__2__greater__wrapper::SolveBoundaryElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 2 >::SolveElementMapping
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( PottsMesh_less__2__greater__wrapper::*SolveElementMapping_function_type)( unsigned int ) const;
            
            PottsMesh2_exposer.def( 
                "SolveElementMapping"
                , SolveElementMapping_function_type( &PottsMesh_less__2__greater__wrapper::SolveElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 2 >::SolveNodeMapping
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( PottsMesh_less__2__greater__wrapper::*SolveNodeMapping_function_type)( unsigned int ) const;
            
            PottsMesh2_exposer.def( 
                "SolveNodeMapping"
                , SolveNodeMapping_function_type( &PottsMesh_less__2__greater__wrapper::default_SolveNodeMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( PottsMesh_less__2__greater__wrapper::*CalculateBoundingBox_function_type)( ::std::vector< Node<2> * > const & ) const;
            
            PottsMesh2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type( &PottsMesh_less__2__greater__wrapper::CalculateBoundingBox )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::CalculateBoundingBox
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::ChasteCuboid< 2 > ( exported_class_t::*CalculateBoundingBox_function_type)(  ) const;
            typedef ::ChasteCuboid< 2 > ( PottsMesh_less__2__greater__wrapper::*default_CalculateBoundingBox_function_type)(  ) const;
            
            PottsMesh2_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type(&::AbstractMesh< 2, 2 >::CalculateBoundingBox)
                , default_CalculateBoundingBox_function_type(&PottsMesh_less__2__greater__wrapper::default_CalculateBoundingBox) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNearestNodeIndex
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            typedef unsigned int ( PottsMesh_less__2__greater__wrapper::*default_GetNearestNodeIndex_function_type)( ::ChastePoint< 2 > const & ) ;
            
            PottsMesh2_exposer.def( 
                "GetNearestNodeIndex"
                , GetNearestNodeIndex_function_type(&::AbstractMesh< 2, 2 >::GetNearestNodeIndex)
                , default_GetNearestNodeIndex_function_type(&PottsMesh_less__2__greater__wrapper::default_GetNearestNodeIndex)
                , ( bp::arg("rTestPoint") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetNumAllNodes
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllNodes_function_type)(  ) const;
            typedef unsigned int ( PottsMesh_less__2__greater__wrapper::*default_GetNumAllNodes_function_type)(  ) const;
            
            PottsMesh2_exposer.def( 
                "GetNumAllNodes"
                , GetNumAllNodes_function_type(&::AbstractMesh< 2, 2 >::GetNumAllNodes)
                , default_GetNumAllNodes_function_type(&PottsMesh_less__2__greater__wrapper::default_GetNumAllNodes) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetVectorFromAtoB
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( exported_class_t::*GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 2 > ( PottsMesh_less__2__greater__wrapper::*default_GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const &,::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            PottsMesh2_exposer.def( 
                "GetVectorFromAtoB"
                , GetVectorFromAtoB_function_type(&::AbstractMesh< 2, 2 >::GetVectorFromAtoB)
                , default_GetVectorFromAtoB_function_type(&PottsMesh_less__2__greater__wrapper::default_GetVectorFromAtoB)
                , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::GetWidth
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef double ( exported_class_t::*GetWidth_function_type)( unsigned int const & ) const;
            typedef double ( PottsMesh_less__2__greater__wrapper::*default_GetWidth_function_type)( unsigned int const & ) const;
            
            PottsMesh2_exposer.def( 
                "GetWidth"
                , GetWidth_function_type(&::AbstractMesh< 2, 2 >::GetWidth)
                , default_GetWidth_function_type(&PottsMesh_less__2__greater__wrapper::default_GetWidth)
                , ( bp::arg("rDimension") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::PermuteNodes
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)(  ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_PermuteNodes_function_type)(  ) ;
            
            PottsMesh2_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type(&::AbstractMesh< 2, 2 >::PermuteNodes)
                , default_PermuteNodes_function_type(&PottsMesh_less__2__greater__wrapper::default_PermuteNodes) );
        
        }
        { //::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            
            PottsMesh2_exposer.def( 
                "ReadNodesPerProcessorFile"
                , ReadNodesPerProcessorFile_function_type(&::AbstractMesh< 2, 2 >::ReadNodesPerProcessorFile)
                , default_ReadNodesPerProcessorFile_function_type(&PottsMesh_less__2__greater__wrapper::default_ReadNodesPerProcessorFile)
                , ( bp::arg("rNodesPerProcessorFile") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::RefreshMesh
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*RefreshMesh_function_type)(  ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_RefreshMesh_function_type)(  ) ;
            
            PottsMesh2_exposer.def( 
                "RefreshMesh"
                , RefreshMesh_function_type(&::AbstractMesh< 2, 2 >::RefreshMesh)
                , default_RefreshMesh_function_type(&PottsMesh_less__2__greater__wrapper::default_RefreshMesh) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 2, 2 > ) ;
            
            PottsMesh2_exposer.def( 
                "Rotate"
                , Rotate_function_type(&::AbstractMesh< 2, 2 >::Rotate)
                , default_Rotate_function_type(&PottsMesh_less__2__greater__wrapper::default_Rotate)
                , ( bp::arg("rotationMatrix") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            PottsMesh2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("axis"), bp::arg("angle") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Rotate
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( double ) ;
            
            PottsMesh2_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 2, 2 >::Rotate )
                , ( bp::arg("theta") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Scale
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*Scale_function_type)( double const,double const,double const ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_Scale_function_type)( double const,double const,double const ) ;
            
            PottsMesh2_exposer.def( 
                "Scale"
                , Scale_function_type(&::AbstractMesh< 2, 2 >::Scale)
                , default_Scale_function_type(&PottsMesh_less__2__greater__wrapper::default_Scale)
                , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) );
        
        }
        { //::AbstractMesh< 2, 2 >::SetDistributedVectorFactory
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            
            PottsMesh2_exposer.def( 
                "SetDistributedVectorFactory"
                , SetDistributedVectorFactory_function_type(&::AbstractMesh< 2, 2 >::SetDistributedVectorFactory)
                , default_SetDistributedVectorFactory_function_type(&PottsMesh_less__2__greater__wrapper::default_SetDistributedVectorFactory)
                , ( bp::arg("pFactory") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::SetElementOwnerships
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( PottsMesh_less__2__greater__wrapper::*SetElementOwnerships_function_type)(  ) ;
            
            PottsMesh2_exposer.def( 
                "SetElementOwnerships"
                , SetElementOwnerships_function_type( &PottsMesh_less__2__greater__wrapper::default_SetElementOwnerships ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            typedef void ( PottsMesh_less__2__greater__wrapper::*default_Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 2 > const & ) ;
            
            PottsMesh2_exposer.def( 
                "Translate"
                , Translate_function_type(&::AbstractMesh< 2, 2 >::Translate)
                , default_Translate_function_type(&PottsMesh_less__2__greater__wrapper::default_Translate)
                , ( bp::arg("rDisplacement") ) );
        
        }
        { //::AbstractMesh< 2, 2 >::Translate
        
            typedef PottsMesh< 2 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( double const,double const,double const ) ;
            
            PottsMesh2_exposer.def( 
                "Translate"
                , Translate_function_type( &::AbstractMesh< 2, 2 >::Translate )
                , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< PottsMesh<2> > >();
        bp::implicitly_convertible< boost::shared_ptr< PottsMesh< 2 > >, boost::shared_ptr< AbstractMesh< 2, 2 > > >();
    }

    { //::PottsMesh< 3 >
        typedef bp::class_< PottsMesh_less__3__greater__wrapper, bp::bases< AbstractMesh< 3, 3 > >, boost::noncopyable > PottsMesh3_exposer_t;
        PottsMesh3_exposer_t PottsMesh3_exposer = PottsMesh3_exposer_t( "PottsMesh3", bp::init< std::vector< Node<3> * >, std::vector< PottsElement<3> * >, std::vector< std::set< unsigned int > >, std::vector< std::set< unsigned int > > >(( bp::arg("nodes"), bp::arg("pottsElements"), bp::arg("vonNeumannNeighbouringNodeIndices"), bp::arg("mooreNeighbouringNodeIndices") )) );
        bp::scope PottsMesh3_scope( PottsMesh3_exposer );
        PottsMesh3_exposer.def( bp::init< >() );
        { //::PottsMesh< 3 >::AddElement
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*AddElement_function_type)( ::PottsElement< 3 > * ) ;
            
            PottsMesh3_exposer.def( 
                "AddElement"
                , AddElement_function_type( &::PottsMesh< 3 >::AddElement )
                , ( bp::arg("pNewElement") ) );
        
        }
        { //::PottsMesh< 3 >::Clear
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*Clear_function_type)(  ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_Clear_function_type)(  ) ;
            
            PottsMesh3_exposer.def( 
                "Clear"
                , Clear_function_type(&::PottsMesh< 3 >::Clear)
                , default_Clear_function_type(&PottsMesh_less__3__greater__wrapper::default_Clear) );
        
        }
        { //::PottsMesh< 3 >::ConstructFromMeshReader
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*ConstructFromMeshReader_function_type)( ::AbstractMeshReader< 3, 3 > & ) ;
            
            PottsMesh3_exposer.def( 
                "ConstructFromMeshReader"
                , ConstructFromMeshReader_function_type( &::PottsMesh< 3 >::ConstructFromMeshReader )
                , ( bp::arg("rMeshReader") ) );
        
        }
        { //::PottsMesh< 3 >::DeleteElement
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*DeleteElement_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "DeleteElement"
                , DeleteElement_function_type( &::PottsMesh< 3 >::DeleteElement )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 3 >::DeleteNode
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*DeleteNode_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "DeleteNode"
                , DeleteNode_function_type( &::PottsMesh< 3 >::DeleteNode )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 3 >::DivideElement
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*DivideElement_function_type)( ::PottsElement< 3 > *,bool ) ;
            
            PottsMesh3_exposer.def( 
                "DivideElement"
                , DivideElement_function_type( &::PottsMesh< 3 >::DivideElement )
                , ( bp::arg("pElement"), bp::arg("placeOriginalElementBelow")=(bool)(false) ) );
        
        }
        { //::PottsMesh< 3 >::GetCentroidOfElement
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetCentroidOfElement_function_type)( unsigned int ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( PottsMesh_less__3__greater__wrapper::*default_GetCentroidOfElement_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "GetCentroidOfElement"
                , GetCentroidOfElement_function_type(&::PottsMesh< 3 >::GetCentroidOfElement)
                , default_GetCentroidOfElement_function_type(&PottsMesh_less__3__greater__wrapper::default_GetCentroidOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 3 >::GetElementIteratorBegin
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::PottsMesh< 3 >::PottsElementIterator ( exported_class_t::*GetElementIteratorBegin_function_type)( bool ) ;
            
            PottsMesh3_exposer.def( 
                "GetElementIteratorBegin"
                , GetElementIteratorBegin_function_type( &::PottsMesh< 3 >::GetElementIteratorBegin )
                , ( bp::arg("skipDeletedElements")=(bool)(true) ) );
        
        }
        { //::PottsMesh< 3 >::GetElementIteratorEnd
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::PottsMesh< 3 >::PottsElementIterator ( exported_class_t::*GetElementIteratorEnd_function_type)(  ) ;
            
            PottsMesh3_exposer.def( 
                "GetElementIteratorEnd"
                , GetElementIteratorEnd_function_type( &::PottsMesh< 3 >::GetElementIteratorEnd ) );
        
        }
        { //::PottsMesh< 3 >::GetMooreNeighbouringNodeIndices
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetMooreNeighbouringNodeIndices_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "GetMooreNeighbouringNodeIndices"
                , GetMooreNeighbouringNodeIndices_function_type( &::PottsMesh< 3 >::GetMooreNeighbouringNodeIndices )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::PottsMesh< 3 >::GetNeighbouringElementIndices
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetNeighbouringElementIndices_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "GetNeighbouringElementIndices"
                , GetNeighbouringElementIndices_function_type( &::PottsMesh< 3 >::GetNeighbouringElementIndices )
                , ( bp::arg("elementIndex") ) );
        
        }
        { //::PottsMesh< 3 >::GetNumAllElements
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllElements_function_type)(  ) const;
            
            PottsMesh3_exposer.def( 
                "GetNumAllElements"
                , GetNumAllElements_function_type( &::PottsMesh< 3 >::GetNumAllElements ) );
        
        }
        { //::PottsMesh< 3 >::GetNumElements
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumElements_function_type)(  ) const;
            typedef unsigned int ( PottsMesh_less__3__greater__wrapper::*default_GetNumElements_function_type)(  ) const;
            
            PottsMesh3_exposer.def( 
                "GetNumElements"
                , GetNumElements_function_type(&::PottsMesh< 3 >::GetNumElements)
                , default_GetNumElements_function_type(&PottsMesh_less__3__greater__wrapper::default_GetNumElements) );
        
        }
        { //::PottsMesh< 3 >::GetNumNodes
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumNodes_function_type)(  ) const;
            typedef unsigned int ( PottsMesh_less__3__greater__wrapper::*default_GetNumNodes_function_type)(  ) const;
            
            PottsMesh3_exposer.def( 
                "GetNumNodes"
                , GetNumNodes_function_type(&::PottsMesh< 3 >::GetNumNodes)
                , default_GetNumNodes_function_type(&PottsMesh_less__3__greater__wrapper::default_GetNumNodes) );
        
        }
        { //::PottsMesh< 3 >::GetSurfaceAreaOfElement
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            typedef double ( PottsMesh_less__3__greater__wrapper::*default_GetSurfaceAreaOfElement_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "GetSurfaceAreaOfElement"
                , GetSurfaceAreaOfElement_function_type(&::PottsMesh< 3 >::GetSurfaceAreaOfElement)
                , default_GetSurfaceAreaOfElement_function_type(&PottsMesh_less__3__greater__wrapper::default_GetSurfaceAreaOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 3 >::GetVolumeOfElement
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetVolumeOfElement_function_type)( unsigned int ) ;
            typedef double ( PottsMesh_less__3__greater__wrapper::*default_GetVolumeOfElement_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "GetVolumeOfElement"
                , GetVolumeOfElement_function_type(&::PottsMesh< 3 >::GetVolumeOfElement)
                , default_GetVolumeOfElement_function_type(&PottsMesh_less__3__greater__wrapper::default_GetVolumeOfElement)
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 3 >::GetVonNeumannNeighbouringNodeIndices
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::std::set< unsigned int > ( exported_class_t::*GetVonNeumannNeighbouringNodeIndices_function_type)( unsigned int ) ;
            
            PottsMesh3_exposer.def( 
                "GetVonNeumannNeighbouringNodeIndices"
                , GetVonNeumannNeighbouringNodeIndices_function_type( &::PottsMesh< 3 >::GetVonNeumannNeighbouringNodeIndices )
                , ( bp::arg("nodeIndex") ) );
        
        }
        { //::PottsMesh< 3 >::RemoveDeletedElements
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*RemoveDeletedElements_function_type)(  ) ;
            
            PottsMesh3_exposer.def( 
                "RemoveDeletedElements"
                , RemoveDeletedElements_function_type( &::PottsMesh< 3 >::RemoveDeletedElements ) );
        
        }
        { //::PottsMesh< 3 >::SolveBoundaryElementMapping
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( PottsMesh_less__3__greater__wrapper::*SolveBoundaryElementMapping_function_type)( unsigned int ) const;
            
            PottsMesh3_exposer.def( 
                "SolveBoundaryElementMapping"
                , SolveBoundaryElementMapping_function_type( &PottsMesh_less__3__greater__wrapper::SolveBoundaryElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 3 >::SolveElementMapping
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( PottsMesh_less__3__greater__wrapper::*SolveElementMapping_function_type)( unsigned int ) const;
            
            PottsMesh3_exposer.def( 
                "SolveElementMapping"
                , SolveElementMapping_function_type( &PottsMesh_less__3__greater__wrapper::SolveElementMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::PottsMesh< 3 >::SolveNodeMapping
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( PottsMesh_less__3__greater__wrapper::*SolveNodeMapping_function_type)( unsigned int ) const;
            
            PottsMesh3_exposer.def( 
                "SolveNodeMapping"
                , SolveNodeMapping_function_type( &PottsMesh_less__3__greater__wrapper::default_SolveNodeMapping )
                , ( bp::arg("index") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::CalculateBoundingBox
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::ChasteCuboid< 3 > ( PottsMesh_less__3__greater__wrapper::*CalculateBoundingBox_function_type)( ::std::vector< Node<3> * > const & ) const;
            
            PottsMesh3_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type( &PottsMesh_less__3__greater__wrapper::CalculateBoundingBox )
                , ( bp::arg("rNodes") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::CalculateBoundingBox
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::ChasteCuboid< 3 > ( exported_class_t::*CalculateBoundingBox_function_type)(  ) const;
            typedef ::ChasteCuboid< 3 > ( PottsMesh_less__3__greater__wrapper::*default_CalculateBoundingBox_function_type)(  ) const;
            
            PottsMesh3_exposer.def( 
                "CalculateBoundingBox"
                , CalculateBoundingBox_function_type(&::AbstractMesh< 3, 3 >::CalculateBoundingBox)
                , default_CalculateBoundingBox_function_type(&PottsMesh_less__3__greater__wrapper::default_CalculateBoundingBox) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetNearestNodeIndex
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNearestNodeIndex_function_type)( ::ChastePoint< 3 > const & ) ;
            typedef unsigned int ( PottsMesh_less__3__greater__wrapper::*default_GetNearestNodeIndex_function_type)( ::ChastePoint< 3 > const & ) ;
            
            PottsMesh3_exposer.def( 
                "GetNearestNodeIndex"
                , GetNearestNodeIndex_function_type(&::AbstractMesh< 3, 3 >::GetNearestNodeIndex)
                , default_GetNearestNodeIndex_function_type(&PottsMesh_less__3__greater__wrapper::default_GetNearestNodeIndex)
                , ( bp::arg("rTestPoint") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetNumAllNodes
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef unsigned int ( exported_class_t::*GetNumAllNodes_function_type)(  ) const;
            typedef unsigned int ( PottsMesh_less__3__greater__wrapper::*default_GetNumAllNodes_function_type)(  ) const;
            
            PottsMesh3_exposer.def( 
                "GetNumAllNodes"
                , GetNumAllNodes_function_type(&::AbstractMesh< 3, 3 >::GetNumAllNodes)
                , default_GetNumAllNodes_function_type(&PottsMesh_less__3__greater__wrapper::default_GetNumAllNodes) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetVectorFromAtoB
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( exported_class_t::*GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            typedef ::boost::numeric::ublas::c_vector< double, 3 > ( PottsMesh_less__3__greater__wrapper::*default_GetVectorFromAtoB_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const &,::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            
            PottsMesh3_exposer.def( 
                "GetVectorFromAtoB"
                , GetVectorFromAtoB_function_type(&::AbstractMesh< 3, 3 >::GetVectorFromAtoB)
                , default_GetVectorFromAtoB_function_type(&PottsMesh_less__3__greater__wrapper::default_GetVectorFromAtoB)
                , ( bp::arg("rLocationA"), bp::arg("rLocationB") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::GetWidth
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef double ( exported_class_t::*GetWidth_function_type)( unsigned int const & ) const;
            typedef double ( PottsMesh_less__3__greater__wrapper::*default_GetWidth_function_type)( unsigned int const & ) const;
            
            PottsMesh3_exposer.def( 
                "GetWidth"
                , GetWidth_function_type(&::AbstractMesh< 3, 3 >::GetWidth)
                , default_GetWidth_function_type(&PottsMesh_less__3__greater__wrapper::default_GetWidth)
                , ( bp::arg("rDimension") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::PermuteNodes
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*PermuteNodes_function_type)(  ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_PermuteNodes_function_type)(  ) ;
            
            PottsMesh3_exposer.def( 
                "PermuteNodes"
                , PermuteNodes_function_type(&::AbstractMesh< 3, 3 >::PermuteNodes)
                , default_PermuteNodes_function_type(&PottsMesh_less__3__greater__wrapper::default_PermuteNodes) );
        
        }
        { //::AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_ReadNodesPerProcessorFile_function_type)( ::std::string const & ) ;
            
            PottsMesh3_exposer.def( 
                "ReadNodesPerProcessorFile"
                , ReadNodesPerProcessorFile_function_type(&::AbstractMesh< 3, 3 >::ReadNodesPerProcessorFile)
                , default_ReadNodesPerProcessorFile_function_type(&PottsMesh_less__3__greater__wrapper::default_ReadNodesPerProcessorFile)
                , ( bp::arg("rNodesPerProcessorFile") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::RefreshMesh
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*RefreshMesh_function_type)(  ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_RefreshMesh_function_type)(  ) ;
            
            PottsMesh3_exposer.def( 
                "RefreshMesh"
                , RefreshMesh_function_type(&::AbstractMesh< 3, 3 >::RefreshMesh)
                , default_RefreshMesh_function_type(&PottsMesh_less__3__greater__wrapper::default_RefreshMesh) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_Rotate_function_type)( ::boost::numeric::ublas::c_matrix< double, 3, 3 > ) ;
            
            PottsMesh3_exposer.def( 
                "Rotate"
                , Rotate_function_type(&::AbstractMesh< 3, 3 >::Rotate)
                , default_Rotate_function_type(&PottsMesh_less__3__greater__wrapper::default_Rotate)
                , ( bp::arg("rotationMatrix") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 >,double ) ;
            
            PottsMesh3_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 3, 3 >::Rotate )
                , ( bp::arg("axis"), bp::arg("angle") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Rotate
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*Rotate_function_type)( double ) ;
            
            PottsMesh3_exposer.def( 
                "Rotate"
                , Rotate_function_type( &::AbstractMesh< 3, 3 >::Rotate )
                , ( bp::arg("theta") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Scale
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*Scale_function_type)( double const,double const,double const ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_Scale_function_type)( double const,double const,double const ) ;
            
            PottsMesh3_exposer.def( 
                "Scale"
                , Scale_function_type(&::AbstractMesh< 3, 3 >::Scale)
                , default_Scale_function_type(&PottsMesh_less__3__greater__wrapper::default_Scale)
                , ( bp::arg("xFactor")=1., bp::arg("yFactor")=1., bp::arg("zFactor")=1. ) );
        
        }
        { //::AbstractMesh< 3, 3 >::SetDistributedVectorFactory
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_SetDistributedVectorFactory_function_type)( ::DistributedVectorFactory * ) ;
            
            PottsMesh3_exposer.def( 
                "SetDistributedVectorFactory"
                , SetDistributedVectorFactory_function_type(&::AbstractMesh< 3, 3 >::SetDistributedVectorFactory)
                , default_SetDistributedVectorFactory_function_type(&PottsMesh_less__3__greater__wrapper::default_SetDistributedVectorFactory)
                , ( bp::arg("pFactory") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::SetElementOwnerships
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( PottsMesh_less__3__greater__wrapper::*SetElementOwnerships_function_type)(  ) ;
            
            PottsMesh3_exposer.def( 
                "SetElementOwnerships"
                , SetElementOwnerships_function_type( &PottsMesh_less__3__greater__wrapper::default_SetElementOwnerships ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Translate
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            typedef void ( PottsMesh_less__3__greater__wrapper::*default_Translate_function_type)( ::boost::numeric::ublas::c_vector< double, 3 > const & ) ;
            
            PottsMesh3_exposer.def( 
                "Translate"
                , Translate_function_type(&::AbstractMesh< 3, 3 >::Translate)
                , default_Translate_function_type(&PottsMesh_less__3__greater__wrapper::default_Translate)
                , ( bp::arg("rDisplacement") ) );
        
        }
        { //::AbstractMesh< 3, 3 >::Translate
        
            typedef PottsMesh< 3 > exported_class_t;
            typedef void ( exported_class_t::*Translate_function_type)( double const,double const,double const ) ;
            
            PottsMesh3_exposer.def( 
                "Translate"
                , Translate_function_type( &::AbstractMesh< 3, 3 >::Translate )
                , ( bp::arg("xMovement")=0., bp::arg("yMovement")=0., bp::arg("zMovement")=0. ) );
        
        }
        bp::register_ptr_to_python< boost::shared_ptr< PottsMesh<3> > >();
        bp::implicitly_convertible< boost::shared_ptr< PottsMesh< 3 > >, boost::shared_ptr< AbstractMesh< 3, 3 > > >();
    }

    bp::class_< SharedHoneycombMeshGenerator_wrapper >( "HoneycombMeshGenerator", bp::init< unsigned int, unsigned int, bp::optional< unsigned int, double > >(( bp::arg("numNodesAlongWidth"), bp::arg("numNodesAlongLength"), bp::arg("ghosts")=(unsigned int)(0), bp::arg("scaleFactor")=1. )) )    
        .def( bp::init< >() )    
        .def( 
            "GetCellLocationIndices"
            , (::std::vector< unsigned int > ( ::SharedHoneycombMeshGenerator::* )(  ))( &::SharedHoneycombMeshGenerator::GetCellLocationIndices ) )    
        .def( 
            "GetCircularMesh"
            , (::boost::shared_ptr< MutableMesh< 2, 2 > > ( ::SharedHoneycombMeshGenerator::* )( double ))( &::SharedHoneycombMeshGenerator::GetCircularMesh )
            , ( bp::arg("radius") ) )    
        .def( 
            "GetDomainDepth"
            , (double ( ::SharedHoneycombMeshGenerator::* )(  ))( &::SharedHoneycombMeshGenerator::GetDomainDepth ) )    
        .def( 
            "GetDomainWidth"
            , (double ( ::SharedHoneycombMeshGenerator::* )(  ))( &::SharedHoneycombMeshGenerator::GetDomainWidth ) )    
        .def( 
            "GetMesh"
            , (::boost::shared_ptr< MutableMesh< 2, 2 > > ( ::SharedHoneycombMeshGenerator::* )(  ))(&::SharedHoneycombMeshGenerator::GetMesh)
            , (::boost::shared_ptr< MutableMesh< 2, 2 > > ( SharedHoneycombMeshGenerator_wrapper::* )(  ))(&SharedHoneycombMeshGenerator_wrapper::default_GetMesh) );

    bp::class_< SharedHoneycombVertexMeshGenerator_wrapper >( "HoneycombVertexMeshGenerator", bp::init< unsigned int, unsigned int, bp::optional< bool, double, double, double > >(( bp::arg("numElementsAcross"), bp::arg("numElementsUp"), bp::arg("isFlatBottom")=(bool)(false), bp::arg("cellRearrangementThreshold")=0.01, bp::arg("t2Threshold")=0.001, bp::arg("elementArea")=0.5 * sqrt(3.) )) )    
        .def( bp::init< >() )    
        .def( 
            "GetMesh"
            , (::boost::shared_ptr< MutableVertexMesh< 2, 2 > > ( ::SharedHoneycombVertexMeshGenerator::* )(  ))(&::SharedHoneycombVertexMeshGenerator::GetMesh)
            , (::boost::shared_ptr< MutableVertexMesh< 2, 2 > > ( SharedHoneycombVertexMeshGenerator_wrapper::* )(  ))(&SharedHoneycombVertexMeshGenerator_wrapper::default_GetMesh) );

    bp::class_< SharedPottsMeshGenerator_less__2__greater__wrapper >( "SharedPottsMeshGenerator2", bp::init< unsigned int, unsigned int, unsigned int, bp::optional< unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, bool, bool, bool, bool > >(( bp::arg("numNodesAcross"), bp::arg("numElementsAcross"), bp::arg("elementWidth"), bp::arg("numNodesUp")=(unsigned int)(1U), bp::arg("numElementsUp")=(unsigned int)(1U), bp::arg("elementHeight")=(unsigned int)(1U), bp::arg("numNodesDeep")=(unsigned int)(1U), bp::arg("numElementsDeep")=(unsigned int)(1U), bp::arg("elementDepth")=(unsigned int)(1U), bp::arg("startAtBottomLeft")=(bool)(false), bp::arg("isPeriodicInX")=(bool)(false), bp::arg("isPeriodicInY")=(bool)(false), bp::arg("isPeriodicInZ")=(bool)(false) )) )    
        .def( bp::init< >() )    
        .def( 
            "GetMesh"
            , (::boost::shared_ptr< PottsMesh< 2 > > ( ::SharedPottsMeshGenerator<2>::* )(  ))(&::SharedPottsMeshGenerator< 2 >::GetMesh)
            , (::boost::shared_ptr< PottsMesh< 2 > > ( SharedPottsMeshGenerator_less__2__greater__wrapper::* )(  ))(&SharedPottsMeshGenerator_less__2__greater__wrapper::default_GetMesh) );

    bp::class_< SharedPottsMeshGenerator_less__3__greater__wrapper >( "PottsMeshGenerator3", bp::init< unsigned int, unsigned int, unsigned int, bp::optional< unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, bool, bool, bool, bool > >(( bp::arg("numNodesAcross"), bp::arg("numElementsAcross"), bp::arg("elementWidth"), bp::arg("numNodesUp")=(unsigned int)(1U), bp::arg("numElementsUp")=(unsigned int)(1U), bp::arg("elementHeight")=(unsigned int)(1U), bp::arg("numNodesDeep")=(unsigned int)(1U), bp::arg("numElementsDeep")=(unsigned int)(1U), bp::arg("elementDepth")=(unsigned int)(1U), bp::arg("startAtBottomLeft")=(bool)(false), bp::arg("isPeriodicInX")=(bool)(false), bp::arg("isPeriodicInY")=(bool)(false), bp::arg("isPeriodicInZ")=(bool)(false) )) )    
        .def( bp::init< >() )    
        .def( 
            "GetMesh"
            , (::boost::shared_ptr< PottsMesh< 3 > > ( ::SharedPottsMeshGenerator<3>::* )(  ))(&::SharedPottsMeshGenerator< 3 >::GetMesh)
            , (::boost::shared_ptr< PottsMesh< 3 > > ( SharedPottsMeshGenerator_less__3__greater__wrapper::* )(  ))(&SharedPottsMeshGenerator_less__3__greater__wrapper::default_GetMesh) );

    { //::Instantiation
    
        typedef int ( *Instantiation_function_type )(  );
        
        bp::def( 
            "Instantiation"
            , Instantiation_function_type( &::Instantiation ) );
    
    }
}
